SCRIPT  /usr/local/Cellar/vim/8.1.0100/share/vim/vim81/scripts.vim
Sourced 2 times
Total time:   0.002608
 Self time:   0.002608

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2018 Feb 03
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    2              0.000012 if did_filetype()
                              finish
                            endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    2              0.000012 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
                            endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    2              0.000017 let s:cpo_save = &cpo
    2              0.000019 set cpo&vim
                            
    2              0.000009 let s:line1 = getline(1)
                            
    2              0.000013 if s:line1 =~# "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make
                            
                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike
                            
                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~# 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~# 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby
                            
                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript
                            
                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~# 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang
                            
                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell
                            
                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala
                            
                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure
                            
                              endif
                              unlet s:name
                            
                            else
                              " File does not start with "#!".
                            
    2              0.000010   let s:line2 = getline(2)
    2              0.000005   let s:line3 = getline(3)
    2              0.000005   let s:line4 = getline(4)
    2              0.000004   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    2              0.000009   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " Z shell scripts
                              elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
                              elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                                " Mason
                              elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason
                            
                                " Vim scripts (must have '" vim' as the first line to trigger this)
                              elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim
                            
                                " MOO
                              elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
                              elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
                              elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
                              elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
                              elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
                              elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
                              elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
                              elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                              elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
                              elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
                              elseif s:line1 =~# '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
                              elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
                              elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
                              elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
                              elseif s:line1 =~# '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
                              elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
                              elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
                              elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
                              elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
                              elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
                              elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
                              elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
                              elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
                              elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
                              elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
                              elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
                              elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
                              elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan
                            
                              " Valgrind
                              elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
                              elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
                              elseif s:line1 =~# '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
                              elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
                              elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
                               elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
                              elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " CVS diff
                              else
    2              0.000007     let s:lnum = 1
    2              0.000014     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
                                endwhile
    2              0.000011     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
                                endif
    2              0.000005     unlet s:lnum
                            
    2              0.000002   endif
                            
    2              0.000005   unlet s:line2 s:line3 s:line4 s:line5
                            
    2              0.000001 endif
                            
                            " Restore 'cpoptions'
    2              0.000016 let &cpo = s:cpo_save
                            
    2              0.000014 unlet s:cpo_save s:line1

SCRIPT  /usr/local/Cellar/vim/8.1.0100/share/vim/vim81/ftplugin/vim.vim
Sourced 2 times
Total time:   0.000741
 Self time:   0.000741

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2017 Dec 05
                            
                            " Only do this when not done yet for this buffer
    2              0.000014 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Don't load another plugin for this buffer
    2              0.000007 let b:did_ftplugin = 1
                            
    2              0.000009 let s:cpo_save = &cpo
    2              0.000015 set cpo-=C
                            
    2              0.000011 let b:undo_ftplugin = "setl fo< isk< com< tw< commentstring<"
                            	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    2              0.000019 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    2              0.000065 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    2              0.000007 setlocal keywordprg=:help
                            
                            " Set 'comments' to format dashed lists in comments
    2              0.000012 setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                            
                            " Format comments to be up to 78 characters long
    2              0.000006 if &tw == 0
    2              0.000012   setlocal tw=78
    2              0.000002 endif
                            
                            " Comments start with a double quote
    2              0.000008 setlocal commentstring=\"%s
                            
    2              0.000012 if !exists("no_plugin_maps") && !exists("no_vim_maps")
                              " Move around functions.
    2              0.000044   nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
    2              0.000031   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
    2              0.000022   nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
    2              0.000027   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
    2              0.000023   nnoremap <silent><buffer> [] m':call search('^\s*endf*\%[unction]\>', "bW")<CR>
    2              0.000027   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "bW")<CR>
    2              0.000021   nnoremap <silent><buffer> ][ m':call search('^\s*endf*\%[unction]\>', "W")<CR>
    2              0.000026   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "W")<CR>
                            
                              " Move around comments
    2              0.000022   nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    2              0.000026   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    2              0.000022   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    2              0.000028   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    2              0.000002 endif
                            
                            " Let the matchit plugin know what items can be matched.
    2              0.000007 if exists("loaded_matchit")
                              let b:match_ignorecase = 0
                              let b:match_words =
                            	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
                             	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
                            	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' .
                            	\ '(:)'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ â€¦
                              let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
                            endif
                            
    2              0.000015 let &cpo = s:cpo_save
    2              0.000006 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /usr/local/Cellar/vim/8.1.0100/share/vim/vim81/indent/vim.vim
Sourced 2 times
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Jun 27
                            
                            " Only load this indent file when no other was loaded.
    2              0.000013 if exists("b:did_indent")
                              finish
                            endif
    2              0.000006 let b:did_indent = 1
                            
    2              0.000012 setlocal indentexpr=GetVimIndent()
    2              0.000009 setlocal indentkeys+==end,=else,=cat,=fina,=END,0\\
                            
    2              0.000006 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    2              0.000008 if exists("*GetVimIndent")
    1              0.000001   finish
                            endif
    1              0.000005 let s:keepcpo= &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000002 function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
    1              0.000002 function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' and below a line that starts
                              " with '\', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ '^\s*\\'
                                while lnum > 0 && getline(lnum) =~ '^\s*\\'
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                              let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' after
                              " a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                              if cur_text =~ '^\s*\\' && v:lnum > 1 && prev_text !~ '^\s*\\'
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                if prev_text !~ '^\s*au\%[tocmd]'
                                  let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
    1              0.000008 let &cpo = s:keepcpo
    1              0.000002 unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/local/Cellar/vim/8.1.0100/share/vim/vim81/syntax/vim.vim
Sourced 2 times
Total time:   0.037646
 Self time:   0.017888

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Vim 8.0 script
                            " Maintainer:	Charles E. Campbell <NdrOchipS@PcampbellAfamily.Mbiz>
                            " Last Change:	April 30, 2018
                            " Version:	8.0-14
                            " URL:	http://www.drchip.org/astronaut/vim/index.html#SYNTAX_VIM
                            " Automatically generated keyword lists: {{{1
                            
                            " Quit when a syntax file was already loaded {{{2
    2              0.000011 if exists("b:current_syntax")
                              finish
                            endif
    2              0.000013 let s:keepcpo= &cpo
    2              0.000015 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    2              0.000060 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    2              0.000018 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " regular vim commands {{{2
    2              0.000297 syn keyword vimCommand contained	a arga[dd] argu[ment] bad[d] bn[ext] breakd[el] bw[ipeout] cadde[xpr] cc cf[ile] changes cla[st] cnf[ile] comp[iler] cq[uit] cw[indow] delep dell diffg[et] dig[raphs] doau ea el[se] endt[ry] f[ile] fina[lly] foldd[oopen] go[to] ha[rdcopy] hid[e] ij[ump] isp[lit] keepa l[ist] lat lcl[ose] lex[pr] lgete[xpr] lla[st] lnf[ile] lol[der] lt[ag] lw[indow] menut[ranslate] mkv[imrc] n[ext] nmapc[lear] nore omapc[lear] pa[ckadd] perld[o] prev[ious] promptr[epl] ptj[ump] pts[elect] py[thon] pyx quita[ll] redr[aw] retu[rn] rub[y] sI sIn sal[l] sba[ll] sbp[revious] scg scripte[ncoding] setg[lobal] sgI sgn sic sim[alt] sla[st] smile so[urce] spelli[nfo] sr sri sta[g] stopi[nsert] sus[pend] sync ta[g] tabe[dit] tabn[ext] tabs te[aroff] tm[enu] to[pleft] tu[nmenu] undol[ist] up[date] vi[sual] vmapc[lear] wa[ll] winp[os] ws[verb] xmapc[lear] xprop
    2              0.000276 syn keyword vimCommand contained	ab argd[elete] as[cii] bd[elete] bo[tright] breakl[ist] cN[ext] caddf[ile] ccl[ose] cfdo chd[ir] cle[arjumps] co[py] con[tinue] cr[ewind] d[elete] deletel delm[arks] diffo[ff] dir dp earlier elsei[f] endw[hile] files fini[sh] folddoc[losed] gr[ep] helpc[lose] his[tory] il[ist] iuna[bbrev] keepalt la[st] later lcs lf[ile] lgr[ep] lli[st] lo[adview] lop[en] lua m[ove] mes mkvie[w] nb[key] noa nos[wapfile] on[ly] packl[oadall] po[p] pro ps[earch] ptl[ast] pu[t] pydo pyxdo r[ead] redraws[tatus] rew[ind] rubyd[o] sIc sIp san[dbox] sbf[irst] sbr[ewind] sci scs setl[ocal] sgc sgp sie sin sm[agic] sn[ext] sor[t] spellr[epall] srI srl star[tinsert] sts[elect] sv[iew] syncbind tab tabf[ind] tabnew tags tf[irst] tma[p] tp[revious] tunma[p] unh[ide] v vie[w] vne[w] wh[ile] wn[ext] wundo xme xunme
    2              0.002633 syn keyword vimCommand contained	abc[lear] argdo au bel[owright] bp[revious] bro[wse] cNf[ile] cal[l] cd cfir[st] che[ckpath] clo[se] col[der] conf[irm] cs debug deletep delp diffp[atch] dj[ump] dr[op] ec em[enu] ene[w] filet fir[st] foldo[pen] grepa[dd] helpf[ind] i imapc[lear] j[oin] keepj[umps] lad[dexpr] lb[uffer] lcscope lfdo lgrepa[dd] lmak[e] loadk lp[revious] luado ma[rk] messages mod[e] nbc[lose] noautocmd nu[mber] opt[ions] pc[lose] popu[p] prof[ile] ptN[ext] ptn[ext] pw[d] pyf[ile] pyxfile rec[over] reg[isters] ri[ght] rubyf[ile] sIe sIr sav[eas] sbl[ast] sc scl scscope sf[ind] sge sgr sig sip sm[ap] sno[magic] sp[lit] spellu[ndo] src srn startg[replace] sun[hide] sw[apname] syntime tabN[ext] tabfir[st] tabo[nly] tc[l] th[row] tmapc[lear] tr[ewind] u[ndo] unl ve[rsion] vim[grep] vs[plit] win[size] wp[revious] wv[iminfo] xmenu xunmenu
    2              0.000156 syn keyword vimCommand contained	abo[veleft] arge[dit] bN[ext] bf[irst] br[ewind] bufdo c[hange] cat[ch] cdo cg[etfile] checkt[ime] cmapc[lear] colo[rscheme] cope[n] cscope debugg[reedy] deletl dep diffpu[t] dl ds[earch] echoe[rr] en[dif] ex filetype fix[del] for gui helpg[rep] ia in ju[mps] keepp[atterns] laddb[uffer] lbo[ttom] ld[o] lfir[st] lh[elpgrep] lmapc[lear] loadkeymap lpf[ile] luafile mak[e] mk[exrc] mz[scheme] nbs[tart] noh[lsearch] o[pen] ownsyntax pe[rl] pp[op] profd[el] pta[g] ptp[revious] py3 python3 q[uit] red[o] res[ize] rightb[elow] rundo sIg sN[ext] sbN[ext] sbm[odified] scI scp se[t] sfir[st] sgi sh[ell] sign sir sme snoreme spe[llgood] spellw[rong] sre[wind] srp startr[eplace] sunme sy t tabc[lose] tabl[ast] tabp[revious] tcld[o] tj[ump] tn[ext] try una[bbreviate] unlo[ckvar] verb[ose] vimgrepa[dd] wN[ext] winc[md] wq x[it] xnoreme xwininfo
    2              0.000170 syn keyword vimCommand contained	al[l] argg[lobal] b[uffer] bl[ast] brea[k] buffers cabc[lear] cb[uffer] ce[nter] cgetb[uffer] chi[story] cn[ext] com cp[revious] cstag delc[ommand] deletp di[splay] diffs[plit] dli[st] dsp[lit] echom[sg] endf[unction] exi[t] filt[er] fo[ld] fu[nction] gvim helpt[ags] iabc[lear] intro k lN[ext] laddf[ile] lc[d] le[ft] lg[etfile] lhi[story] lne[xt] loc[kmarks] lr[ewind] lv[imgrep] marks mks[ession] mzf[ile] new nor ol[dfiles] p[rint] ped[it] pre[serve] promptf[ind] ptf[irst] ptr[ewind] py3do pythonx qa[ll] redi[r] ret[ab] ru[ntime] rv[iminfo] sIl sa[rgument] sb[uffer] sbn[ext] sce scr[iptnames] setf[iletype] sg sgl si sil[ent] sl[eep] smenu snoremenu spelld[ump] spr[evious] srg st[op] stj[ump] sunmenu syn tN[ext] tabd[o] tabm[ove] tabr[ewind] tclf[ile] tl[ast] tno[remap] ts[elect] undoj[oin] uns[ilent] vert[ical] viu[sage] w[rite] windo wqa[ll] xa[ll] xnoremenu y[ank]
    2              0.000082 syn keyword vimCommand contained	ar[gs] argl[ocal] ba[ll] bm[odified] breaka[dd] bun[load] cad[dbuffer] cbo[ttom] cex[pr] cgete[xpr] cl[ist] cnew[er] comc[lear] cpf[ile] cuna[bbrev] delel delf[unction] dif[fupdate] difft[his] do e[dit] echon endfo[r] exu[sage] fin[d] foldc[lose] g h[elp] hi if is[earch] kee[pmarks] lNf[ile] lan[guage] lch[dir] lefta[bove] lgetb[uffer] ll lnew[er] lockv[ar] ls lvimgrepa[dd] mat[ch] mksp[ell]
    2              0.000010 syn keyword vimCommand contained	ter[minal]
                            
    2              0.000017 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    2              0.000019 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] P[rint] S TOhtml XMLent XMLns
                            
                            " vimOptions are caught only when contained in a vimSet {{{2
    2              0.000073 syn keyword vimOption contained	acd ambw arshape background ballooneval bex bl brk buftype cf cinkeys cmdwinheight com conceallevel crb cscopeverbose cuc def diffexpr ea ei ep eventignore fdi fenc fileformat fkmap foldexpr foldopen fsync gfw guicursor guitabtooltip hidden hlg imactivatefunc imi inc inex isident keymap langnoremap linespace lnr lw makeprg maxmem mfd mmd modified mousemodel msm nu omnifunc para pdev pheader preserveindent printheader pumwidth pythonthreehome readonly restorescreen rnu ruf sc scrolloff selection shellcmdflag shellxescape showbreak si sm so spellfile spr st sts swapsync syn tag tal tcldll termwinscroll tgc titlelen toolbariconsize ttimeout ttymouse tx undolevels vbs viewdir vop wd wic wildmode winheight wm wrapscan
    2              0.000067 syn keyword vimOption contained	ai anti autochdir backspace balloonevalterm bexpr bo browsedir casemap cfu cino cmp comments confirm cryptmethod cspc cul define diffopt ead ek equalalways ex fdl fencs fileformats flp foldignore foldtext ft ghr guifont helpfile highlight hls imactivatekey iminsert include inf isk keymodel langremap lisp loadplugins lz mat maxmempattern mh mmp more mouses mzq number opendevice paragraphs penc pi previewheight printmbcharset pvh pyx redrawtime revins ro ruler scb scrollopt selectmode shellpipe shellxquote showcmd sidescroll smartcase softtabstop spelllang sps sta su swb synmaxcol tagbsearch tb tenc termwinsize tgst titleold top ttimeoutlen ttyscroll uc undoreload vdir viewoptions wa weirdinvert wig wildoptions winminheight wmh write
    2              0.000067 syn keyword vimOption contained	akm antialias autoindent backup balloonexpr bg bomb bs cb ch cinoptions cms commentstring copyindent cscopepathcomp csprg cursorbind delcombine digraph eadirection emo equalprg expandtab fdls fex fileignorecase fml foldlevel formatexpr gcr go guifontset helpheight history hlsearch imaf ims includeexpr infercase iskeyword keywordprg laststatus lispwords lpl ma matchpairs maxmemtot mis mmt mouse mouseshape mzquantum numberwidth operatorfunc paste perldll pm previewwindow printmbfont pvw pyxversion regexpengine ri rop rulerformat scl scs sessionoptions shellquote shiftround showfulltag sidescrolloff smartindent sol spellsuggest sr stal sua swf syntax tagcase tbi term terse thesaurus titlestring tpm ttm ttytype udf updatecount ve vif wak wfh wildchar wim winminwidth wmnu writeany
    2              0.000065 syn keyword vimOption contained	al ar autoread backupcopy bdir bh breakat bsdir cc charconvert cinw co compatible cot cscopeprg csqf cursorcolumn dex dip eb emoji errorbells exrc fdm ff filetype fmr foldlevelstart formatlistpat gd gp guifontwide helplang hk ic imak imsearch incsearch insertmode isp km lazyredraw list lrm macatsui matchtime mco mkspellmem mod mousef mouset mzschemedll nuw opfunc pastetoggle pex pmbcs printdevice printoptions pw qe relativenumber rightleft rs runtimepath scr sect sft shellredir shiftwidth showmatch signcolumn smarttab sp spf srr startofline suffixes switchbuf ta taglength tbidi termbidi textauto tildeop tl tr tty tw udir updatetime verbose viminfo warn wfw wildcharm winaltkeys winptydll wmw writebackup
    2              0.000075 syn keyword vimOption contained	aleph arab autowrite backupdir bdlay bin breakindent bsk ccv ci cinwords cocu complete cp cscopequickfix csre cursorline dg dir ed enc errorfile fcl fdn ffs fillchars fo foldmarker formatoptions gdefault grepformat guiheadroom hf hkmap icon imc imsf inde is isprint kmp lbr listchars ls magic maxcombine mef ml modeline mousefocus mousetime mzschemegcdll odev osfiletype patchexpr pexpr pmbfn printencoding prompt pythondll quoteescape remap rightleftcmd rtp sb scroll sections sh shellslash shm showmode siso smc spc spl ss statusline suffixesadd sws tabline tagrelative tbis termencoding textmode timeout tm ts ttybuiltin twk ul ur verbosefile viminfofile wb wh wildignore window winwidth wop writedelay
    2              0.000069 syn keyword vimOption contained	allowrevins arabic autowriteall backupext belloff binary breakindentopt bt cd cin clipboard cole completefunc cpo cscoperelative cst cwh dict directory edcompatible encoding errorformat fcs fdo fic fixendofline foldclose foldmethod formatprg gfm grepprg guioptions hh hkmapp iconstring imcmdline imst indentexpr isf joinspaces kp lcs lm lsp makeef maxfuncdepth menc mls modelines mousehide mp nf oft pa patchmode pfn popt printexpr pt pythonhome rdt renderoptions rl ru sbo scrollbind secure shcf shelltemp shortmess showtabline sj smd spell splitbelow ssl stl sw sxe tabpagemax tags tbs termguicolors textwidth timeoutlen to tsl ttyfast tws undodir ut vfile virtualedit wc whichwrap wildignorecase winfixheight wiv wrap ws
    2              0.000061 syn keyword vimOption contained	altkeymap arabicshape aw backupskip beval bk bri bufhidden cdpath cindent cm colorcolumn completeopt cpoptions cscopetag csto debug dictionary display ef endofline esckeys fdc fdt fileencoding fixeol foldcolumn foldminlines fp gfn gtl guipty hi hkp ignorecase imd imstatusfunc indentkeys isfname js langmap linebreak lmap luadll makeencoding maxmapdepth menuitems mm modifiable mousem mps nrformats ofu packpath path ph pp printfont pumheight pythonthreedll re report rlc rubydll sbr scrolljump sel shell shelltype shortname shq slm sn spellcapcheck splitright ssop stmp swapfile sxq tabstop tagstack tc termwinkey tf title toolbar tsr ttym twsl undofile vb vi visualbell wcm wi wildmenu winfixwidth wiw wrapmargin ww
    2              0.000032 syn keyword vimOption contained	ambiwidth ari awa balloondelay bevalterm bkc briopt buflisted cedit cink cmdheight columns concealcursor cpt cscopetagorder csverb deco diff dy efm eol et fde fen fileencodings fk foldenable foldnestmax fs gfs gtt guitablabel hid hl im imdisable imstyle indk isi key langmenu lines
                            
                            " vimOptions: These are the turn-off setting variants {{{2
    2              0.000072 syn keyword vimOption contained	noacd noallowrevins noantialias noarabic noarshape noautoread noaw noballooneval nobevalterm nobk nobreakindent nocf nocindent nocopyindent nocscoperelative nocsre nocuc nocursorcolumn nodelcombine nodigraph noed noemo noeol noesckeys noexpandtab nofic nofixeol nofoldenable nogd nohid nohkmap nohls noicon noimc noimdisable noinfercase nojoinspaces nolangremap nolinebreak nolist noloadplugins nolrm noma nomagic noml nomodeline nomodified nomousef nomousehide nonumber noopendevice nopi nopreviewwindow nopvw norelativenumber norestorescreen nori norl noro noru nosb noscb noscs nosft noshelltemp noshortname noshowfulltag noshowmode nosm nosmartindent nosmd nosol nosplitbelow nospr nossl nostartofline noswapfile nota notagrelative notbi notbs noterse notextmode notgst notimeout noto notr nottybuiltin notx noundofile novisualbell nowarn noweirdinvert nowfw nowildignorecase nowinfixheight nowiv nowrap nowrite nowritebackup
    2              0.000212 syn keyword vimOption contained	noai noaltkeymap noar noarabicshape noautochdir noautowrite noawa noballoonevalterm nobin nobl nobri noci nocompatible nocp nocscopetag nocst nocul nocursorline nodg noea noedcompatible noemoji noequalalways noet noexrc nofileignorecase nofk nofs nogdefault nohidden nohkmapp nohlsearch noignorecase noimcmdline noincsearch noinsertmode nojs nolazyredraw nolisp nolnr nolpl nolz nomacatsui nomh nomod nomodifiable nomore nomousefocus nonu noodev nopaste nopreserveindent noprompt noreadonly noremap norevins norightleft nornu nors noruler nosc noscrollbind nosecure noshellslash noshiftround noshowcmd noshowmatch nosi nosmartcase nosmarttab nosn nospell nosplitright nosr nosta nostmp noswf notagbsearch notagstack notbidi notermbidi notextauto notf notildeop notitle notop nottimeout nottyfast noudf novb nowa nowb nowfh nowic nowildmenu nowinfixwidth nowmnu nowrapscan nowriteany nows
    2              0.000031 syn keyword vimOption contained	noakm noanti noarab noari noautoindent noautowriteall nobackup nobeval nobinary nobomb nobuflisted nocin noconfirm nocrb nocscopeverbose nocsverb nocursorbind nodeco nodiff noeb noek noendofline noerrorbells noex nofen nofixendofline nofkmap nofsync noguipty nohk nohkp noic noim noimd noinf nois nolangnoremap nolbr
                            
                            " vimOptions: These are the invertible variants {{{2
    2              0.000081 syn keyword vimOption contained	invacd invallowrevins invantialias invarabic invarshape invautoread invaw invballooneval invbevalterm invbk invbreakindent invcf invcindent invcopyindent invcscoperelative invcsre invcuc invcursorcolumn invdelcombine invdigraph inved invemo inveol invesckeys invexpandtab invfic invfixeol invfoldenable invgd invhid invhkmap invhls invicon invimc invimdisable invinfercase invjoinspaces invlangremap invlinebreak invlist invloadplugins invlrm invma invmagic invml invmodeline invmodified invmousef invmousehide invnumber invopendevice invpi invpreviewwindow invpvw invrelativenumber invrestorescreen invri invrl invro invru invsb invscb invscs invsft invshelltemp invshortname invshowfulltag invshowmode invsm invsmartindent invsmd invsol invsplitbelow invspr invssl invstartofline invswapfile invta invtagrelative invtbi invtbs invterse invtextmode invtgst invtimeout invto invtr invttybuiltin invtx invundofile invvisualbell invwarn invweirdinvert invwfw invwildignorecase invwinfixheight 
    2              0.000078 syn keyword vimOption contained	invai invaltkeymap invar invarabicshape invautochdir invautowrite invawa invballoonevalterm invbin invbl invbri invci invcompatible invcp invcscopetag invcst invcul invcursorline invdg invea invedcompatible invemoji invequalalways invet invexrc invfileignorecase invfk invfs invgdefault invhidden invhkmapp invhlsearch invignorecase invimcmdline invincsearch invinsertmode invjs invlazyredraw invlisp invlnr invlpl invlz invmacatsui invmh invmod invmodifiable invmore invmousefocus invnu invodev invpaste invpreserveindent invprompt invreadonly invremap invrevins invrightleft invrnu invrs invruler invsc invscrollbind invsecure invshellslash invshiftround invshowcmd invshowmatch invsi invsmartcase invsmarttab invsn invspell invsplitright invsr invsta invstmp invswf invtagbsearch invtagstack invtbidi invtermbidi invtextauto invtf invtildeop invtitle invtop invttimeout invttyfast invudf invvb invwa invwb invwfh invwic invwildmenu invwinfixwidth invwmnu invwrapscan invwriteany invws
    2              0.000029 syn keyword vimOption contained	invakm invanti invarab invari invautoindent invautowriteall invbackup invbeval invbinary invbomb invbuflisted invcin invconfirm invcrb invcscopeverbose invcsverb invcursorbind invdeco invdiff inveb invek invendofline inverrorbells invex invfen invfixendofline invfkmap invfsync invguipty invhk invhkp invic invim invimd invinf invis invlangnoremap invlbr
                            
                            " termcap codes (which can also be set) {{{2
    2              0.000057 syn keyword vimOption contained	t_8b t_AB t_al t_bc t_BE t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_EI t_F2 t_F4 t_F6 t_F8 t_fs t_IE t_k1 t_k2 t_K3 t_K4 t_K5 t_K6 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_PE t_PS t_RB t_RC t_RF t_RI t_RS t_RV t_Sb t_SC t_se t_Sf t_SH t_SI t_so t_sr t_SR t_te t_Te t_ti t_ts t_Ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_VS t_WP t_WS t_xn t_xs t_ZH t_ZR
    2              0.000019 syn keyword vimOption contained	t_8f t_AF t_AL t_BD t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EC t_F1 t_F3 t_F5 t_F7 t_F9 t_GP t_IS t_K1 t_k3 t_k4 t_k5 t_k6 t_k7
    2              0.000012 syn match   vimOption contained	"t_%1"
    2              0.000009 syn match   vimOption contained	"t_#2"
    2              0.000007 syn match   vimOption contained	"t_#4"
    2              0.000011 syn match   vimOption contained	"t_@7"
    2              0.000008 syn match   vimOption contained	"t_*7"
    2              0.000007 syn match   vimOption contained	"t_&8"
    2              0.000008 syn match   vimOption contained	"t_%i"
    2              0.000012 syn match   vimOption contained	"t_k;"
                            
                            " unsupported settings: some were supported by vi but don't do anything in vim {{{2
                            " others have been dropped along with msdos support
    2              0.000037 syn keyword vimErrSetting contained	bioskey biosk conskey consk autoprint beautify flash graphic hardtabs mesg novice open op optimize redraw slow slowopen sourceany w300 w1200 w9600 hardtabs ht nobioskey nobiosk noconskey noconsk noautoprint nobeautify noflash nographic nohardtabs nomesg nonovice noopen noop nooptimize noredraw noslow noslowopen nosourceany now300 now1200 now9600 w1200 w300 w9600
                            
                            " AutoCmd Events {{{2
    2              0.000010 syn case ignore
    2              0.000120 syn keyword vimAutoEvent contained	BufAdd BufCreate BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufRead BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWrite BufWriteCmd BufWritePost BufWritePre CmdlineChanged CmdlineEnter CmdlineLeave CmdUndefined CmdwinEnter CmdwinLeave ColorScheme CompleteDone CursorHold CursorHoldI CursorMoved CursorMovedI DirChanged EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileEncoding FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabClosed TabEn
                            
                            " Highlight commonly used Groupnames {{{2
    2              0.000039 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo
                            
                            " Default highlighting groups {{{2
    2              0.000112 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question QuickFixLine Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC StatusLineTerm TabLine TabLineFill TabLineSel Terminal Title Tooltip VertSplit Visual VisualNOS WarningMsg WildMenu
    2              0.000011 syn match vimHLGroup contained	"Conceal"
    2              0.000002 syn case match
                            
                            " Function Names {{{2
    2              0.000090 syn keyword vimFuncName contained	abs append argv assert_equalfile assert_inrange assert_report balloon_show bufexists bufnr byteidx changenr ch_close_in ch_getjob ch_open ch_sendraw clearmatches complete_check cosh deepcopy diff_hlID eventhandler exists feedkeys finddir fmod foldclosedend foreground get getchangelist getcmdline getcompletion getfperm getjumplist getpid getregtype getwininfo getwinvar has histadd hlexists indent inputlist insert isnan job_setoptions join json_encode libcallnr localtime map matchadd matchend max mzeval option_save pow py3eval readfile remote_expr remote_send repeat screenattr search searchpos setbufvar setline setqflist setwinvar simplify soundfold sqrt strchars stridx strridx substitute synIDtrans tabpagebuflist taglist term_dumpdiff term_getansicolors term_getline term_gettitle term_sendkeys term_setsize test_autochdir test_ignore_error test_null_job test_null_string timer_info timer_stop toupper trunc undotree virtcol winbufnr win_getid win_id2tabwin winnr winsaveview word
    2              0.000077 syn keyword vimFuncName contained	acos argc asin assert_exception assert_match assert_true balloon_split buflisted bufwinid byteidxcomp char2nr ch_evalexpr ch_info ch_read ch_setoptions col confirm count delete empty executable exp filereadable findfile fnameescape foldlevel funcref getbufinfo getchar getcmdpos getcurpos getfsize getline getpos gettabinfo getwinpos glob has_key histdel hlID index inputrestore invert items job_start js_decode keys line log maparg matchaddpos matchlist min nextnonblank or prevnonblank pyeval reltime remote_foreground remote_startserver resolve screenchar searchdecl server2client setcharsearch setloclist setreg sha256 sin spellbadword str2float strdisplaywidth string strtrans synconcealed synstack tabpagenr tan term_dumpload term_getattr term_getscrolled term_gettty term_setansicolors term_start test_feedinput test_null_channel test_null_list test_override timer_pause timer_stopall tr type uniq visualmode wincol win_gotoid win_id2win winrestcmd win_screenpos writefile
    2              0.000071 syn keyword vimFuncName contained	add argidx assert_beeps assert_fails assert_notequal atan browse bufloaded bufwinnr call ch_canread ch_evalraw ch_log ch_readraw ch_status complete copy cscope_connection did_filetype escape execute expand filewritable float2nr fnamemodify foldtext function getbufline getcharmod getcmdtype getcwd getftime getloclist getqflist gettabvar getwinposx glob2regpat haslocaldir histget hostname input inputsave isdirectory job_getchannel job_status js_encode len line2byte log10 mapcheck matcharg matchstr mkdir nr2char pathshorten printf pyxeval reltimefloat remote_peek remove reverse screencol searchpair serverlist setcmdpos setmatches settabvar shellescape sinh spellsuggest str2nr strftime strlen strwidth synID system tabpagewinnr tanh term_dumpwrite term_getcursor term_getsize term_list term_setkill term_wait test_garbagecollect_now test_null_dict test_null_partial test_settime timer_start tolower trim undofile values wildmenumode win_findbuf winheight winline winrestview winwidth 
    2              0.000061 syn keyword vimFuncName contained	and arglistid assert_equal assert_false assert_notmatch atan2 browsedir bufname byte2line ceil ch_close ch_getbufnr ch_logfile ch_sendexpr cindent complete_add cos cursor diff_filler eval exepath extend filter floor foldclosed foldtextresult garbagecollect getbufvar getcharsearch getcmdwintype getfontname getftype getmatches getreg gettabwinvar getwinposy globpath hasmapto histnr iconv inputdialog inputsecret islocked job_info job_stop json_decode libcall lispindent luaeval match matchdelete matchstrpos mode option_restore perleval pumvisible range reltimestr remote_read rename round screenrow searchpairpos setbufline setfperm setpos settabwinvar shiftwidth sort split strcharpart strgetchar strpart submatch synIDattr systemlist tagfiles tempname term_getaltscreen term_getjob term_getstatus term_scrape term_setrestore test_alloc_fail
                            
                            "--- syntax here and above generated by mkvimvim ---
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands
    2              0.000011 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[aflmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p'
                              com! -nargs=* VimFoldp <args> fold
                             else
                              com! -nargs=* VimFoldp <args>
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
                            else
    2              0.000022  com! -nargs=*	VimFolda	<args>
    2              0.000011  com! -nargs=*	VimFoldf	<args>
    2              0.000010  com! -nargs=*	VimFoldl	<args>
    2              0.000010  com! -nargs=*	VimFoldm	<args>
    2              0.000008  com! -nargs=*	VimFoldp	<args>
    2              0.000010  com! -nargs=*	VimFoldP	<args>
    2              0.000008  com! -nargs=*	VimFoldr	<args>
    2              0.000009  com! -nargs=*	VimFoldt	<args>
    2              0.000003 endif
                            
                            " commands not picked up by the generator (due to non-standard format)
    2              0.000009 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    2              0.000008 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
                            endif
    2              0.000005 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
                            endif
    2              0.000005 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
                            endif
                            
                            " Variable options {{{2
    2              0.000004 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
                            else
    2              0.000009  let s:vimsyn_maxlines= 60
    2              0.000002 endif
                            
                            " Numbers {{{2
                            " =======
    2              0.000043 syn match vimNumber	"\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=" skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    2              0.000032 syn match vimNumber	"-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\="  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    2              0.000011 syn match vimNumber	"\<0[xX]\x\+"
    2              0.000014 syn match vimNumber	"\%(^\|\A\)\zs#\x\{6}"
                            
                            " All vimCommands are contained by vimIsCommands. {{{2
    2              0.000083 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    2              0.000016 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    2              0.000017 syn match vimVar        contained	"\<\h[a-zA-Z0-9#_]*\>"
    2              0.000013 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    2              0.000011 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    2              0.000024 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    2              0.000042 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"	matchgroup=vimCommand end="^\.$""
    2              0.000025 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"	matchgroup=vimCommand end="^\.$""
    2              0.000023 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    2              0.000026 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    2              0.000008 syn keyword vimBehaveModel contained	mswin	xterm
    2              0.000012 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    2              0.000010  syn match   vimBehaveError contained	"[^ ]\+"
    2              0.000002 endif
                            
                            " Filetypes {{{2
                            " =========
    2              0.000033 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    2              0.000009 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    2              0.000010  syn match   vimFTError  contained	"\I\i*"
    2              0.000002 endif
    2              0.000008 syn keyword vimFTCmd    contained	filet[ype]
    2              0.000010 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    2              0.000221 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue,vimSetEqual,vimOption
    2              0.000008 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
                            else
    2              0.000034  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    2              0.000019 endif
    2              0.000035 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    2              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    2              0.000015  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    2              0.000002 endif
    2              0.000008 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    2              0.000056 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue
    2              0.000040 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    2              0.000025 syn match	vimOper	"\(\<is\>\|\<isnot\>\)[?#]\{0,2}"		skipwhite nextgroup=vimString,vimSpecFile
    2              0.000022 syn match	vimOper	"||\|&&\|[-+.]"			skipwhite nextgroup=vimString,vimSpecFile
    2              0.000021 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    2              0.000043 syn region	vimOperParen	matchgroup=vimSep		start="{" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    2              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    2              0.000010  syn match	vimOperError	")"
    2              0.000002 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    2              0.000042 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    2              0.000230 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimExecute,vimIf,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    2              0.000051 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    2              0.000008 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
                            else
    2              0.000025  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    2              0.000002 endif
    2              0.000012 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    2              0.000010 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    2              0.000027 syn keyword	vimFuncKey   contained	fu[nction]
    2              0.000028 syn match	vimFuncBlank contained	"\s\+"
                            
    2              0.000009 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    2              0.000030 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    2              0.000025 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    2              0.000023 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    2              0.000020 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    2              0.000024 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    2              0.000024 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    2              0.000010 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    2              0.000178 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vimCtrlChar,vimEscapeBrace,vimFilter,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    2              0.000009 syn keyword	vimUserCommand	contained	com[mand]
    2              0.000037 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList
    2              0.000011 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    2              0.000023 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    2              0.000039 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    2              0.000031 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    2              0.000032 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    2              0.000020 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    2              0.000019 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    2              0.000020 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    2              0.000023 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    2              0.000013 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    2              0.000010  syn match	vimUserCmdError	contained	"\S\+\>"
    2              0.000002 endif
    2              0.000019 syn case ignore
    2              0.000120 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    2              0.000035 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    2              0.000023 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    2              0.000026 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    2              0.000002 syn case match
    2              0.000013 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    2              0.000023 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    2              0.000020 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    2              0.000018 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    2              0.000020 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            
                            " Environment Variables: {{{2
                            " =====================
    2              0.000008 syn match	vimEnvvar	"\$\I\i*"
    2              0.000009 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    2              0.000028 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    2              0.000009 syn match	vimPatSepErr	contained	"\\)"
    2              0.000010 syn match	vimPatSep	contained	"\\|"
    2              0.000034 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\]['"]"	contains=@vimStringGroup
    2              0.000028 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    2              0.000010 syn match	vimNotPatSep	contained	"\\\\"
    2              0.000033 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    2              0.000024 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ end=+"+	contains=@vimStringGroup
    2              0.000038 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    2              0.000042 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    2              0.000020 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
    2              0.000025 syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup
    2              0.000023 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    2              0.000015 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    2              0.000037 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    2              0.000022 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    2              0.000013 syn cluster	vimSubstList	add=vimCollection
    2              0.000031 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
    2              0.000019 syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    2              0.000018 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    2              0.000017 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    2              0.000016 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    2              0.000044 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    2              0.000045 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    2              0.000025 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    2              0.000012 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    2              0.000033 syn match	vimCollClass    contained transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    2              0.000013 syn match	vimSubstSubstr  contained	"\\z\=\d"
    2              0.000009 syn match	vimSubstTwoBS   contained	"\\\\"
    2              0.000022 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    2              0.000010 syn match	vimSubstFlags   contained	"[&cegiIpr]\+"
                            
                            " 'String': {{{2
    2              0.000010 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    2              0.000030 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000045 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000049 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000033 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000031 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000022 syn match	vimMarkNumber	"[-+]\d\+"		nextgroup=vimSubst contained contains=vimOper
    2              0.000010 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
                            
    2              0.000016 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    2              0.000015 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    2              0.000014 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    2              0.000010 syn match	vimRegister	'@"'
    2              0.000011 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    2              0.000015 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    2              0.000035 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    2              0.000018 syn match	vimFilter contained	"^!.\{-}\(|\|$\)"		contains=vimSpecFile
    2              0.000034 syn match	vimFilter contained	"\A!.\{-}\(|\|$\)"ms=s+1	contains=vimSpecFile,vimFunction,vimFuncName,vimOperParen
                            
                            " Complex repeats (:h complex-repeat) {{{2
    2              0.000012 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    2              0.000020 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    2              0.000076 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vimSetString,vimSetMod
    2              0.000052 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1 contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    2              0.000028 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+	contains=vimCtrlChar
    2              0.000016 syn match	vimSetSep	contained	"[,:]" skipwhite nextgroup=vimCommand
    2              0.000011 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let {{{2
                            " ===
    2              0.000037 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar
                            
                            " Abbreviations {{{2
                            " =============
    2              0.000048 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd {{{2
                            " =======
    2              0.000031 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent nextgroup=vimAutoCmdSpace
    2              0.000015 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    2              0.000008 syn match	vimAutoCmdSfxList	contained	"\S*"
    2              0.000025 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
                            
                            " Echo and Execute -- prefer strings! {{{2
                            " ================
    2              0.000053 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    2              0.000076 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    2              0.000030 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone
    2              0.000002 syn case ignore
    2              0.000006 syn keyword	vimEchoHLNone	none
    2              0.000002 syn case match
                            
                            " Maps {{{2
                            " ====
    2              0.000022 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    2              0.000069 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000011 syn keyword	vimMap		mapc[lear] smapc[lear]
    2              0.000048 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000029 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    2              0.000018 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    2              0.000055 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    2              0.000028 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    2              0.000032 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    2              0.000019 syn case ignore
    2              0.000015 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    2              0.000002 syn case match
                            
                            " Menus {{{2
                            " =====
    2              0.000032 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    2              0.000054 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    2              0.000041 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    2              0.000016 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    2              0.000028 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    2              0.000024 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    2              0.000015 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    2              0.000027 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vimIsCommand
    2              0.000010 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation (tnx to Michael Geddes) {{{2
                            " ======================
    2              0.000003 syn case ignore
    2              0.000088 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cr\|lf\|linefeed\|return\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    2              0.000031 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    2              0.000024 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"			contains=vimBracket
    2              0.000019 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    2              0.000029 syn match	vimNotation	'\%#=1\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    2              0.000024 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    2              0.000008 syn match	vimBracket contained	"[\\<>]"
    2              0.000002 syn case match
                            
                            " User Function Highlighting {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    2              0.000057 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    2              0.000044 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
    2              0.000017 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"
                            
                            " Errors And Warnings: {{{2
                            " ====================
    2              0.000014 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    2              0.000027  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
                            " syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    2              0.000011  syn match	vimElseIfErr	"\<else\s\+if\>"
    2              0.000021  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    2              0.000003 endif
                            
                            " Norm {{{2
                            " ====
    2              0.000017 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    2              0.000010 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax {{{2
                            "=======
    2              0.000023 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    2              0.000025 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    2              0.000008 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    2              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    2              0.000010  syn match	vimSynError	contained	"\i\+"
    2              0.000013  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    2              0.000002 endif
    2              0.000021 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    2              0.000020 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    2              0.000015 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    2              0.000030 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    2              0.000044 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    2              0.000036 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    2              0.000019 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    2              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    2              0.000010  syn match	vimSynCaseError	contained	"\i\+"
    2              0.000001 endif
    2              0.000006 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    2              0.000012 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    2              0.000012 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    2              0.000058 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    2              0.000013 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    2              0.000014 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    2              0.000020 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    2              0.000011 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    2              0.000015 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    2              0.000007 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    2              0.000011 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    2              0.000011 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    2              0.000022 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    2              0.000013 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    2              0.000050 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    2              0.000036 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    2              0.000012 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    2              0.000044 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation
    2              0.000014 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    2              0.000021 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    2              0.000026 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    2              0.000008 if has("conceal")
    2              0.000017  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    2              0.000008  syn match	vimSynMtchCchar	contained	"\S"
    2              0.000002 endif
    2              0.000011 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    2              0.000010 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    2              0.000052 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    2              0.000031 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    2              0.000012 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    2              0.000032 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    2              0.000029 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    2              0.000015 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    2              0.000024 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup
    2              0.000040 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    2              0.000018 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    2              0.000020 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    2              0.000009 syn match	vimSynPatMod	contained	"lc=\d\+"
    2              0.000017 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    2              0.000017 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    2              0.000025 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    2              0.000027 syn match	vimMtchComment	contained	'"[^"]\+$'
    2              0.000012 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    2              0.000049 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    2              0.000012 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    2              0.000013  syn match	vimSyncError	contained	"\i\+"
    2              0.000002 endif
    2              0.000008 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    2              0.000014 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    2              0.000010 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    2              0.000018 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    2              0.000010 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    2              0.000023 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    2              0.000015 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    2              0.000016 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    2              0.000017 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    2              0.000006 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand, here by reasons of precedence {{{2
                            " ====================
    2              0.000027 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting {{{2
                            " ============
    2              0.000028 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment
    2              0.000012 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    2              0.000015  syn match	vimHiCtermError	contained	"\D\i*"
    2              0.000002 endif
    2              0.000022 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    2              0.000027 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    2              0.000011 syn match	vimHiGroup	contained	"\i\+"
    2              0.000002 syn case ignore
    2              0.000020 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl
    2              0.000010 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    2              0.000003 syn case match
    2              0.000014 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    2              0.000017 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    2              0.000008 syn case ignore
    2              0.000026 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    2              0.000015 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    2              0.000002 syn case match
    2              0.000012 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    2              0.000011 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    2              0.000014 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    2              0.000069 syn cluster	vimHiCluster contains=vimGroup,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    2              0.000023 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    2              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    2              0.000009  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    2              0.000002 endif
    2              0.000012 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    2              0.000029 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    2              0.000013 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    2              0.000034 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    2              0.000013 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    2              0.000012 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    2              0.000029 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    2              0.000018 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    2              0.000022 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    2              0.000012 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
    2              0.000056 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
    2              0.000012 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters {{{2
                            " ==================
    2              0.000009 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    2              0.000032 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    2              0.000033 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    2              0.000010 syn match	vimContinue	"^\s*\\"
    2              0.000031 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    2              0.000014 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    2              0.000016 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    2              0.000014 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    2              0.000035 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    2              0.000035 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Scripts  : perl,ruby : Benoit Cerrina {{{2
                            " =======    python,tcl: Johannes Zellner
                            "            lua
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua      (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'p' : embed perl     (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'P' : embed python   (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'r' : embed ruby     (but only if vim supports it)
                            "   g:vimsyn_embed =~# 't' : embed tcl      (but only if vim supports it)
    2              0.000009 if !exists("g:vimsyn_embed")
    1              0.000003  let g:vimsyn_embed= "lmpPr"
    1              0.000001 endif
                            
                            " [-- lua --] {{{3
    2              0.000053 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    2              0.000037 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
                            endif
    2              0.000019 if (g:vimsyn_embed =~# 'l' && has("lua")) && filereadable(s:luapath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimLuaRegion
                             exe "syn include @vimLuaScript ".s:luapath
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+		contains=@vimLuaScript
                             syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
    2              0.000030  syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000032  syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    2              0.000018 endif
    2              0.000006 unlet s:luapath
                            
                            " [-- perl --] {{{3
    2              0.000047 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    2              0.000034 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
                            endif
    2              0.000041 if (g:vimsyn_embed =~# 'p' && has("perl")) && filereadable(s:perlpath)
    2              0.000019  unlet! b:current_syntax
    2              0.000023  syn cluster vimFuncBodyList	add=vimPerlRegion
    2   0.009998   0.000240  exe "syn include @vimPerlScript ".s:perlpath
    2              0.000049  VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)\ze\(\s*["#].*\)\=$+ end=+^\z1\ze\(\s*[#"].*\)\=$+	contains=@vimPerlScript
    2              0.000040  VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+			contains=@vimPerlScript
    2              0.000012  syn cluster vimFuncBodyList	add=vimPerlRegion
    2              0.000002 else
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
                            endif
    2              0.000004 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    2              0.000061 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    2              0.000036 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
                            endif
    2              0.000041 if (g:vimsyn_embed =~# 'r' && has("ruby")) && filereadable(s:rubypath)
    2              0.000015  syn cluster vimFuncBodyList	add=vimRubyRegion
    2              0.000004  unlet! b:current_syntax
    2   0.008273   0.000218  exe "syn include @vimRubyScript ".s:rubypath
    2              0.000038  VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimRubyScript
    2              0.000024  syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+			contains=@vimRubyScript
    2              0.000010  syn cluster vimFuncBodyList	add=vimRubyRegion
    2              0.000002 else
                             syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
                            endif
    2              0.000004 unlet s:rubypath
                            
                            " [-- python --] {{{3
    2              0.000053 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    2              0.000033 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
                            endif
    2              0.000052 if g:vimsyn_embed =~# 'P' && has("pythonx") && filereadable(s:pythonpath)
    2              0.000006  unlet! b:current_syntax
    2              0.000013  syn cluster vimFuncBodyList	add=vimPythonRegion
    2   0.002145   0.000200  exe "syn include @vimPythonScript ".s:pythonpath
    2              0.000036  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
    2              0.000031  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+			contains=@vimPythonScript
    2              0.000026  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
    2              0.000020  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+			contains=@vimPythonScript
    2              0.000010  syn cluster vimFuncBodyList	add=vimPythonRegion
    2              0.000002 else
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
                            endif
    2              0.000003 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    2              0.000020 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
                            else
    2              0.000003  let s:trytcl= 1
    2              0.000002 endif
    2              0.000002 if s:trytcl
    2              0.000060  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    2              0.000031  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
                             endif
    2              0.000012  if (g:vimsyn_embed =~# 't' && has("tcl")) && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
                             else
    2              0.000025   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000018   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    2              0.000002  endif
    2              0.000018  unlet s:tclpath
    2              0.000001 else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
                            endif
    2              0.000003 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    2              0.000042 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    2              0.000030 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
                            endif
    2              0.000015 if (g:vimsyn_embed =~# 'm' && has("mzscheme")) && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                            else
    2              0.000019  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000014  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    2              0.000002 endif
    2              0.000003 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    2              0.000005 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
                            endif
    2              0.000012 exe "syn sync maxlines=".s:vimsyn_maxlines
    2              0.000007 syn sync linecont	"^\s\+\\"
    2              0.000017 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    2              0.000007 if !exists("skip_vim_syntax_inits")
    2              0.000004  if !exists("g:vimsyn_noerror")
    2              0.000010   hi def link vimBehaveError	vimError
    2              0.000007   hi def link vimCollClassErr	vimError
    2              0.000006   hi def link vimErrSetting	vimError
    2              0.000004   hi def link vimEmbedError	vimError
    2              0.000006   hi def link vimFTError	vimError
    2              0.000006   hi def link vimFunctionError	vimError
    2              0.000006   hi def link vimFunc         	vimError
    2              0.000005   hi def link vimHiAttribList	vimError
    2              0.000004   hi def link vimHiCtermError	vimError
    2              0.000005   hi def link vimHiKeyError	vimError
    2              0.000005   hi def link vimKeyCodeError	vimError
    2              0.000005   hi def link vimMapModErr	vimError
    2              0.000005   hi def link vimSubstFlagErr	vimError
    2              0.000004   hi def link vimSynCaseError	vimError
    2              0.000007   hi def link vimBufnrWarn	vimWarn
    2              0.000001  endif
                            
    2              0.000010  hi def link vimAbb	vimCommand
    2              0.000009  hi def link vimAddress	vimMark
    2              0.000006  hi def link vimAugroupError	vimError
    2              0.000009  hi def link vimAugroupKey	vimCommand
    2              0.000008  hi def link vimAuHighlight	vimHighlight
    2              0.000009  hi def link vimAutoCmdOpt	vimOption
    2              0.000009  hi def link vimAutoCmd	vimCommand
    2              0.000011  hi def link vimAutoEvent	Type
    2              0.000009  hi def link vimAutoSet	vimCommand
    2              0.000009  hi def link vimBehaveModel	vimBehave
    2              0.000009  hi def link vimBehave	vimCommand
    2              0.000024  hi def link vimBracket	Delimiter
    2              0.000010  hi def link vimCmplxRepeat	SpecialChar
    2              0.000010  hi def link vimCommand	Statement
    2              0.000010  hi def link vimComment	Comment
    2              0.000009  hi def link vimCommentString	vimString
    2              0.000009  hi def link vimCommentTitle	PreProc
    2              0.000009  hi def link vimCondHL	vimCommand
    2              0.000009  hi def link vimContinue	Special
    2              0.000010  hi def link vimCtrlChar	SpecialChar
    2              0.000009  hi def link vimEchoHLNone	vimGroup
    2              0.000008  hi def link vimEchoHL	vimCommand
    2              0.000009  hi def link vimElseIfErr	Error
    2              0.000006  hi def link vimElseif	vimCondHL
    2              0.000010  hi def link vimEnvvar	PreProc
    2              0.000007  hi def link vimError	Error
    2              0.000008  hi def link vimFBVar	vimVar
    2              0.000007  hi def link vimFgBgAttrib	vimHiAttrib
    2              0.000010  hi def link vimFold	Folded
    2              0.000022  hi def link vimFTCmd	vimCommand
    2              0.000008  hi def link vimFTOption	vimSynType
    2              0.000023  hi def link vimFuncKey	vimCommand
    2              0.000010  hi def link vimFuncName	Function
    2              0.000009  hi def link vimFuncSID	Special
    2              0.000011  hi def link vimFuncVar	Identifier
    2              0.000007  hi def link vimGroupAdd	vimSynOption
    2              0.000008  hi def link vimGroupName	vimGroup
    2              0.000004  hi def link vimGroupRem	vimSynOption
    2              0.000010  hi def link vimGroupSpecial	Special
    2              0.000009  hi def link vimGroup	Type
    2              0.000010  hi def link vimHiAttrib	PreProc
    2              0.000006  hi def link vimHiClear	vimHighlight
    2              0.000007  hi def link vimHiCtermFgBg	vimHiTerm
    2              0.000019  hi def link vimHiCTerm	vimHiTerm
    2              0.000009  hi def link vimHighlight	vimCommand
    2              0.000007  hi def link vimHiGroup	vimGroupName
    2              0.000006  hi def link vimHiGuiFgBg	vimHiTerm
    2              0.000006  hi def link vimHiGuiFont	vimHiTerm
    2              0.000007  hi def link vimHiGuiRgb	vimNumber
    2              0.000006  hi def link vimHiGui	vimHiTerm
    2              0.000008  hi def link vimHiNmbr	Number
    2              0.000007  hi def link vimHiStartStop	vimHiTerm
    2              0.000008  hi def link vimHiTerm	Type
    2              0.000010  hi def link vimHLGroup	vimGroup
    2              0.000008  hi def link vimHLMod	PreProc
    2              0.000010  hi def link vimInsert	vimString
    2              0.000020  hi def link vimIskSep	Delimiter
    2              0.000009  hi def link vimKeyCode	vimSpecFile
    2              0.000008  hi def link vimKeyword	Statement
    2              0.000010  hi def link vimLet	vimCommand
    2              0.000008  hi def link vimLineComment	vimComment
    2              0.000008  hi def link vimMapBang	vimCommand
    2              0.000007  hi def link vimMapModKey	vimFuncSID
    2              0.000021  hi def link vimMapMod	vimBracket
    2              0.000010  hi def link vimMap	vimCommand
    2              0.000010  hi def link vimMark	Number
    2              0.000008  hi def link vimMarkNumber	vimNumber
    2              0.000007  hi def link vimMenuMod	vimMapMod
    2              0.000008  hi def link vimMenuNameMore	vimMenuName
    2              0.000008  hi def link vimMenuName	PreProc
    2              0.000008  hi def link vimMtchComment	vimComment
    2              0.000009  hi def link vimNorm	vimCommand
    2              0.000009  hi def link vimNotation	Special
    2              0.000008  hi def link vimNotFunc	vimCommand
    2              0.000007  hi def link vimNotPatSep	vimString
    2              0.000023  hi def link vimNumber	Number
    2              0.000010  hi def link vimOperError	Error
    2              0.000010  hi def link vimOper	Operator
    2              0.000010  hi def link vimOption	PreProc
    2              0.000009  hi def link vimParenSep	Delimiter
    2              0.000007  hi def link vimPatSepErr	vimPatSep
    2              0.000008  hi def link vimPatSepR	vimPatSep
    2              0.000008  hi def link vimPatSep	SpecialChar
    2              0.000009  hi def link vimPatSepZone	vimString
    2              0.000007  hi def link vimPatSepZ	vimPatSep
    2              0.000008  hi def link vimPattern	Type
    2              0.000009  hi def link vimPlainMark	vimMark
    2              0.000008  hi def link vimPlainRegister	vimRegister
    2              0.000010  hi def link vimRegister	SpecialChar
    2              0.000008  hi def link vimScriptDelim	Comment
    2              0.000008  hi def link vimSearchDelim	Statement
    2              0.000007  hi def link vimSearch	vimString
    2              0.000010  hi def link vimSep	Delimiter
    2              0.000008  hi def link vimSetMod	vimOption
    2              0.000009  hi def link vimSetSep	Statement
    2              0.000022  hi def link vimSetString	vimString
    2              0.000010  hi def link vimSpecFile	Identifier
    2              0.000008  hi def link vimSpecFileMod	vimSpecFile
    2              0.000010  hi def link vimSpecial	Type
    2              0.000008  hi def link vimStatement	Statement
    2              0.000007  hi def link vimStringCont	vimString
    2              0.000009  hi def link vimString	String
    2              0.000008  hi def link vimSubst1	vimSubst
    2              0.000009  hi def link vimSubstDelim	Delimiter
    2              0.000008  hi def link vimSubstFlags	Special
    2              0.000010  hi def link vimSubstSubstr	SpecialChar
    2              0.000007  hi def link vimSubstTwoBS	vimString
    2              0.000023  hi def link vimSubst	vimCommand
    2              0.000009  hi def link vimSynCaseError	Error
    2              0.000010  hi def link vimSynCase	Type
    2              0.000008  hi def link vimSyncC	Type
    2              0.000008  hi def link vimSyncError	Error
    2              0.000008  hi def link vimSyncGroupName	vimGroupName
    2              0.000007  hi def link vimSyncGroup	vimGroupName
    2              0.000008  hi def link vimSyncKey	Type
    2              0.000009  hi def link vimSyncNone	Type
    2              0.000004  hi def link vimSynContains	vimSynOption
    2              0.000010  hi def link vimSynError	Error
    2              0.000007  hi def link vimSynKeyContainedin	vimSynContains
    2              0.000005  hi def link vimSynKeyOpt	vimSynOption
    2              0.000005  hi def link vimSynMtchGrp	vimSynOption
    2              0.000004  hi def link vimSynMtchOpt	vimSynOption
    2              0.000006  hi def link vimSynNextgroup	vimSynOption
    2              0.000007  hi def link vimSynNotPatRange	vimSynRegPat
    2              0.000006  hi def link vimSynOption	Special
    2              0.000008  hi def link vimSynPatRange	vimString
    2              0.000005  hi def link vimSynRegOpt	vimSynOption
    2              0.000021  hi def link vimSynRegPat	vimString
    2              0.000009  hi def link vimSynReg	Type
    2              0.000009  hi def link vimSyntax	vimCommand
    2              0.000005  hi def link vimSynType	vimSpecial
    2              0.000009  hi def link vimTodo	Todo
    2              0.000010  hi def link vimUnmap	vimMap
    2              0.000009  hi def link vimUserAttrbCmpltFunc	Special
    2              0.000006  hi def link vimUserAttrbCmplt	vimSpecial
    2              0.000008  hi def link vimUserAttrbKey	vimOption
    2              0.000006  hi def link vimUserAttrb	vimSpecial
    2              0.000009  hi def link vimUserAttrbError	Error
    2              0.000009  hi def link vimUserCmdError	Error
    2              0.000022  hi def link vimUserCommand	vimCommand
    2              0.000010  hi def link vimUserFunc	Normal
    2              0.000009  hi def link vimVar	Identifier
    2              0.000008  hi def link vimWarn	WarningMsg
    2              0.000001 endif
                            
                            " Current Syntax Variable: {{{2
    2              0.000005 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    2              0.000005 delc VimFolda
    2              0.000003 delc VimFoldf
    2              0.000002 delc VimFoldl
    2              0.000002 delc VimFoldm
    2              0.000002 delc VimFoldp
    2              0.000003 delc VimFoldP
    2              0.000003 delc VimFoldr
    2              0.000002 delc VimFoldt
    2              0.000014 let &cpo = s:keepcpo
    2              0.000016 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/local/Cellar/vim/8.1.0100/share/vim/vim81/syntax/perl.vim
Sourced 2 times
Total time:   0.009649
 Self time:   0.008030

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:      Perl 5
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Homepage:      http://github.com/vim-perl/vim-perl/tree/master
                            " Bugs/requests: http://github.com/vim-perl/vim-perl/issues
                            " Last Change:   2017-09-12
                            " Contributors:  Andy Lester <andy@petdance.com>
                            "                Hinrik Ã–rn SigurÃ°sson <hinrik.sig@gmail.com>
                            "                Lukas Mai <l.mai.web.de>
                            "                Nick Hibma <nick@van-laarhoven.org>
                            "                Sonia Heimann <niania@netsurf.org>
                            "                Rob Hoelz <rob@hoelz.ro>
                            "                and many others.
                            "
                            " Please download the most recent version first, before mailing
                            " any comments.
                            "
                            " The following parameters are available for tuning the
                            " perl syntax highlighting, with defaults given:
                            "
                            " let perl_include_pod = 1
                            " unlet perl_no_scope_in_variables
                            " unlet perl_no_extended_vars
                            " unlet perl_string_as_statement
                            " unlet perl_no_sync_on_sub
                            " unlet perl_no_sync_on_global_var
                            " let perl_sync_dist = 100
                            " unlet perl_fold
                            " unlet perl_fold_blocks
                            " unlet perl_nofold_packages
                            " unlet perl_nofold_subs
                            " unlet perl_fold_anonymous_subs
                            " unlet perl_no_subprototype_error
                            
    2              0.000013 if exists("b:current_syntax")
                              finish
                            endif
                            
    2              0.000012 let s:cpo_save = &cpo
    2              0.000015 set cpo&vim
                            
                            " POD starts with ^=<word> and ends with ^=cut
                            
    2              0.000009 if !exists("perl_include_pod") || perl_include_pod == 1
                              " Include a while extra syntax file
    2   0.002481   0.000862   syn include @Pod syntax/pod.vim
    2              0.000004   unlet b:current_syntax
    2              0.000008   if exists("perl_fold")
                                syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend fold extend
                                syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend fold extend
                              else
    2              0.000024     syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend
    2              0.000022     syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend
    2              0.000002   endif
    2              0.000002 else
                              " Use only the bare minimum of rules
                              if exists("perl_fold")
                                syn region perlPOD start="^=[a-z]" end="^=cut" fold
                              else
                                syn region perlPOD start="^=[a-z]" end="^=cut"
                              endif
                            endif
                            
                            
    2              0.000008 syn cluster perlTop		contains=TOP
                            
    2              0.000014 syn region perlBraces start="{" end="}" transparent extend
                            
                            " All keywords
                            "
    2              0.000034 syn match perlConditional		"\<\%(if\|elsif\|unless\|given\|when\|default\)\>"
    2              0.000025 syn match perlConditional		"\<else\%(\%(\_s\*if\>\)\|\>\)" contains=perlElseIfError skipwhite skipnl skipempty
    2              0.000017 syn match perlRepeat			"\<\%(while\|for\%(each\)\=\|do\|until\|continue\)\>"
    2              0.000051 syn match perlOperator			"\<\%(defined\|undef\|eq\|ne\|[gl][et]\|cmp\|not\|and\|or\|xor\|not\|bless\|ref\|do\)\>"
                            " for some reason, adding this as the nextgroup for perlControl fixes BEGIN
                            " folding issues...
    2              0.000010 syn match perlFakeGroup 		"" contained
    2              0.000022 syn match perlControl			"\<\%(BEGIN\|CHECK\|INIT\|END\|UNITCHECK\)\>\_s*" nextgroup=perlFakeGroup
                            
    2              0.000013 syn match perlStatementStorage		"\<\%(my\|our\|local\|state\)\>"
    2              0.000014 syn match perlStatementControl		"\<\%(return\|last\|next\|redo\|goto\|break\)\>"
    2              0.000023 syn match perlStatementScalar		"\<\%(chom\=p\|chr\|crypt\|r\=index\|lc\%(first\)\=\|length\|ord\|pack\|sprintf\|substr\|fc\|uc\%(first\)\=\)\>"
    2              0.000014 syn match perlStatementRegexp		"\<\%(pos\|quotemeta\|split\|study\)\>"
    2              0.000017 syn match perlStatementNumeric		"\<\%(abs\|atan2\|cos\|exp\|hex\|int\|log\|oct\|rand\|sin\|sqrt\|srand\)\>"
    2              0.000017 syn match perlStatementList		"\<\%(splice\|unshift\|shift\|push\|pop\|join\|reverse\|grep\|map\|sort\|unpack\)\>"
    2              0.000014 syn match perlStatementHash		"\<\%(delete\|each\|exists\|keys\|values\)\>"
    2              0.000014 syn match perlStatementIOfunc		"\<\%(syscall\|dbmopen\|dbmclose\)\>"
    2              0.000041 syn match perlStatementFiledesc		"\<\%(binmode\|close\%(dir\)\=\|eof\|fileno\|getc\|lstat\|printf\=\|read\%(dir\|line\|pipe\)\|rewinddir\|say\|select\|stat\|tell\%(dir\)\=\|write\)\>" nextgroup=perlFiledescStatementNocomma skipwhite
    2              0.000030 syn match perlStatementFiledesc		"\<\%(fcntl\|flock\|ioctl\|open\%(dir\)\=\|read\|seek\%(dir\)\=\|sys\%(open\|read\|seek\|write\)\|truncate\)\>" nextgroup=perlFiledescStatementComma skipwhite
    2              0.000015 syn match perlStatementVector		"\<vec\>"
    2              0.000021 syn match perlStatementFiles		"\<\%(ch\%(dir\|mod\|own\|root\)\|glob\|link\|mkdir\|readlink\|rename\|rmdir\|symlink\|umask\|unlink\|utime\)\>"
    2              0.000032 syn match perlStatementFiles		"-[rwxoRWXOezsfdlpSbctugkTBMAC]\>"
    2              0.000016 syn match perlStatementFlow		"\<\%(caller\|die\|dump\|eval\|exit\|wantarray\|evalbytes\)\>"
    2              0.000014 syn match perlStatementInclude		"\<\%(require\|import\|unimport\)\>"
    2              0.000065 syn match perlStatementInclude		"\<\%(use\|no\)\s\+\%(\%(attributes\|attrs\|autodie\|autouse\|parent\|base\|big\%(int\|num\|rat\)\|blib\|bytes\|charnames\|constant\|diagnostics\|encoding\%(::warnings\)\=\|feature\|fields\|filetest\|if\|integer\|less\|lib\|locale\|mro\|open\|ops\|overload\|overloading\|re\|sigtrap\|sort\|strict\|subs\|threads\%(::shared\)\=\|utf8\|vars\|version\|vmsish\|warnings\%(::register\)\=\)\>\)\="
    2              0.000031 syn match perlStatementProc		"\<\%(alarm\|exec\|fork\|get\%(pgrp\|ppid\|priority\)\|kill\|pipe\|set\%(pgrp\|priority\)\|sleep\|system\|times\|wait\%(pid\)\=\)\>"
    2              0.000059 syn match perlStatementSocket		"\<\%(accept\|bind\|connect\|get\%(peername\|sock\%(name\|opt\)\)\|listen\|recv\|send\|setsockopt\|shutdown\|socket\%(pair\)\=\)\>"
    2              0.000023 syn match perlStatementIPC		"\<\%(msg\%(ctl\|get\|rcv\|snd\)\|sem\%(ctl\|get\|op\)\|shm\%(ctl\|get\|read\|write\)\)\>"
    2              0.000029 syn match perlStatementNetwork		"\<\%(\%(end\|[gs]et\)\%(host\|net\|proto\|serv\)ent\|get\%(\%(host\|net\)by\%(addr\|name\)\|protoby\%(name\|number\)\|servby\%(name\|port\)\)\)\>"
    2              0.000024 syn match perlStatementPword		"\<\%(get\%(pw\%(uid\|nam\)\|gr\%(gid\|nam\)\|login\)\)\|\%(end\|[gs]et\)\%(pw\|gr\)ent\>"
    2              0.000020 syn match perlStatementTime		"\<\%(gmtime\|localtime\|time\)\>"
                            
    2              0.000037 syn match perlStatementMisc		"\<\%(warn\|format\|formline\|reset\|scalar\|prototype\|lock\|tied\=\|untie\)\>"
                            
    2              0.000016 syn keyword perlTodo			TODO TODO: TBD TBD: FIXME FIXME: XXX XXX: NOTE NOTE: contained
                            
    2              0.000031 syn region perlStatementIndirObjWrap   matchgroup=perlStatementIndirObj start="\%(\<\%(map\|grep\|sort\|printf\=\|say\|system\|exec\)\>\s*\)\@<={" end="}" transparent extend
                            
    2              0.000021 syn match perlLabel      "^\s*\h\w*\s*::\@!\%(\<v\d\+\s*:\)\@<!"
                            
                            " Perl Identifiers.
                            "
                            " Should be cleaned up to better handle identifiers in particular situations
                            " (in hash keys for example)
                            "
                            " Plain identifiers: $foo, @foo, $#foo, %foo, &foo and dereferences $$foo, @$foo, etc.
                            " We do not process complex things such as @{${"foo"}}. Too complicated, and
                            " too slow. And what is after the -> is *not* considered as part of the
                            " variable - there again, too complicated and too slow.
                            
                            " Special variables first ($^A, ...) and ($|, $', ...)
    2              0.000013 syn match  perlVarPlain		 "$^[ACDEFHILMNOPRSTVWX]\="
    2              0.000049 syn match  perlVarPlain		 "$[\\\"\[\]'&`+*.,;=%~!?@#$<>(-]"
    2              0.000026 syn match  perlVarPlain		 "@[-+]"
    2              0.000011 syn match  perlVarPlain		 "$\%(0\|[1-9]\d*\)"
                            " Same as above, but avoids confusion in $::foo (equivalent to $main::foo)
    2              0.000008 syn match  perlVarPlain		 "$::\@!"
                            " These variables are not recognized within matches.
    2              0.000020 syn match  perlVarNotInMatches	 "$[|)]"
                            " This variable is not recognized within matches delimited by m//.
    2              0.000011 syn match  perlVarSlash		 "$/"
                            
                            " And plain identifiers
    2              0.000022 syn match  perlPackageRef	 "[$@#%*&]\%(\%(::\|'\)\=\I\i*\%(\%(::\|'\)\I\i*\)*\)\=\%(::\|'\)\I"ms=s+1,me=e-1 contained
                            
                            " To not highlight packages in variables as a scope reference - i.e. in
                            " $pack::var, pack:: is a scope, just set "perl_no_scope_in_variables"
                            " If you don't want complex things like @{${"foo"}} to be processed,
                            " just set the variable "perl_no_extended_vars"...
                            
    2              0.000010 if !exists("perl_no_scope_in_variables")
    2              0.000047   syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
    2              0.000036   syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
    2              0.000033   syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
    2              0.000002 else
                              syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
                              syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
                              syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref
                            endif
                            
    2              0.000013 syn match  perlVarPlain2	 "%[-+]"
                            
    2              0.000008 if !exists("perl_no_extended_vars")
    2              0.000111   syn cluster perlExpr		contains=perlStatementIndirObjWrap,perlStatementScalar,perlStatementRegexp,perlStatementNumeric,perlStatementList,perlStatementHash,perlStatementFiles,perlStatementTime,perlStatementMisc,perlVarPlain,perlVarPlain2,perlVarNotInMatches,perlVarSlash,perlVarBlock,perlVarBlock2,perlShellCommand,perlFloat,perlNumber,perlStringUnexpanded,perlString,perlQQ,perlArrow,perlBraces
    2              0.000035   syn region perlArrow		matchgroup=perlArrow start="->\s*(" end=")" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    2              0.000050   syn region perlArrow		matchgroup=perlArrow start="->\s*\[" end="\]" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    2              0.000035   syn region perlArrow		matchgroup=perlArrow start="->\s*{" end="}" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    2              0.000038   syn match  perlArrow		"->\s*{\s*\I\i*\s*}" contains=perlVarSimpleMemberName nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    2              0.000032   syn region perlArrow		matchgroup=perlArrow start="->\s*\$*\I\i*\s*(" end=")" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contained
    2              0.000051   syn region perlVarBlock	matchgroup=perlVarPlain start="\%($#\|[$@]\)\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    2              0.000042   syn region perlVarBlock2	matchgroup=perlVarPlain start="[%&*]\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    2              0.000025   syn match  perlVarPlain2	"[%&*]\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    2              0.000031   syn match  perlVarPlain	"\%(\$#\|[@$]\)\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    2              0.000039   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\={" skip="\\}" end="}" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    2              0.000030   syn match  perlVarSimpleMember	"\%(->\)\={\s*\I\i*\s*}" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref contains=perlVarSimpleMemberName contained extend
    2              0.000007   syn match  perlVarSimpleMemberName	"\I\i*" contained
    2              0.000051   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\=\[" skip="\\]" end="]" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod,perlPostDeref extend
    2              0.000021   syn match perlPackageConst	"__PACKAGE__" nextgroup=perlMethod,perlPostDeref
    2              0.000027   syn match  perlMethod		"->\$*\I\i*" contained nextgroup=perlVarSimpleMember,perlVarMember,perlMethod,perlPostDeref
    2              0.000030   syn match  perlPostDeref	"->\%($#\|[$@%&*]\)\*" contained nextgroup=perlVarSimpleMember,perlVarMember,perlMethod,perlPostDeref
    2              0.000034   syn region  perlPostDeref	start="->\%($#\|[$@%&*]\)\[" skip="\\]" end="]" contained contains=@perlExpr nextgroup=perlVarSimpleMember,perlVarMember,perlMethod,perlPostDeref
    2              0.000036   syn region  perlPostDeref	matchgroup=perlPostDeref start="->\%($#\|[$@%&*]\){" skip="\\}" end="}" contained contains=@perlExpr nextgroup=perlVarSimpleMember,perlVarMember,perlMethod,perlPostDeref
    2              0.000002 endif
                            
                            " File Descriptors
    2              0.000020 syn match  perlFiledescRead	"<\h\w*>"
                            
    2              0.000018 syn match  perlFiledescStatementComma	"(\=\s*\<\u\w*\>\s*,"me=e-1 transparent contained contains=perlFiledescStatement
    2              0.000015 syn match  perlFiledescStatementNocomma "(\=\s*\<\u\w*\>\s*[^, \t]"me=e-1 transparent contained contains=perlFiledescStatement
                            
    2              0.000010 syn match  perlFiledescStatement	"\<\u\w*\>" contained
                            
                            " Special characters in strings and matches
    2              0.000019 syn match  perlSpecialString	"\\\%(\o\{1,3}\|x\%({\x\+}\|\x\{1,2}\)\|c.\|[^cx]\)" contained extend
    2              0.000015 syn match  perlSpecialStringU2	"\\." extend contained contains=NONE
    2              0.000009 syn match  perlSpecialStringU	"\\\\" contained
    2              0.000011 syn match  perlSpecialMatch	"\\[1-9]" contained extend
    2              0.000032 syn match  perlSpecialMatch	"\\g\%(\d\+\|{\%(-\=\d\+\|\h\w*\)}\)" contained
    2              0.000014 syn match  perlSpecialMatch	"\\k\%(<\h\w*>\|'\h\w*'\)" contained
    2              0.000009 syn match  perlSpecialMatch	"{\d\+\%(,\%(\d\+\)\=\)\=}" contained
    2              0.000011 syn match  perlSpecialMatch	"\[[]-]\=[^\[\]]*[]-]\=\]" contained extend
    2              0.000007 syn match  perlSpecialMatch	"[+*()?.]" contained
    2              0.000007 syn match  perlSpecialMatch	"(?[#:=!]" contained
    2              0.000013 syn match  perlSpecialMatch	"(?[impsx]*\%(-[imsx]\+\)\=)" contained
    2              0.000013 syn match  perlSpecialMatch	"(?\%([-+]\=\d\+\|R\))" contained
    2              0.000009 syn match  perlSpecialMatch	"(?\%(&\|P[>=]\)\h\w*)" contained
    2              0.000021 syn match  perlSpecialMatch	"(\*\%(\%(PRUNE\|SKIP\|THEN\)\%(:[^)]*\)\=\|\%(MARK\|\):[^)]*\|COMMIT\|F\%(AIL\)\=\|ACCEPT\))" contained
                            
                            " Possible errors
                            "
                            " Highlight lines with only whitespace (only in blank delimited here documents) as errors
    2              0.000011 syn match  perlNotEmptyLine	"^\s\+$" contained
                            " Highlight "} else if (...) {", it should be "} else { if (...) { " or "} elsif (...) {"
    2              0.000017 syn match perlElseIfError	"else\_s*if" containedin=perlConditional
    2              0.000013 syn keyword perlElseIfError	elseif containedin=perlConditional
                            
                            " Variable interpolation
                            "
                            " These items are interpolated inside "" strings and similar constructs.
    2              0.000026 syn cluster perlInterpDQ	contains=perlSpecialString,perlVarPlain,perlVarNotInMatches,perlVarSlash,perlVarBlock
                            " These items are interpolated inside '' strings and similar constructs.
    2              0.000011 syn cluster perlInterpSQ	contains=perlSpecialStringU,perlSpecialStringU2
                            " These items are interpolated inside m// matches and s/// substitutions.
    2              0.000018 syn cluster perlInterpSlash	contains=perlSpecialString,perlSpecialMatch,perlVarPlain,perlVarBlock
                            " These items are interpolated inside m## matches and s### substitutions.
    2              0.000010 syn cluster perlInterpMatch	contains=@perlInterpSlash,perlVarSlash
                            
                            " Shell commands
    2              0.000020 syn region  perlShellCommand	matchgroup=perlMatchStartEnd start="`" end="`" contains=@perlInterpDQ keepend
                            
                            " Constants
                            "
                            " Numbers
    2              0.000025 syn match  perlNumber	"\<\%(0\%(x\x[[:xdigit:]_]*\|b[01][01_]*\|\o[0-7_]*\|\)\|[1-9][[:digit:]_]*\)\>"
    2              0.000019 syn match  perlFloat	"\<\d[[:digit:]_]*[eE][\-+]\=\d\+"
    2              0.000014 syn match  perlFloat	"\<\d[[:digit:]_]*\.[[:digit:]_]*\%([eE][\-+]\=\d\+\)\="
    2              0.000011 syn match  perlFloat    "\.[[:digit:]][[:digit:]_]*\%([eE][\-+]\=\d\+\)\="
                            
    2              0.000031 syn match  perlString	"\<\%(v\d\+\%(\.\d\+\)*\|\d\+\%(\.\d\+\)\{2,}\)\>" contains=perlVStringV
    2              0.000007 syn match  perlVStringV	"\<v" contained
                            
                            
    2              0.000021 syn region perlParensSQ		start=+(+ end=+)+ extend contained contains=perlParensSQ,@perlInterpSQ keepend
    2              0.000020 syn region perlBracketsSQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsSQ,@perlInterpSQ keepend
    2              0.000018 syn region perlBracesSQ		start=+{+ end=+}+ extend contained contains=perlBracesSQ,@perlInterpSQ keepend
    2              0.000018 syn region perlAnglesSQ		start=+<+ end=+>+ extend contained contains=perlAnglesSQ,@perlInterpSQ keepend
                            
    2              0.000025 syn region perlParensDQ		start=+(+ end=+)+ extend contained contains=perlParensDQ,@perlInterpDQ keepend
    2              0.000019 syn region perlBracketsDQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsDQ,@perlInterpDQ keepend
    2              0.000018 syn region perlBracesDQ		start=+{+ end=+}+ extend contained contains=perlBracesDQ,@perlInterpDQ keepend
    2              0.000016 syn region perlAnglesDQ		start=+<+ end=+>+ extend contained contains=perlAnglesDQ,@perlInterpDQ keepend
                            
                            
                            " Simple version of searches and matches
    2              0.000036 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1[msixpodualgcn]*+ contains=@perlInterpMatch keepend extend
    2              0.000027 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m#+ end=+#[msixpodualgcn]*+ contains=@perlInterpMatch keepend extend
    2              0.000020 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*'+ end=+'[msixpodualgcn]*+ contains=@perlInterpSQ keepend extend
    2              0.000053 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*/+ end=+/[msixpodualgcn]*+ contains=@perlInterpSlash keepend extend
    2              0.000043 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*(+ end=+)[msixpodualgcn]*+ contains=@perlInterpMatch,perlParensDQ keepend extend
    2              0.000032 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*{+ end=+}[msixpodualgcn]*+ contains=@perlInterpMatch,perlBracesDQ extend
    2              0.000024 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*<+ end=+>[msixpodualgcn]*+ contains=@perlInterpMatch,perlAnglesDQ keepend extend
    2              0.000074 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*\[+ end=+\][msixpodualgcn]*+ contains=@perlInterpMatch,perlBracketsDQ keepend extend
                            
                            " Below some hacks to recognise the // variant. This is virtually impossible to catch in all
                            " cases as the / is used in so many other ways, but these should be the most obvious ones.
    2              0.000070 syn region perlMatch	matchgroup=perlMatchStartEnd start="\%([$@%&*]\@<!\%(\<split\|\<while\|\<if\|\<unless\|\.\.\|[-+*!~(\[{=]\)\s*\)\@<=/\%(/=\)\@!" start=+^/\%(/=\)\@!+ start=+\s\@<=/\%(/=\)\@![^[:space:][:digit:]$@%=]\@=\%(/\_s*\%([([{$@%&*[:digit:]"'`]\|\_s\w\|[[:upper:]_abd-fhjklnqrt-wyz]\)\)\@!+ skip=+\\/+ end=+/[msixpodualgcn]*+ contains=@perlInterpSlash extend
                            
                            
                            " Substitutions
                            " perlMatch is the first part, perlSubstitution* is the substitution part
    2              0.000032 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    2              0.000031 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*'+  end=+'+me=e-1 contains=@perlInterpSQ nextgroup=perlSubstitutionSQ keepend extend
    2              0.000044 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*/+  end=+/+me=e-1 contains=@perlInterpSlash nextgroup=perlSubstitutionGQQ keepend extend
    2              0.000022 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s#+  end=+#+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    2              0.000025 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*(+ end=+)+ contains=@perlInterpMatch,perlParensDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    2              0.000029 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*<+ end=+>+ contains=@perlInterpMatch,perlAnglesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    2              0.000030 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*\[+ end=+\]+ contains=@perlInterpMatch,perlBracketsDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    2              0.000029 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*{+ end=+}+ contains=@perlInterpMatch,perlBracesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    2              0.000028 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]'([{<]\)+ end=+\z1[msixpodualgcern]*+ keepend contained contains=@perlInterpDQ extend
    2              0.000020 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+(+ end=+)[msixpodualgcern]*+ contained contains=@perlInterpDQ,perlParensDQ keepend extend
    2              0.000024 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\][msixpodualgcern]*+ contained contains=@perlInterpDQ,perlBracketsDQ keepend extend
    2              0.000019 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+{+ end=+}[msixpodualgcern]*+ contained contains=@perlInterpDQ,perlBracesDQ keepend extend extend
    2              0.000022 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+<+ end=+>[msixpodualgcern]*+ contained contains=@perlInterpDQ,perlAnglesDQ keepend extend
    2              0.000019 syn region perlSubstitutionSQ		matchgroup=perlMatchStartEnd start=+'+  end=+'[msixpodualgcern]*+ contained contains=@perlInterpSQ keepend extend
                            
                            " Translations
                            " perlMatch is the first part, perlTranslation* is the second, translator part.
    2              0.000035 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\>\s*\z([^[:space:]([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    2              0.000023 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)#+ end=+#+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    2              0.000031 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    2              0.000027 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    2              0.000026 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    2              0.000026 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    2              0.000036 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]([{<]\)+ end=+\z1[cdsr]*+ contained
    2              0.000017 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+(+ end=+)[cdsr]*+ contains=perlParensSQ contained
    2              0.000022 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\][cdsr]*+ contains=perlBracketsSQ contained
    2              0.000016 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+{+ end=+}[cdsr]*+ contains=perlBracesSQ contained
    2              0.000016 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+<+ end=+>[cdsr]*+ contains=perlAnglesSQ contained
                            
                            
                            " Strings and q, qq, qw and qr expressions
                            
    2              0.000024 syn region perlStringUnexpanded	matchgroup=perlStringStartEnd start="'" end="'" contains=@perlInterpSQ keepend extend
    2              0.000016 syn region perlString		matchgroup=perlStringStartEnd start=+"+  end=+"+ contains=@perlInterpDQ keepend extend
    2              0.000038 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpSQ keepend extend
    2              0.000022 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q#+ end=+#+ contains=@perlInterpSQ keepend extend
    2              0.000022 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    2              0.000027 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    2              0.000024 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    2              0.000020 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    2              0.000021 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpDQ keepend extend
    2              0.000021 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]#+ end=+#+ contains=@perlInterpDQ keepend extend
    2              0.000025 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*(+ end=+)+ contains=@perlInterpDQ,perlParensDQ keepend extend
    2              0.000024 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*\[+ end=+\]+ contains=@perlInterpDQ,perlBracketsDQ keepend extend
    2              0.000024 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*{+ end=+}+ contains=@perlInterpDQ,perlBracesDQ keepend extend
    2              0.000025 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*<+ end=+>+ contains=@perlInterpDQ,perlAnglesDQ keepend extend
                            
    2              0.000020 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\z([^[:space:]#([{<]\)+  end=+\z1+ contains=@perlInterpSQ keepend extend
    2              0.000018 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw#+  end=+#+ contains=@perlInterpSQ keepend extend
    2              0.000024 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*(+  end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    2              0.000027 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\[+  end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    2              0.000021 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*{+  end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    2              0.000024 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*<+  end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    2              0.000043 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\>\s*\z([^[:space:]#([{<'/]\)+  end=+\z1[imosxdual]*+ contains=@perlInterpMatch keepend extend
    2              0.000020 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*/+  end=+/[imosxdual]*+ contains=@perlInterpSlash keepend extend
    2              0.000082 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr#+  end=+#[imosxdual]*+ contains=@perlInterpMatch keepend extend
    2              0.000024 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*'+  end=+'[imosxdual]*+ contains=@perlInterpSQ keepend extend
    2              0.000026 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*(+  end=+)[imosxdual]*+ contains=@perlInterpMatch,perlParensDQ keepend extend
                            
                            " A special case for qr{}, qr<> and qr[] which allows for comments and extra whitespace in the pattern
    2              0.000033 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*{+  end=+}[imosxdual]*+ contains=@perlInterpMatch,perlBracesDQ,perlComment keepend extend
    2              0.000026 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*<+  end=+>[imosxdual]*+ contains=@perlInterpMatch,perlAnglesDQ,perlComment keepend extend
    2              0.000042 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*\[+  end=+\][imosxdual]*+ contains=@perlInterpMatch,perlBracketsDQ,perlComment keepend extend
                            
                            " Constructs such as print <<EOF [...] EOF, 'here' documents
                            "
                            " XXX Any statements after the identifier are in perlString colour (i.e.
                            " 'if $a' in 'print <<EOF if $a'). This is almost impossible to get right it
                            " seems due to the 'auto-extending nature' of regions.
    2              0.000028 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\z(\I\i*\)+  end=+$+     contains=@perlTop oneline
    2              0.000023 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ end=+$+ contains=@perlTop oneline
    2              0.000018 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ end=+$+ contains=@perlTop oneline
    2              0.000017 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\s*""+       end=+$+     contains=@perlTop oneline
    2              0.000020 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\s*''+       end=+$+     contains=@perlTop oneline
    2              0.000010 if exists("perl_fold")
                              syn region perlHereDoc	start=+<<\z(\I\i*\)+ matchgroup=perlStringStartEnd      end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ fold extend
                              syn region perlHereDoc	start=+<<\s*""+ matchgroup=perlStringStartEnd           end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
                              syn region perlHereDoc	start=+<<\s*''+ matchgroup=perlStringStartEnd           end=+^$+    contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine fold extend
                              syn region perlAutoload	matchgroup=perlStringStartEnd start=+<<\s*\(['"]\=\)\z(END_\%(SUB\|OF_FUNC\|OF_AUTOLOAD\)\)\1+ end=+^\z1$+ contains=ALL fold extend
                            else
    2              0.000024   syn region perlHereDoc	start=+<<\z(\I\i*\)+ matchgroup=perlStringStartEnd      end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    2              0.000028   syn region perlHereDoc	start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    2              0.000022   syn region perlHereDoc	start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ
    2              0.000042   syn region perlHereDoc	start=+<<\s*""+ matchgroup=perlStringStartEnd           end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    2              0.000024   syn region perlHereDoc	start=+<<\s*''+ matchgroup=perlStringStartEnd           end=+^$+    contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine
    2              0.000032   syn region perlAutoload	matchgroup=perlStringStartEnd start=+<<\s*\(['"]\=\)\z(END_\%(SUB\|OF_FUNC\|OF_AUTOLOAD\)\)\1+ end=+^\z1$+ contains=ALL
    2              0.000002 endif
                            
                            
                            " Class declarations
                            "
    2              0.000027 syn match   perlPackageDecl		"\<package\s\+\%(\h\|::\)\%(\w\|::\)*" contains=perlStatementPackage
    2              0.000007 syn keyword perlStatementPackage	package contained
                            
                            " Functions
                            "       sub [name] [(prototype)] {
                            "
    2              0.000012 syn match perlSubError "[^[:space:];{#]" contained
    2              0.000022 syn match perlSubAttributesCont "\h\w*\_s*\%(:\_s*\)\=" nextgroup=@perlSubAttrMaybe contained
    2              0.000026 syn region perlSubAttributesCont matchgroup=perlSubAttributesCont start="\h\w*(" end=")\_s*\%(:\_s*\)\=" nextgroup=@perlSubAttrMaybe contained contains=@perlInterpSQ,perlParensSQ
    2              0.000017 syn cluster perlSubAttrMaybe contains=perlSubAttributesCont,perlSubError,perlFakeGroup
    2              0.000012 syn match perlSubAttributes "" contained nextgroup=perlSubError
    2              0.000013 syn match perlSubAttributes ":\_s*" contained nextgroup=@perlSubAttrMaybe
    2              0.000010 if get(g:, "perl_sub_signatures", 0)
                                syn match perlSignature +(\_[^)]*)\_s*+ nextgroup=perlSubAttributes,perlComment contained
                            else
    2              0.000036     syn match perlSubPrototypeError "(\%(\_s*\%(\%(\\\%([$@%&*]\|\[[$@%&*]\+\]\)\|[$&*]\|[@%]\%(\_s*)\)\@=\|;\%(\_s*[)$@%&*\\]\)\@=\|_\%(\_s*[);]\)\@=\)\_s*\)*\)\@>\zs\_[^)]\+" contained
    2              0.000022     syn match perlSubPrototype +(\_[^)]*)\_s*+ nextgroup=perlSubAttributes,perlComment contained contains=perlSubPrototypeError
    2              0.000002 endif
                            
    2              0.000031 syn match perlSubName +\%(\h\|::\|'\w\)\%(\w\|::\|'\w\)*\_s*\|+ contained nextgroup=perlSubPrototype,perlSignature,perlSubAttributes,perlComment
                            
    2              0.000016 syn match perlFunction +\<sub\>\_s*+ nextgroup=perlSubName
                            
                            " The => operator forces a bareword to the left of it to be interpreted as
                            " a string
    2              0.000018 syn match  perlString "\I\@<!-\?\I\i*\%(\s*=>\)\@="
                            
                            " All other # are comments, except ^#!
    2              0.000017 syn match  perlComment		"#.*" contains=perlTodo,@Spell extend
    2              0.000014 syn match  perlSharpBang	"^#!.*"
                            
                            " Formats
    2              0.000053 syn region perlFormat		matchgroup=perlStatementIOFunc start="^\s*\<format\s\+\k\+\s*=\s*$"rs=s+6 end="^\s*\.\s*$" contains=perlFormatName,perlFormatField,perlVarPlain,perlVarPlain2
    2              0.000011 syn match  perlFormatName	"format\s\+\k\+\s*="lc=7,me=e-1 contained
    2              0.000009 syn match  perlFormatField	"[@^][|<>~]\+\%(\.\.\.\)\=" contained
    2              0.000023 syn match  perlFormatField	"[@^]#[#.]*" contained
    2              0.000006 syn match  perlFormatField	"@\*" contained
    2              0.000013 syn match  perlFormatField	"@[^A-Za-z_|<>~#*]"me=e-1 contained
    2              0.000006 syn match  perlFormatField	"@$" contained
                            
                            " __END__ and __DATA__ clauses
    2              0.000008 if exists("perl_fold")
                              syntax region perlDATA		start="^__DATA__$" skip="." end="." contains=@perlDATA fold
                              syntax region perlDATA		start="^__END__$" skip="." end="." contains=perlPOD,@perlDATA fold
                            else
    2              0.000025   syntax region perlDATA		start="^__DATA__$" skip="." end="." contains=@perlDATA
    2              0.000024   syntax region perlDATA		start="^__END__$" skip="." end="." contains=perlPOD,@perlDATA
    2              0.000002 endif
                            
                            "
                            " Folding
                            
    2              0.000005 if exists("perl_fold")
                              " Note: this bit must come before the actual highlighting of the "package"
                              " keyword, otherwise this will screw up Pod lines that match /^package/
                              if !exists("perl_nofold_packages")
                                syn region perlPackageFold start="^package \S\+;\s*\%(#.*\)\=$" end="^1;\=\s*\%(#.*\)\=$" end="\n\+package"me=s-1 transparent fold keepend
                              endif
                              if !exists("perl_nofold_subs")
                                if get(g:, "perl_fold_anonymous_subs", 0)
                                  syn region perlSubFold start="\<sub\>[^{]*{" end="}" transparent fold keepend extend
                                  syn region perlSubFold start="\<\%(BEGIN\|END\|CHECK\|INIT\)\>\s*{" end="}" transparent fold keepend
                                else
                                  syn region perlSubFold     start="^\z(\s*\)\<sub\>.*[^};]$" end="^\z1}\s*\%(#.*\)\=$" transparent fold keepend
                                  syn region perlSubFold start="^\z(\s*\)\<\%(BEGIN\|END\|CHECK\|INIT\|UNITCHECK\)\>.*[^};]$" end="^\z1}\s*$" transparent fold keepend
                                endif
                              endif
                            
                              if exists("perl_fold_blocks")
                                syn region perlBlockFold start="^\z(\s*\)\%(if\|elsif\|unless\|for\|while\|until\|given\)\s*(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" start="^\z(\s*\)for\%(each\)\=\s*\%(\%(my\|our\)\=\s*\S\+\s*\)\=(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                                syn region perlBlockFold start="^\z(\s*\)\%(do\|else\)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*while" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                              endif
                            
                              setlocal foldmethod=syntax
                              syn sync fromstart
                            else
                              " fromstart above seems to set minlines even if perl_fold is not set.
    2              0.000003   syn sync minlines=0
    2              0.000002 endif
                            
                            " NOTE: If you're linking new highlight groups to perlString, please also put
                            "       them into b:match_skip in ftplugin/perl.vim.
                            
                            " The default highlighting.
    2              0.000018 hi def link perlSharpBang		PreProc
    2              0.000008 hi def link perlControl		PreProc
    2              0.000010 hi def link perlInclude		Include
    2              0.000009 hi def link perlSpecial		Special
    2              0.000025 hi def link perlString		String
    2              0.000010 hi def link perlCharacter		Character
    2              0.000007 hi def link perlNumber		Number
    2              0.000008 hi def link perlFloat		Float
    2              0.000010 hi def link perlType			Type
    2              0.000010 hi def link perlIdentifier		Identifier
    2              0.000008 hi def link perlLabel		Label
    2              0.000010 hi def link perlStatement		Statement
    2              0.000008 hi def link perlConditional		Conditional
    2              0.000008 hi def link perlRepeat		Repeat
    2              0.000009 hi def link perlOperator		Operator
    2              0.000022 hi def link perlFunction		Keyword
    2              0.000008 hi def link perlSubName		Function
    2              0.000009 hi def link perlSubPrototype		Type
    2              0.000007 hi def link perlSignature		Type
    2              0.000008 hi def link perlSubAttributes	PreProc
    2              0.000005 hi def link perlSubAttributesCont	perlSubAttributes
    2              0.000008 hi def link perlComment		Comment
    2              0.000009 hi def link perlTodo			Todo
    2              0.000007 if exists("perl_string_as_statement")
                              hi def link perlStringStartEnd	perlStatement
                            else
    2              0.000006   hi def link perlStringStartEnd	perlString
    2              0.000001 endif
    2              0.000004 hi def link perlVStringV		perlStringStartEnd
    2              0.000007 hi def link perlList			perlStatement
    2              0.000006 hi def link perlMisc			perlStatement
    2              0.000005 hi def link perlVarPlain		perlIdentifier
    2              0.000005 hi def link perlVarPlain2		perlIdentifier
    2              0.000003 hi def link perlArrow		perlIdentifier
    2              0.000005 hi def link perlFiledescRead		perlIdentifier
    2              0.000005 hi def link perlFiledescStatement	perlIdentifier
    2              0.000020 hi def link perlVarSimpleMember	perlIdentifier
    2              0.000005 hi def link perlVarSimpleMemberName 	perlString
    2              0.000004 hi def link perlVarNotInMatches	perlIdentifier
    2              0.000004 hi def link perlVarSlash		perlIdentifier
    2              0.000005 hi def link perlQQ			perlString
    2              0.000004 hi def link perlHereDoc		perlString
    2              0.000006 hi def link perlStringUnexpanded	perlString
    2              0.000005 hi def link perlSubstitutionSQ	perlString
    2              0.000005 hi def link perlSubstitutionGQQ	perlString
    2              0.000004 hi def link perlTranslationGQ	perlString
    2              0.000005 hi def link perlMatch		perlString
    2              0.000018 hi def link perlMatchStartEnd	perlStatement
    2              0.000006 hi def link perlFormatName		perlIdentifier
    2              0.000004 hi def link perlFormatField		perlString
    2              0.000003 hi def link perlPackageDecl		perlType
    2              0.000007 hi def link perlStorageClass		perlType
    2              0.000005 hi def link perlPackageRef		perlType
    2              0.000005 hi def link perlStatementPackage	perlStatement
    2              0.000005 hi def link perlStatementStorage	perlStatement
    2              0.000004 hi def link perlStatementControl	perlStatement
    2              0.000005 hi def link perlStatementScalar	perlStatement
    2              0.000005 hi def link perlStatementRegexp	perlStatement
    2              0.000005 hi def link perlStatementNumeric	perlStatement
    2              0.000005 hi def link perlStatementList	perlStatement
    2              0.000004 hi def link perlStatementHash	perlStatement
    2              0.000006 hi def link perlStatementIOfunc	perlStatement
    2              0.000006 hi def link perlStatementFiledesc	perlStatement
    2              0.000005 hi def link perlStatementVector	perlStatement
    2              0.000004 hi def link perlStatementFiles	perlStatement
    2              0.000005 hi def link perlStatementFlow	perlStatement
    2              0.000005 hi def link perlStatementInclude	perlStatement
    2              0.000005 hi def link perlStatementProc	perlStatement
    2              0.000018 hi def link perlStatementSocket	perlStatement
    2              0.000005 hi def link perlStatementIPC		perlStatement
    2              0.000005 hi def link perlStatementNetwork	perlStatement
    2              0.000004 hi def link perlStatementPword	perlStatement
    2              0.000004 hi def link perlStatementTime	perlStatement
    2              0.000005 hi def link perlStatementMisc	perlStatement
    2              0.000005 hi def link perlStatementIndirObj	perlStatement
    2              0.000004 hi def link perlFunctionName		perlIdentifier
    2              0.000005 hi def link perlMethod		perlIdentifier
    2              0.000005 hi def link perlPostDeref		perlIdentifier
    2              0.000006 hi def link perlFunctionPRef		perlType
    2              0.000021 if !get(g:, 'perl_include_pod', 1)
                              hi def link perlPOD		perlComment
                            endif
    2              0.000006 hi def link perlShellCommand		perlString
    2              0.000007 hi def link perlSpecialAscii		perlSpecial
    2              0.000006 hi def link perlSpecialDollar	perlSpecial
    2              0.000005 hi def link perlSpecialString	perlSpecial
    2              0.000005 hi def link perlSpecialStringU	perlSpecial
    2              0.000004 hi def link perlSpecialMatch		perlSpecial
    2              0.000005 hi def link perlDATA			perlComment
                            
                            " NOTE: Due to a bug in Vim (or more likely, a misunderstanding on my part),
                            "       I had to remove the transparent property from the following regions
                            "       in order to get them to highlight correctly.  Feel free to remove
                            "       these and reinstate the transparent property if you know how.
    2              0.000005 hi def link perlParensSQ		perlString
    2              0.000005 hi def link perlBracketsSQ		perlString
    2              0.000004 hi def link perlBracesSQ		perlString
    2              0.000005 hi def link perlAnglesSQ		perlString
                            
    2              0.000005 hi def link perlParensDQ		perlString
    2              0.000018 hi def link perlBracketsDQ		perlString
    2              0.000005 hi def link perlBracesDQ		perlString
    2              0.000005 hi def link perlAnglesDQ		perlString
                            
    2              0.000005 hi def link perlSpecialStringU2	perlString
                            
                            " Possible errors
    2              0.000008 hi def link perlNotEmptyLine		Error
    2              0.000009 hi def link perlElseIfError		Error
    2              0.000008 hi def link perlSubPrototypeError	Error
    2              0.000008 hi def link perlSubError		Error
                            
                            " Syncing to speed up processing
                            "
    2              0.000008 if !exists("perl_no_sync_on_sub")
    2              0.000018   syn sync match perlSync	grouphere NONE "^\s*\<package\s"
    2              0.000011   syn sync match perlSync	grouphere NONE "^\s*\<sub\>"
    2              0.000009   syn sync match perlSync	grouphere NONE "^}"
    2              0.000002 endif
                            
    2              0.000005 if !exists("perl_no_sync_on_global_var")
    2              0.000012   syn sync match perlSync	grouphere NONE "^$\I[[:alnum:]_:]+\s*=\s*{"
    2              0.000011   syn sync match perlSync	grouphere NONE "^[@%]\I[[:alnum:]_:]+\s*=\s*("
    2              0.000002 endif
                            
    2              0.000005 if exists("perl_sync_dist")
                              execute "syn sync maxlines=" . perl_sync_dist
                            else
    2              0.000003   syn sync maxlines=100
    2              0.000002 endif
                            
    2              0.000016 syn sync match perlSyncPOD	grouphere perlPOD "^=pod"
    2              0.000029 syn sync match perlSyncPOD	grouphere perlPOD "^=head"
    2              0.000017 syn sync match perlSyncPOD	grouphere perlPOD "^=item"
    2              0.000009 syn sync match perlSyncPOD	grouphere NONE "^=cut"
                            
    2              0.000007 let b:current_syntax = "perl"
                            
    2              0.000020 let &cpo = s:cpo_save
    2              0.000005 unlet s:cpo_save
                            
                            " XXX Change to sts=4:sw=4
                            " vim:ts=8:sts=2:sw=2:expandtab:ft=vim

SCRIPT  /Users/jinwook/.vim/plugged/vim-polyglot/syntax/pod.vim
Sourced 2 times
Total time:   0.001329
 Self time:   0.001329

count  total (s)   self (s)
    2              0.000020 if !exists('g:polyglot_disabled') || index(g:polyglot_disabled, 'perl') == -1
                              
                            " Vim syntax file
                            " Language:      Perl POD format
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Previously:    Scott Bigham <dsb@killerbunnies.org>
                            " Homepage:      http://github.com/vim-perl/vim-perl
                            " Bugs/requests: http://github.com/vim-perl/vim-perl/issues
                            " Last Change:   {{LAST_CHANGE}}
                            
                            " To add embedded POD documentation highlighting to your syntax file, add
                            " the commands:
                            "
                            "   syn include @Pod <sfile>:p:h/pod.vim
                            "   syn region myPOD start="^=pod" start="^=head" end="^=cut" keepend contained contains=@Pod
                            "
                            " and add myPod to the contains= list of some existing region, probably a
                            " comment.  The "keepend" flag is needed because "=cut" is matched as a
                            " pattern in its own right.
                            
                            
                            " Remove any old syntax stuff hanging around (this is suppressed
                            " automatically by ":syn include" if necessary).
                            " quit when a syntax file was already loaded
    2              0.000008 if exists("b:current_syntax")
                              finish
                            endif
                            
    2              0.000010 let s:cpo_save = &cpo
    2              0.000013 set cpo&vim
                            
                            " POD commands
    2              0.000029 syn match podCommand    "^=encoding"  nextgroup=podCmdText contains=@NoSpell
    2              0.000018 syn match podCommand    "^=head[1234]"  nextgroup=podCmdText contains=@NoSpell
    2              0.000015 syn match podCommand    "^=item"        nextgroup=podCmdText contains=@NoSpell
    2              0.000041 syn match podCommand    "^=over"        nextgroup=podOverIndent skipwhite contains=@NoSpell
    2              0.000014 syn match podCommand    "^=back"        contains=@NoSpell
    2              0.000009 syn match podCommand    "^=cut"         contains=@NoSpell
    2              0.000008 syn match podCommand    "^=pod"         contains=@NoSpell
    2              0.000014 syn match podCommand    "^=for"         nextgroup=podForKeywd skipwhite contains=@NoSpell
    2              0.000014 syn match podCommand    "^=begin"       nextgroup=podForKeywd skipwhite contains=@NoSpell
    2              0.000013 syn match podCommand    "^=end"         nextgroup=podForKeywd skipwhite contains=@NoSpell
                            
                            " Text of a =head1, =head2 or =item command
    2              0.000016 syn match podCmdText	".*$" contained contains=podFormat,@NoSpell
                            
                            " Indent amount of =over command
    2              0.000010 syn match podOverIndent	"\d\+" contained contains=@NoSpell
                            
                            " Formatter identifier keyword for =for, =begin and =end commands
    2              0.000009 syn match podForKeywd	"\S\+" contained contains=@NoSpell
                            
                            " An indented line, to be displayed verbatim
    2              0.000032 syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                            " Inline textual items handled specially by POD
    2              0.000022 syn match podSpecial	"\(\<\|&\)\I\i*\(::\I\i*\)*([^)]*)" contains=@NoSpell
    2              0.000014 syn match podSpecial	"[$@%]\I\i*\(::\I\i*\)*\>" contains=@NoSpell
                            
                            " Special formatting sequences
    2              0.000031 syn region podFormat	start="[IBSCLFX]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
    2              0.000022 syn region podFormat	start="[IBSCLFX]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
    2              0.000008 syn match  podFormat	"Z<>"
    2              0.000027 syn match  podFormat	"E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
    2              0.000012 syn match  podEscape	"\I\i*>"me=e-1 contained contains=@NoSpell
    2              0.000052 syn match  podEscape2	"\d\+>"me=e-1 contained contains=@NoSpell
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    2              0.000011 hi def link podCommand		Statement
    2              0.000009 hi def link podCmdText		String
    2              0.000008 hi def link podOverIndent	Number
    2              0.000008 hi def link podForKeywd		Identifier
    2              0.000008 hi def link podFormat		Identifier
    2              0.000008 hi def link podVerbatimLine	PreProc
    2              0.000008 hi def link podSpecial		Identifier
    2              0.000006 hi def link podEscape		String
    2              0.000007 hi def link podEscape2		Number
                            
    2              0.000009 if exists("perl_pod_spellcheck_headings")
                              " Spell-check headings
                              syn clear podCmdText
                              syn match podCmdText    ".*$" contained contains=podFormat
                            endif
                            
    2              0.000008 if exists("perl_pod_formatting")
                              " By default, escapes like C<> are not checked for spelling. Remove B<>
                              " and I<> from the list of escapes.
                              syn clear podFormat
                              syn region podFormat start="[CLF]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
                              syn region podFormat start="[CLF]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
                            
                              " Don't spell-check inside E<>, but ensure that the E< itself isn't
                              " marked as a spelling mistake.
                              syn match podFormat   "E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
                            
                              " Z<> is a mock formatting code. Ensure Z<> on its own isn't marked as a
                              " spelling mistake.
                              syn match podFormat   "Z<>" contains=podEscape,podEscape2,@NoSpell
                            
                              " These are required so that whatever is *within* B<...>, I<...>, etc. is
                              " spell-checked, but not the B, I, ... itself.
                              syn match podBoldOpen    "B<" contains=@NoSpell
                              syn match podItalicOpen  "I<" contains=@NoSpell
                              syn match podNoSpaceOpen "S<" contains=@NoSpell
                              syn match podIndexOpen   "X<" contains=@NoSpell
                            
                              " Same as above but for the << >> syntax.
                              syn match podBoldAlternativeDelimOpen    "B<< " contains=@NoSpell
                              syn match podItalicAlternativeDelimOpen  "I<< " contains=@NoSpell
                              syn match podNoSpaceAlternativeDelimOpen "S<< " contains=@NoSpell
                              syn match podIndexAlternativeDelimOpen   "X<< " contains=@NoSpell
                            
                              " Add support for spell checking text inside B<>, I<>, S<> and X<>.
                              syn region podBold start="B<[^<]"me=e end=">" oneline contains=podBoldItalic,podBoldOpen
                              syn region podBoldAlternativeDelim start="B<<\s" end="\s>>" oneline contains=podBoldAlternativeDelimOpen
                            
                              syn region podItalic start="I<[^<]"me=e end=">" oneline contains=podItalicBold,podItalicOpen
                              syn region podItalicAlternativeDelim start="I<<\s" end="\s>>" oneline contains=podItalicAlternativeDelimOpen
                            
                              " Nested bold/italic and vice-versa
                              syn region podBoldItalic contained start="I<[^<]"me=e end=">" oneline
                              syn region podItalicBold contained start="B<[^<]"me=e end=">" oneline
                            
                              syn region podNoSpace start="S<[^<]"ms=s-2 end=">"me=e oneline contains=podNoSpaceOpen
                              syn region podNoSpaceAlternativeDelim start="S<<\s"ms=s-2 end="\s>>"me=e oneline contains=podNoSpaceAlternativeDelimOpen
                            
                              syn region podIndex start="X<[^<]"ms=s-2 end=">"me=e oneline contains=podIndexOpen
                              syn region podIndexAlternativeDelim start="X<<\s"ms=s-2 end="\s>>"me=e oneline contains=podIndexAlternativeDelimOpen
                            
                              " Restore this (otherwise B<> is shown as bold inside verbatim)
                              syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                              " Ensure formatted text can be displayed in headings and items
                              syn clear podCmdText
                            
                              if exists("perl_pod_spellcheck_headings")
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \podBoldOpen,podItalicOpen,podBoldAlternativeDelimOpen,
                                      \podItalicAlternativeDelimOpen,podNoSpaceOpen
                              else
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \@NoSpell
                              endif
                            
                              " Specify how to display these
                              hi def podBold term=bold cterm=bold gui=bold
                            
                              hi link podBoldAlternativeDelim podBold
                              hi link podBoldAlternativeDelimOpen podBold
                              hi link podBoldOpen podBold
                            
                              hi link podNoSpace                 Identifier
                              hi link podNoSpaceAlternativeDelim Identifier
                            
                              hi link podIndex                   Identifier
                              hi link podIndexAlternativeDelim   Identifier
                            
                              hi def podItalic term=italic cterm=italic gui=italic
                            
                              hi link podItalicAlternativeDelim podItalic
                              hi link podItalicAlternativeDelimOpen podItalic
                              hi link podItalicOpen podItalic
                            
                              hi def podBoldItalic term=italic,bold cterm=italic,bold gui=italic,bold
                              hi def podItalicBold term=italic,bold cterm=italic,bold gui=italic,bold
                            endif
                            
    2              0.000008 let b:current_syntax = "pod"
                            
    2              0.000016 let &cpo = s:cpo_save
    2              0.000004 unlet s:cpo_save
                            
                            " vim: ts=8
                            
    2              0.000010 endif

SCRIPT  /usr/local/Cellar/vim/8.1.0100/share/vim/vim81/syntax/pod.vim
Sourced 2 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:      Perl POD format
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Previously:    Scott Bigham <dsb@killerbunnies.org>
                            " Homepage:      http://github.com/vim-perl/vim-perl
                            " Bugs/requests: http://github.com/vim-perl/vim-perl/issues
                            " Last Change:   2017-09-12
                            
                            " To add embedded POD documentation highlighting to your syntax file, add
                            " the commands:
                            "
                            "   syn include @Pod <sfile>:p:h/pod.vim
                            "   syn region myPOD start="^=pod" start="^=head" end="^=cut" keepend contained contains=@Pod
                            "
                            " and add myPod to the contains= list of some existing region, probably a
                            " comment.  The "keepend" flag is needed because "=cut" is matched as a
                            " pattern in its own right.
                            
                            
                            " Remove any old syntax stuff hanging around (this is suppressed
                            " automatically by ":syn include" if necessary).
                            " quit when a syntax file was already loaded
    2              0.000013 if exists("b:current_syntax")
    2              0.000002   finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " POD commands
                            syn match podCommand    "^=encoding"  nextgroup=podCmdText contains=@NoSpell
                            syn match podCommand    "^=head[1234]"  nextgroup=podCmdText contains=@NoSpell
                            syn match podCommand    "^=item"        nextgroup=podCmdText contains=@NoSpell
                            syn match podCommand    "^=over"        nextgroup=podOverIndent skipwhite contains=@NoSpell
                            syn match podCommand    "^=back"        contains=@NoSpell
                            syn match podCommand    "^=cut"         contains=@NoSpell
                            syn match podCommand    "^=pod"         contains=@NoSpell
                            syn match podCommand    "^=for"         nextgroup=podForKeywd skipwhite contains=@NoSpell
                            syn match podCommand    "^=begin"       nextgroup=podForKeywd skipwhite contains=@NoSpell
                            syn match podCommand    "^=end"         nextgroup=podForKeywd skipwhite contains=@NoSpell
                            
                            " Text of a =head1, =head2 or =item command
                            syn match podCmdText	".*$" contained contains=podFormat,@NoSpell
                            
                            " Indent amount of =over command
                            syn match podOverIndent	"\d\+" contained contains=@NoSpell
                            
                            " Formatter identifier keyword for =for, =begin and =end commands
                            syn match podForKeywd	"\S\+" contained contains=@NoSpell
                            
                            " An indented line, to be displayed verbatim
                            syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                            " Inline textual items handled specially by POD
                            syn match podSpecial	"\(\<\|&\)\I\i*\(::\I\i*\)*([^)]*)" contains=@NoSpell
                            syn match podSpecial	"[$@%]\I\i*\(::\I\i*\)*\>" contains=@NoSpell
                            
                            " Special formatting sequences
                            syn region podFormat	start="[IBSCLFX]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
                            syn region podFormat	start="[IBSCLFX]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
                            syn match  podFormat	"Z<>"
                            syn match  podFormat	"E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
                            syn match  podEscape	"\I\i*>"me=e-1 contained contains=@NoSpell
                            syn match  podEscape2	"\d\+>"me=e-1 contained contains=@NoSpell
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
                            hi def link podCommand		Statement
                            hi def link podCmdText		String
                            hi def link podOverIndent	Number
                            hi def link podForKeywd		Identifier
                            hi def link podFormat		Identifier
                            hi def link podVerbatimLine	PreProc
                            hi def link podSpecial		Identifier
                            hi def link podEscape		String
                            hi def link podEscape2		Number
                            
                            if exists("perl_pod_spellcheck_headings")
                              " Spell-check headings
                              syn clear podCmdText
                              syn match podCmdText    ".*$" contained contains=podFormat
                            endif
                            
                            if exists("perl_pod_formatting")
                              " By default, escapes like C<> are not checked for spelling. Remove B<>
                              " and I<> from the list of escapes.
                              syn clear podFormat
                              syn region podFormat start="[CLF]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
                              syn region podFormat start="[CLF]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
                            
                              " Don't spell-check inside E<>, but ensure that the E< itself isn't
                              " marked as a spelling mistake.
                              syn match podFormat   "E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
                            
                              " Z<> is a mock formatting code. Ensure Z<> on its own isn't marked as a
                              " spelling mistake.
                              syn match podFormat   "Z<>" contains=podEscape,podEscape2,@NoSpell
                            
                              " These are required so that whatever is *within* B<...>, I<...>, etc. is
                              " spell-checked, but not the B, I, ... itself.
                              syn match podBoldOpen    "B<" contains=@NoSpell
                              syn match podItalicOpen  "I<" contains=@NoSpell
                              syn match podNoSpaceOpen "S<" contains=@NoSpell
                              syn match podIndexOpen   "X<" contains=@NoSpell
                            
                              " Same as above but for the << >> syntax.
                              syn match podBoldAlternativeDelimOpen    "B<< " contains=@NoSpell
                              syn match podItalicAlternativeDelimOpen  "I<< " contains=@NoSpell
                              syn match podNoSpaceAlternativeDelimOpen "S<< " contains=@NoSpell
                              syn match podIndexAlternativeDelimOpen   "X<< " contains=@NoSpell
                            
                              " Add support for spell checking text inside B<>, I<>, S<> and X<>.
                              syn region podBold start="B<[^<]"me=e end=">" oneline contains=podBoldItalic,podBoldOpen
                              syn region podBoldAlternativeDelim start="B<<\s" end="\s>>" oneline contains=podBoldAlternativeDelimOpen
                            
                              syn region podItalic start="I<[^<]"me=e end=">" oneline contains=podItalicBold,podItalicOpen
                              syn region podItalicAlternativeDelim start="I<<\s" end="\s>>" oneline contains=podItalicAlternativeDelimOpen
                            
                              " Nested bold/italic and vice-versa
                              syn region podBoldItalic contained start="I<[^<]"me=e end=">" oneline
                              syn region podItalicBold contained start="B<[^<]"me=e end=">" oneline
                            
                              syn region podNoSpace start="S<[^<]"ms=s-2 end=">"me=e oneline contains=podNoSpaceOpen
                              syn region podNoSpaceAlternativeDelim start="S<<\s"ms=s-2 end="\s>>"me=e oneline contains=podNoSpaceAlternativeDelimOpen
                            
                              syn region podIndex start="X<[^<]"ms=s-2 end=">"me=e oneline contains=podIndexOpen
                              syn region podIndexAlternativeDelim start="X<<\s"ms=s-2 end="\s>>"me=e oneline contains=podIndexAlternativeDelimOpen
                            
                              " Restore this (otherwise B<> is shown as bold inside verbatim)
                              syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                              " Ensure formatted text can be displayed in headings and items
                              syn clear podCmdText
                            
                              if exists("perl_pod_spellcheck_headings")
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \podBoldOpen,podItalicOpen,podBoldAlternativeDelimOpen,
                                      \podItalicAlternativeDelimOpen,podNoSpaceOpen
                              else
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \@NoSpell
                              endif
                            
                              " Specify how to display these
                              hi def podBold term=bold cterm=bold gui=bold
                            
                              hi link podBoldAlternativeDelim podBold
                              hi link podBoldAlternativeDelimOpen podBold
                              hi link podBoldOpen podBold
                            
                              hi link podNoSpace                 Identifier
                              hi link podNoSpaceAlternativeDelim Identifier
                            
                              hi link podIndex                   Identifier
                              hi link podIndexAlternativeDelim   Identifier
                            
                              hi def podItalic term=italic cterm=italic gui=italic
                            
                              hi link podItalicAlternativeDelim podItalic
                              hi link podItalicAlternativeDelimOpen podItalic
                              hi link podItalicOpen podItalic
                            
                              hi def podBoldItalic term=italic,bold cterm=italic,bold gui=italic,bold
                              hi def podItalicBold term=italic,bold cterm=italic,bold gui=italic,bold
                            endif
                            
                            let b:current_syntax = "pod"
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/vim/8.1.0100/share/vim/vim81/syntax/ruby.vim
Sourced 2 times
Total time:   0.007954
 Self time:   0.007765

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
                            " Prelude {{{1
    2              0.000013 if exists("b:current_syntax")
                              finish
                            endif
                            
                            " this file uses line continuations
    2              0.000011 let s:cpo_sav = &cpo
    2              0.000013 set cpo&vim
                            
                            " Folding Config {{{1
    2              0.000009 if has("folding") && exists("ruby_fold")
                              setlocal foldmethod=syntax
                            endif
                            
    2              0.000047 let s:foldable_groups = split(
                                  \	  get(
                                  \	    b:,
                                  \	    'ruby_foldable_groups',
                                  \	    get(g:, 'ruby_foldable_groups', 'ALL')
                                  \	  )
                                  \	)
                            
    2              0.000007 function! s:foldable(...) abort
                              if index(s:foldable_groups, 'ALL') > -1
                                return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0
                            endfunction " }}}
                            
    2              0.000053 syn cluster rubyNotTop contains=@rubyExtendedStringSpecial,@rubyRegexpSpecial,@rubyDeclaration,rubyConditional,rubyExceptional,rubyMethodExceptional,rubyTodo
                            
                            " Whitespace Errors {{{1
    2              0.000006 if exists("ruby_space_errors")
                              if !exists("ruby_no_trail_space_error")
                                syn match rubySpaceError display excludenl "\s\+$"
                              endif
                              if !exists("ruby_no_tab_space_error")
                                syn match rubySpaceError display " \+\t"me=e-1
                              endif
                            endif
                            
                            " Operators {{{1
    2              0.000005 if exists("ruby_operators")
                              syn match  rubyOperator "[~!^|*/%+-]\|&\.\@!\|\%(class\s*\)\@<!<<\|<=>\|<=\|\%(<\|\<class\s\+\u\w*\s*\)\@<!<[^<]\@=\|===\|==\|=\~\|>>\|>=\|=\@1<!>\|\*\*\|\.\.\.\|\.\.\|::"
                              syn match  rubyOperator "->\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|&&\|||=\||=\|||\|%=\|+=\|!\~\|!="
                              syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\w[?!]\=\|[]})]\)\@2<=\[\s*" end="\s*]" contains=ALLBUT,@rubyNotTop
                            endif
                            
                            " Expression Substitution and Backslash Notation {{{1
    2              0.000018 syn match rubyStringEscape "\\\\\|\\[abefnrstv]\|\\\o\{1,3}\|\\x\x\{1,2}"						    contained display
    2              0.000020 syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)" contained display
    2              0.000025 syn match rubyQuoteEscape  "\\[\\']"											    contained display
                            
    2              0.000022 syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
    2              0.000039 syn match  rubyInterpolation	      "#\%(\$\|@@\=\)\w\+"    display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable,rubyPredefinedVariable
    2              0.000010 syn match  rubyInterpolationDelimiter "#\ze\%(\$\|@@\=\)\w\+" display contained
    2              0.000024 syn match  rubyInterpolation	      "#\$\%(-\w\|\W\)"       display contained contains=rubyInterpolationDelimiter,rubyPredefinedVariable,rubyInvalidVariable
    2              0.000007 syn match  rubyInterpolationDelimiter "#\ze\$\%(-\w\|\W\)"    display contained
    2              0.000019 syn region rubyNoInterpolation	      start="\\#{" end="}"	      contained
    2              0.000008 syn match  rubyNoInterpolation	      "\\#{"		      display contained
    2              0.000009 syn match  rubyNoInterpolation	      "\\#\%(\$\|@@\=\)\w\+"  display contained
    2              0.000023 syn match  rubyNoInterpolation	      "\\#\$\W"		      display contained
                            
    2              0.000015 syn match rubyDelimiterEscape	"\\[(<{\[)>}\]]" transparent display contained contains=NONE
                            
    2              0.000026 syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  matchgroup=rubyString end=")"	transparent contained
    2              0.000022 syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  matchgroup=rubyString end="}"	transparent contained
    2              0.000091 syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  matchgroup=rubyString end=">"	transparent contained
    2              0.000022 syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" matchgroup=rubyString end="\]"	transparent contained
                            
                            " Regular Expression Metacharacters {{{1
                            " These are mostly Oniguruma ready
    2              0.000023 syn region rubyRegexpComment	matchgroup=rubyRegexpSpecial   start="(?#"								  skip="\\)"  end=")"  contained
    2              0.000102 syn region rubyRegexpParens	matchgroup=rubyRegexpSpecial   start="(\(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\)"  end=")"  contained transparent contains=@rubyRegexpSpecial
    2              0.000034 syn region rubyRegexpBrackets	matchgroup=rubyRegexpCharClass start="\[\^\="								  skip="\\\]" end="\]" contained transparent contains=rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass oneline
    2              0.000011 syn match  rubyRegexpCharClass	"\\[DdHhSsWw]"	       contained display
    2              0.000018 syn match  rubyRegexpCharClass	"\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\):\]" contained
    2              0.000008 syn match  rubyRegexpEscape	"\\[].*?+^$|\\/(){}[]" contained
    2              0.000010 syn match  rubyRegexpQuantifier	"[*?+][?+]\="	       contained display
    2              0.000032 syn match  rubyRegexpQuantifier	"{\d\+\%(,\d*\)\=}?\=" contained display
    2              0.000011 syn match  rubyRegexpAnchor	"[$^]\|\\[ABbGZz]"     contained display
    2              0.000010 syn match  rubyRegexpDot	"\."		       contained display
    2              0.000010 syn match  rubyRegexpSpecial	"|"		       contained display
    2              0.000031 syn match  rubyRegexpSpecial	"\\[1-9]\d\=\d\@!"     contained display
    2              0.000017 syn match  rubyRegexpSpecial	"\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
    2              0.000013 syn match  rubyRegexpSpecial	"\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
    2              0.000013 syn match  rubyRegexpSpecial	"\\g<\%([a-z_]\w*\|-\=\d\+\)>" contained display
    2              0.000016 syn match  rubyRegexpSpecial	"\\g'\%([a-z_]\w*\|-\=\d\+\)'" contained display
                            
    2              0.000015 syn cluster rubyStringSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape
    2              0.000019 syn cluster rubyExtendedStringSpecial contains=@rubyStringSpecial,rubyNestedParentheses,rubyNestedCurlyBraces,rubyNestedAngleBrackets,rubyNestedSquareBrackets
    2              0.000045 syn cluster rubyRegexpSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment
                            
                            " Numbers and ASCII Codes {{{1
    2              0.000027 syn match rubyASCIICode "\%(\w\|[]})\"'/]\)\@1<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)"
    2              0.000020 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*r\=i\=\>"								display
    2              0.000034 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)r\=i\=\>"						display
    2              0.000012 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*r\=i\=\>"								display
    2              0.000013 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*r\=i\=\>"								display
    2              0.000018 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*r\=i\=\>"					display
    2              0.000017 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)r\=i\=\>"	display
                            
                            " Identifiers {{{1
    2              0.000019 syn match rubyLocalVariableOrMethod "\<[_[:lower:]][_[:alnum:]]*[?!=]\=" contains=NONE display transparent
    2              0.000015 syn match rubyBlockArgument	    "&[_[:lower:]][_[:alnum:]]"		 contains=NONE display transparent
                            
    2              0.000018 syn match  rubyConstant		"\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!"
    2              0.000011 syn match  rubyClassVariable	"@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
    2              0.000097 syn match  rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"	display
    2              0.000014 syn match  rubyGlobalVariable	"$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
    2              0.000027 syn match  rubySymbol		"[]})\"':]\@1<!:\%(\^\|\~@\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!@\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)"
    2              0.000021 syn match  rubySymbol		"[]})\"':]\@1<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"
    2              0.000017 syn match  rubySymbol		"[]})\"':]\@1<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"
    2              0.000017 syn match  rubySymbol		"[]})\"':]\@1<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\="
                            
    2   0.000090   0.000077 if s:foldable(':')
    2              0.000031   syn region rubySymbol		start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape fold
    2              0.000103   syn region rubySymbol		start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial fold
    2              0.000003 else
                              syn region rubySymbol		start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape
                              syn region rubySymbol		start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial
                            endif
                            
    2              0.000019 syn match  rubyCapitalizedMethod	"\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)*\s*(\@="
                            
    2              0.000028 syn match  rubyBlockParameter	  "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" contained
    2              0.000022 syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\_s*\)\@32<=|" end="|" oneline display contains=rubyBlockParameter
                            
    2              0.000013 syn match rubyInvalidVariable	 "$[^ A-Za-z_-]"
    2              0.000010 syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<=>?@\`~]#
    2              0.000008 syn match rubyPredefinedVariable "$\d\+"										   display
    2              0.000088 syn match rubyPredefinedVariable "$_\>"											   display
    2              0.000012 syn match rubyPredefinedVariable "$-[0FIKadilpvw]\>"									   display
    2              0.000013 syn match rubyPredefinedVariable "$\%(deferr\|defout\|stderr\|stdin\|stdout\)\>"					   display
    2              0.000016 syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|KCODE\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
    2              0.000024 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(ARGF\|ARGV\|ENV\|DATA\|FALSE\|NIL\|STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\|TRUE\)\>\%(\s*(\)\@!"
    2              0.000036 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
                            
                            " Normal Regular Expression {{{1
    2   0.000021   0.000011 if s:foldable('/')
    2              0.000052   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
    2              0.000051   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\h\k*\s\+\)\@<=/[ \t=]\@!" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
    2              0.000003 else
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\h\k*\s\+\)\@<=/[ \t=]\@!" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial
                            endif
                            
                            " Generalized Regular Expression {{{1
    2   0.000018   0.000009 if s:foldable('%')
    2              0.000037   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial fold
    2              0.000030   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r{"				end="}[iomxneus]*"   skip="\\\\\|\\}"	 contains=@rubyRegexpSpecial fold
    2              0.000040   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r<"				end=">[iomxneus]*"   skip="\\\\\|\\>"	 contains=@rubyRegexpSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape fold
    2              0.000032   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\["				end="\][iomxneus]*"  skip="\\\\\|\\\]"	 contains=@rubyRegexpSpecial fold
    2              0.000032   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r("				end=")[iomxneus]*"   skip="\\\\\|\\)"	 contains=@rubyRegexpSpecial fold
    2              0.000052   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z(\s\)"				end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial fold
    2              0.000002 else
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r{"				end="}[iomxneus]*"   skip="\\\\\|\\}"	 contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r<"				end=">[iomxneus]*"   skip="\\\\\|\\>"	 contains=@rubyRegexpSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\["				end="\][iomxneus]*"  skip="\\\\\|\\\]"	 contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r("				end=")[iomxneus]*"   skip="\\\\\|\\)"	 contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z(\s\)"				end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
                            endif
                            
                            " Normal String {{{1
    2              0.000016 let s:spell_cluster = exists('ruby_spellcheck_strings') ? ',@Spell' : ''
    2   0.000073   0.000064 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\"" ' .
                                  \ (s:foldable('%') ? 'fold' : '') . ' contains=@rubyStringSpecial' . s:spell_cluster
    2   0.000046   0.000038 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="''" end="''" skip="\\\\\|\\''" ' .
                                  \ (s:foldable('%') ? 'fold' : '') . ' contains=rubyQuoteEscape'	 . s:spell_cluster
                            
                            " Shell Command Output {{{1
    2   0.000015   0.000007 if s:foldable('%')
    2              0.000019   syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial fold
    2              0.000002 else
                              syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial
                            endif
                            
                            " Generalized Single Quoted String, Symbol and Array of Strings {{{1
    2   0.000014   0.000007 if s:foldable('%')
    2              0.000022   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" fold
    2              0.000028   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]{"				     end="}"   skip="\\\\\|\\}"	  fold contains=rubyNestedCurlyBraces,rubyDelimiterEscape
    2              0.000045   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]<"				     end=">"   skip="\\\\\|\\>"	  fold contains=rubyNestedAngleBrackets,rubyDelimiterEscape
    2              0.000023   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\["				     end="\]"  skip="\\\\\|\\\]"  fold contains=rubyNestedSquareBrackets,rubyDelimiterEscape
    2              0.000026   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]("				     end=")"   skip="\\\\\|\\)"	  fold contains=rubyNestedParentheses,rubyDelimiterEscape
    2              0.000026   syn region rubyString matchgroup=rubyStringDelimiter start="%q\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1" fold
    2              0.000029   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)"    end="\z1" skip="\\\\\|\\\z1" fold
    2              0.000027   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s{"				     end="}"   skip="\\\\\|\\}"	  fold contains=rubyNestedCurlyBraces,rubyDelimiterEscape
    2              0.000032   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s<"				     end=">"   skip="\\\\\|\\>"	  fold contains=rubyNestedAngleBrackets,rubyDelimiterEscape
    2              0.000031   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\["				     end="\]"  skip="\\\\\|\\\]"  fold contains=rubyNestedSquareBrackets,rubyDelimiterEscape
    2              0.000027   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s("				     end=")"   skip="\\\\\|\\)"	  fold contains=rubyNestedParentheses,rubyDelimiterEscape
    2              0.000016   syn region rubyString matchgroup=rubyStringDelimiter start="%s\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1" fold
    2              0.000001 else
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]{"				     end="}"   skip="\\\\\|\\}"	  contains=rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]<"				     end=">"   skip="\\\\\|\\>"	  contains=rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\["				     end="\]"  skip="\\\\\|\\\]"  contains=rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]("				     end=")"   skip="\\\\\|\\)"	  contains=rubyNestedParentheses,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%q\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1"
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)"    end="\z1" skip="\\\\\|\\\z1"
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s{"				     end="}"   skip="\\\\\|\\}"	  contains=rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s<"				     end=">"   skip="\\\\\|\\>"	  contains=rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\["				     end="\]"  skip="\\\\\|\\\]"  contains=rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s("				     end=")"   skip="\\\\\|\\)"	  contains=rubyNestedParentheses,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%s\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1"
                            endif
                            
                            " Generalized Double Quoted String and Array of Strings and Shell Command Output {{{1
                            " Note: %= is not matched here as the beginning of a double quoted string
    2   0.000019   0.000009 if s:foldable('%')
    2              0.000023   syn region rubyString matchgroup=rubyStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"	      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    2              0.000027   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    2              0.000026   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\={"			      end="}"	skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape    fold
    2              0.000041   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=<"			      end=">"	skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape  fold
    2              0.000033   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=\["			      end="\]"	skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape fold
    2              0.000030   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=("			      end=")"	skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape    fold
    2              0.000020   syn region rubyString matchgroup=rubyStringDelimiter start="%[Qx]\z(\s\)"			      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    2              0.000001 else
                              syn region rubyString matchgroup=rubyStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"	      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\={"			      end="}"	skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=<"			      end=">"	skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=\["			      end="\]"	skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=("			      end=")"	skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[Qx]\z(\s\)"			      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                            endif
                            
                            " Array of Symbols {{{1
    2   0.000018   0.000010 if s:foldable('%')
                              " Array of Symbols
    2              0.000027   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"	fold
    2              0.000113   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i{"				  end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimiterEscape
    2              0.000027   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i<"				  end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimiterEscape
    2              0.000026   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\["				  end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimiterEscape
    2              0.000033   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i("				  end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimiterEscape
                            
                              " Array of interpolated Symbols
    2              0.000032   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"	contains=@rubyStringSpecial fold
    2              0.000028   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I{"				  end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape    fold
    2              0.000034   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I<"				  end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape  fold
    2              0.000032   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\["				  end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape fold
    2              0.000028   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I("				  end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape    fold
    2              0.000002 else
                              " Array of Symbols
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i{"				  end="}"   skip="\\\\\|\\}"	contains=rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i<"				  end=">"   skip="\\\\\|\\>"	contains=rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\["				  end="\]"  skip="\\\\\|\\\]"	contains=rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i("				  end=")"   skip="\\\\\|\\)"	contains=rubyNestedParentheses,rubyDelimiterEscape
                            
                              " Array of interpolated Symbols
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"	contains=@rubyStringSpecial
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I{"				  end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I<"				  end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\["				  end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I("				  end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape
                            endif
                            
                            " Here Document {{{1
    2              0.000039 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+	 end=+$+ oneline contains=ALLBUT,@rubyNotTop
    2              0.000030 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs"\%([^"]*\)"+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    2              0.000022 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs'\%([^']*\)'+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    2              0.000019 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs`\%([^`]*\)`+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    2   0.000024   0.000014 if s:foldable('<<')
    2              0.000044   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    2              0.000042   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    2              0.000028   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc		    fold keepend
    2              0.000028   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
                            
    2              0.000031   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3    matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    2              0.000026   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    2              0.000028   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		    fold keepend
    2              0.000030   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    2              0.000002 else
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc		    keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial keepend
                            
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3    matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		    keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                            endif
                            
                            " eRuby Config {{{1
    2              0.000024 if exists('main_syntax') && main_syntax == 'eruby'
                              let b:ruby_no_expensive = 1
                            end
                            
                            " Module, Class, Method and Alias Declarations {{{1
    2              0.000054 syn match  rubyAliasDeclaration    "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable nextgroup=rubyAliasDeclaration2 skipwhite
    2              0.000027 syn match  rubyAliasDeclaration2   "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable
    2              0.000045 syn match  rubyMethodDeclaration   "[^[:space:];#(]\+"	 contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
    2              0.000017 syn match  rubyClassDeclaration    "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    2              0.000019 syn match  rubyModuleDeclaration   "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    2              0.000018 syn match  rubyFunction "\<[_[:alpha:]][_[:alnum:]]*[?!=]\=[[:alnum:]_.:?!=]\@!" contained containedin=rubyMethodDeclaration
    2              0.000046 syn match  rubyFunction "\%(\s\|^\)\@1<=[_[:alpha:]][_[:alnum:]]*[?!=]\=\%(\s\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
    2              0.000033 syn match  rubyFunction "\%([[:space:].]\|^\)\@2<=\%(\[\]=\=\|\*\*\|[-+!~]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
                            
    2              0.000024 syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyFunction,rubyBlockParameter
                            
                            " Keywords {{{1
                            " Note: the following keywords have already been defined:
                            " begin case class def do end for if module unless until while
    2              0.000021 syn match   rubyControl	       "\<\%(and\|break\|in\|next\|not\|or\|redo\|rescue\|retry\|return\)\>[?!]\@!"
    2              0.000025 syn match   rubyOperator       "\<defined?" display
    2              0.000013 syn match   rubyKeyword	       "\<\%(super\|yield\)\>[?!]\@!"
    2              0.000010 syn match   rubyBoolean	       "\<\%(true\|false\)\>[?!]\@!"
    2              0.000016 syn match   rubyPseudoVariable "\<\%(nil\|self\|__ENCODING__\|__dir__\|__FILE__\|__LINE__\|__callee__\|__method__\)\>[?!]\@!" " TODO: reorganise
    2              0.000020 syn match   rubyBeginEnd       "\<\%(BEGIN\|END\)\>[?!]\@!"
                            
                            " Expensive Mode {{{1
                            " Match 'end' with the appropriate opening keyword for syntax based folding
                            " and special highlighting of module/class/method definitions
    2              0.000014 if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
    2              0.000015   syn match  rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration  skipwhite skipnl
    2              0.000011   syn match  rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
    2              0.000027   syn match  rubyDefine "\<undef\>"  nextgroup=rubyFunction	     skipwhite skipnl
    2              0.000015   syn match  rubyClass	"\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
    2              0.000013   syn match  rubyModule "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
                            
    2   0.000021   0.000011   if s:foldable('def')
    2              0.000035     syn region rubyMethodBlock start="\<def\>"	matchgroup=rubyDefine end="\%(\<def\_s\+\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
    2              0.000002   else
                                syn region rubyMethodBlock start="\<def\>"	matchgroup=rubyDefine end="\%(\<def\_s\+\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    2   0.000016   0.000008   if s:foldable('class')
    2              0.000024     syn region rubyBlock start="\<class\>"	matchgroup=rubyClass end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    2              0.000002   else
                                syn region rubyBlock start="\<class\>"	matchgroup=rubyClass end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    2   0.000014   0.000006   if s:foldable('module')
    2              0.000031     syn region rubyBlock start="\<module\>" matchgroup=rubyModule end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    2              0.000002   else
                                syn region rubyBlock start="\<module\>" matchgroup=rubyModule end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              " modifiers
    2              0.000022   syn match rubyLineContinuation    "\\$" nextgroup=rubyConditionalModifier,rubyRepeatModifier skipwhite skipnl
    2              0.000013   syn match rubyConditionalModifier "\<\%(if\|unless\)\>"
    2              0.000009   syn match rubyRepeatModifier	    "\<\%(while\|until\)\>"
                            
    2   0.000015   0.000007   if s:foldable('do')
    2              0.000041     syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    2              0.000002   else
                                syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              " curly bracket block or hash literal
    2   0.000015   0.000008   if s:foldable('{')
    2              0.000021     syn region rubyCurlyBlock matchgroup=rubyCurlyBlockDelimiter start="{" end="}" contains=ALLBUT,@rubyNotTop fold
    2              0.000002   else
                                syn region rubyCurlyBlock matchgroup=rubyCurlyBlockDelimiter start="{" end="}" contains=ALLBUT,@rubyNotTop
                              endif
                            
    2   0.000013   0.000005   if s:foldable('[')
    2              0.000025     syn region rubyArrayLiteral	matchgroup=rubyArrayDelimiter start="\%(\w\|[\]})]\)\@<!\[" end="]" contains=ALLBUT,@rubyNotTop fold
    2              0.000002   else
                                syn region rubyArrayLiteral	matchgroup=rubyArrayDelimiter start="\%(\w\|[\]})]\)\@<!\[" end="]" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              " statements without 'do'
    2   0.000019   0.000011   if s:foldable('begin')
    2              0.000027     syn region rubyBlockExpression matchgroup=rubyControl start="\<begin\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    2              0.000002   else
                                syn region rubyBlockExpression matchgroup=rubyControl start="\<begin\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    2   0.000014   0.000008   if s:foldable('case')
    2              0.000029     syn region rubyCaseExpression matchgroup=rubyConditional start="\<case\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    2              0.000002   else
                                syn region rubyCaseExpression matchgroup=rubyConditional start="\<case\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    2   0.000017   0.000009   if s:foldable('if')
    2              0.000040     syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*%&^|+=-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" end="\%(\%(\%(\.\@1<!\.\)\|::\)\s*\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
    2              0.000003   else
                                syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*%&^|+=-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" end="\%(\%(\%(\.\@1<!\.\)\|::\)\s*\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
    2              0.000014   syn match rubyConditional "\<\%(then\|else\|when\)\>[?!]\@!"	contained containedin=rubyCaseExpression
    2              0.000011   syn match rubyConditional "\<\%(then\|else\|elsif\)\>[?!]\@!" contained containedin=rubyConditionalExpression
                            
    2              0.000015   syn match rubyExceptional	  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyBlockExpression
    2              0.000013   syn match rubyMethodExceptional "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyMethodBlock
                            
                              " statements with optional 'do'
    2              0.000057   syn region rubyOptionalDoLine   matchgroup=rubyRepeat start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\%(\<do\>\)" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
                            
    2   0.000032   0.000023   if s:foldable('for')
    2              0.000039     syn region rubyRepeatExpression start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine fold
    2              0.000003   else
                                syn region rubyRepeatExpression start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine
                              endif
                            
    2              0.000006   if !exists("ruby_minlines")
    1              0.000006     let ruby_minlines = 500
    1              0.000001   endif
    2              0.000014   exec "syn sync minlines=" . ruby_minlines
                            
    2              0.000001 else
                              syn match rubyControl "\<def\>[?!]\@!"    nextgroup=rubyMethodDeclaration skipwhite skipnl
                              syn match rubyControl "\<class\>[?!]\@!"  nextgroup=rubyClassDeclaration  skipwhite skipnl
                              syn match rubyControl "\<module\>[?!]\@!" nextgroup=rubyModuleDeclaration skipwhite skipnl
                              syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|ensure\|then\|when\|end\)\>[?!]\@!"
                              syn match rubyKeyword "\<\%(alias\|undef\)\>[?!]\@!"
                            endif
                            
                            " Special Methods {{{1
    2              0.000008 if !exists("ruby_no_special_methods")
    2              0.000016   syn keyword rubyAccess    public protected private public_class_method private_class_method public_constant private_constant module_function
                              " attr is a common variable name
    2              0.000015   syn match   rubyAttribute "\%(\%(^\|;\)\s*\)\@<=attr\>\(\s*[.=]\)\@!"
    2              0.000008   syn keyword rubyAttribute attr_accessor attr_reader attr_writer
    2              0.000020   syn match   rubyControl   "\<\%(exit!\|\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>[?!]\@!\)"
    2              0.000011   syn keyword rubyEval	    eval class_eval instance_eval module_eval
    2              0.000012   syn keyword rubyException raise fail catch throw
                              " false positive with 'include?'
    2              0.000017   syn match   rubyInclude   "\<include\>[?!]\@!"
    2              0.000011   syn keyword rubyInclude   autoload extend load prepend refine require require_relative using
    2              0.000007   syn keyword rubyKeyword   callcc caller lambda proc
    2              0.000015 endif
                            
                            " Comments and Documentation {{{1
    2              0.000024 syn match   rubySharpBang "\%^#!.*" display
    2              0.000011 syn keyword rubyTodo	  FIXME NOTE TODO OPTIMIZE HACK REVIEW XXX todo contained
    2              0.000027 syn match   rubyComment   "#.*" contains=rubySharpBang,rubySpaceError,rubyTodo,@Spell
    2   0.000022   0.000014 if !exists("ruby_no_comment_fold") && s:foldable('#')
    2              0.000029   syn region rubyMultilineComment start="^\s*#.*\n\%(^\s*#\)\@=" end="^\s*#.*\n\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
    2              0.000033   syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$" contains=rubySpaceError,rubyTodo,@Spell fold
    2              0.000002 else
                              syn region rubyDocumentation	  start="^=begin\s*$" end="^=end\s*$" contains=rubySpaceError,rubyTodo,@Spell
                            endif
                            
                            " Keyword Nobbling {{{1
                            " Note: this is a hack to prevent 'keywords' being highlighted as such when called as methods with an explicit receiver
    2              0.000025 syn match rubyKeywordAsMethod "\%(\%(\.\@1<!\.\)\|::\)\_s*\%([_[:lower:]][_[:alnum:]]*\|\<\%(BEGIN\|END\)\>\)" transparent contains=NONE
    2              0.000018 syn match rubyKeywordAsMethod "\(defined?\|exit!\)\@!\<[_[:lower:]][_[:alnum:]]*[?!]"			       transparent contains=NONE
                            
                            " More Symbols {{{1
    2              0.000018 syn match  rubySymbol		"\%([{(,]\_s*\)\zs\l\w*[!?]\=::\@!"he=e-1
    2              0.000022 syn match  rubySymbol		"[]})\"':]\@1<!\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],]\@="he=e-1
    2              0.000018 syn match  rubySymbol		"\%([{(,]\_s*\)\zs[[:space:],{]\l\w*[!?]\=::\@!"hs=s+1,he=e-1
    2              0.000019 syn match  rubySymbol		"[[:space:],{(]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],]\@="hs=s+1,he=e-1
                            
                            " __END__ Directive {{{1
    2   0.000018   0.000009 if s:foldable('__END__')
    2              0.000021   syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$" fold
    2              0.000002 else
                              syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$"
                            endif
                            
                            " Default Highlighting {{{1
    2              0.000011 hi def link rubyClass			rubyDefine
    2              0.000004 hi def link rubyModule			rubyDefine
    2              0.000004 hi def link rubyMethodExceptional	rubyDefine
    2              0.000007 hi def link rubyDefine			Define
    2              0.000009 hi def link rubyFunction		Function
    2              0.000007 hi def link rubyConditional		Conditional
    2              0.000005 hi def link rubyConditionalModifier	rubyConditional
    2              0.000003 hi def link rubyExceptional		rubyConditional
    2              0.000007 hi def link rubyRepeat			Repeat
    2              0.000003 hi def link rubyRepeatModifier		rubyRepeat
    2              0.000018 hi def link rubyOptionalDo		rubyRepeat
    2              0.000012 hi def link rubyControl			Statement
    2              0.000008 hi def link rubyInclude			Include
    2              0.000008 hi def link rubyInteger			Number
    2              0.000007 hi def link rubyASCIICode		Character
    2              0.000007 hi def link rubyFloat			Float
    2              0.000007 hi def link rubyBoolean			Boolean
    2              0.000008 hi def link rubyException		Exception
    2              0.000006 if !exists("ruby_no_identifiers")
    2              0.000013   hi def link rubyIdentifier		Identifier
    2              0.000002 else
                              hi def link rubyIdentifier		NONE
                            endif
    2              0.000008 hi def link rubyClassVariable		rubyIdentifier
    2              0.000008 hi def link rubyConstant		Type
    2              0.000008 hi def link rubyGlobalVariable		rubyIdentifier
    2              0.000007 hi def link rubyBlockParameter		rubyIdentifier
    2              0.000012 hi def link rubyInstanceVariable	rubyIdentifier
    2              0.000011 hi def link rubyPredefinedIdentifier	rubyIdentifier
    2              0.000007 hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
    2              0.000022 hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
    2              0.000012 hi def link rubySymbol			Constant
    2              0.000007 hi def link rubyKeyword			Keyword
    2              0.000007 hi def link rubyOperator		Operator
    2              0.000008 hi def link rubyBeginEnd		Statement
    2              0.000007 hi def link rubyAccess			Statement
    2              0.000007 hi def link rubyAttribute		Statement
    2              0.000017 hi def link rubyEval			Statement
    2              0.000009 hi def link rubyPseudoVariable		Constant
    2              0.000005 hi def link rubyCapitalizedMethod	rubyLocalVariableOrMethod
                            
    2              0.000007 hi def link rubyComment			Comment
    2              0.000022 hi def link rubyData			Comment
    2              0.000008 hi def link rubyDataDirective		Delimiter
    2              0.000007 hi def link rubyDocumentation		Comment
    2              0.000007 hi def link rubyTodo			Todo
                            
    2              0.000004 hi def link rubyQuoteEscape		rubyStringEscape
    2              0.000007 hi def link rubyStringEscape		Special
    2              0.000009 hi def link rubyInterpolationDelimiter	Delimiter
    2              0.000004 hi def link rubyNoInterpolation		rubyString
    2              0.000007 hi def link rubySharpBang		PreProc
    2              0.000008 hi def link rubyRegexpDelimiter		rubyStringDelimiter
    2              0.000007 hi def link rubySymbolDelimiter		rubySymbol
    2              0.000008 hi def link rubyStringDelimiter		Delimiter
    2              0.000005 hi def link rubyHeredoc			rubyString
    2              0.000007 hi def link rubyString			String
    2              0.000008 hi def link rubyRegexpEscape		rubyRegexpSpecial
    2              0.000007 hi def link rubyRegexpQuantifier	rubyRegexpSpecial
    2              0.000008 hi def link rubyRegexpAnchor		rubyRegexpSpecial
    2              0.000004 hi def link rubyRegexpDot		rubyRegexpCharClass
    2              0.000007 hi def link rubyRegexpCharClass		rubyRegexpSpecial
    2              0.000025 hi def link rubyRegexpSpecial		Special
    2              0.000007 hi def link rubyRegexpComment		Comment
    2              0.000008 hi def link rubyRegexp			rubyString
                            
    2              0.000008 hi def link rubyInvalidVariable		Error
    2              0.000009 hi def link rubyError			Error
    2              0.000004 hi def link rubySpaceError		rubyError
                            
                            " Postscript {{{1
    2              0.000007 let b:current_syntax = "ruby"
                            
    2              0.000017 let &cpo = s:cpo_sav
    2              0.000018 unlet! s:cpo_sav
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:

SCRIPT  /usr/local/Cellar/vim/8.1.0100/share/vim/vim81/syntax/python.vim
Sourced 2 times
Total time:   0.001836
 Self time:   0.001836

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2016 Oct 29
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            
                            " quit when a syntax file was already loaded.
    2              0.000011 if exists("b:current_syntax")
                              finish
                            endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    2              0.000010 let s:cpo_save = &cpo
    2              0.000012 set cpo&vim
                            
    2              0.000006 if exists("python_no_doctest_highlight")
                              let python_no_doctest_code_highlight = 1
                            endif
                            
    2              0.000006 if exists("python_highlight_all")
    2              0.000004   if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
    2              0.000006   if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
    2              0.000006   if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
    2              0.000004   if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
    2              0.000004   if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
    2              0.000005   let python_space_error_highlight = 1
    2              0.000014 endif
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/2/reference/lexical_analysis.html#keywords,
                            " https://docs.python.org/3/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " Keywords 'with' and 'as' are new in Python 2.6
                            " (use 'from __future__ import with_statement' in Python 2.5).
                            "
                            " Some compromises had to be made to support both Python 3 and 2.
                            " We include Python 3 features, but when a definition is duplicated,
                            " the last definition takes precedence.
                            "
                            " - 'False', 'None', and 'True' are keywords in Python 3 but they are
                            "   built-ins in 2 and will be highlighted as built-ins below.
                            " - 'exec' is a built-in in Python 3 and will be highlighted as
                            "   built-in below.
                            " - 'nonlocal' is a keyword in Python 3 and will be highlighted.
                            " - 'print' is a built-in in Python 3 and will be highlighted as
                            "   built-in below (use 'from __future__ import print_function' in 2)
                            " - async and await were added in Python 3.5 and are soft keywords.
                            "
    2              0.000014 syn keyword pythonStatement	False None True
    2              0.000010 syn keyword pythonStatement	as assert break continue del exec global
    2              0.000008 syn keyword pythonStatement	lambda nonlocal pass print return with yield
    2              0.000012 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    2              0.000009 syn keyword pythonConditional	elif else if
    2              0.000007 syn keyword pythonRepeat	for while
    2              0.000009 syn keyword pythonOperator	and in is not or
    2              0.000027 syn keyword pythonException	except finally raise try
    2              0.000009 syn keyword pythonInclude	from import
    2              0.000006 syn keyword pythonAsync		async await
                            
                            " Decorators (new in Python 2.4)
                            " A dot must be allowed because of @MyClass.myfunc decorators.
    2              0.000010 syn match   pythonDecorator	"@" display contained
    2              0.000016 syn match   pythonDecoratorName	"@\s*\h\%(\w\|\.\)*" display contains=pythonDecorator
                            
                            " Python 3.5 introduced the use of the same symbol for matrix multiplication:
                            " https://www.python.org/dev/peps/pep-0465/.  We now have to exclude the
                            " symbol from highlighting when used in that context.
                            " Single line multiplication.
    2              0.000035 syn match   pythonMatrixMultiply
                                  \ "\%(\w\|[])]\)\s*@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication continued on the next line after backslash.
    2              0.000040 syn match   pythonMatrixMultiply
                                  \ "[^\\]\\\s*\n\%(\s*\.\.\.\s\)\=\s\+@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication in a parenthesized expression over multiple lines with @ at
                            " the start of each continued line; very similar to decorators and complex.
    2              0.000035 syn match   pythonMatrixMultiply
                                  \ "^\s*\%(\%(>>>\|\.\.\.\)\s\+\)\=\zs\%(\h\|\%(\h\|[[(]\).\{-}\%(\w\|[])]\)\)\s*\n\%(\s*\.\.\.\s\)\=\s\+@\%(.\{-}\n\%(\s*\.\.\.\s\)\=\s\+@\)*"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            
    2              0.000012 syn match   pythonFunction	"\h\w*" display contained
                            
    2              0.000019 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    2              0.000021 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    2              0.000040 syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    2              0.000038 syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    2              0.000055 syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    2              0.000029 syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    2              0.000011 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    2              0.000007 syn match   pythonEscape	"\\\o\{1,3}" contained
    2              0.000007 syn match   pythonEscape	"\\x\x\{2}" contained
    2              0.000010 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    2              0.000022 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    2              0.000008 syn match   pythonEscape	"\\$"
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/2/reference/lexical_analysis.html#numeric-literals
                            " https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals
    2              0.000008 if !exists("python_no_number_highlight")
                              " numbers (including longs and complex)
    2              0.000017   syn match   pythonNumber	"\<0[oO]\=\o\+[Ll]\=\>"
    2              0.000008   syn match   pythonNumber	"\<0[xX]\x\+[Ll]\=\>"
    2              0.000006   syn match   pythonNumber	"\<0[bB][01]\+[Ll]\=\>"
    2              0.000009   syn match   pythonNumber	"\<\%([1-9]\d*\|0\)[Ll]\=\>"
    2              0.000011   syn match   pythonNumber	"\<\d\+[jJ]\>"
    2              0.000008   syn match   pythonNumber	"\<\d\+[eE][+-]\=\d\+[jJ]\=\>"
    2              0.000012   syn match   pythonNumber
                            	\ "\<\d\+\.\%([eE][+-]\=\d\+\)\=[jJ]\=\%(\W\|$\)\@="
    2              0.000011   syn match   pythonNumber
                            	\ "\%(^\|\W\)\zs\d*\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>"
    2              0.000001 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/2/library/constants.html
                            " https://docs.python.org/3/library/constants.html
                            " http://docs.python.org/2/library/functions.html
                            " http://docs.python.org/3/library/functions.html
                            " http://docs.python.org/2/library/functions.html#non-essential-built-in-functions
                            " http://docs.python.org/3/library/functions.html#non-essential-built-in-functions
                            " Python built-in functions are in alphabetical order.
    2              0.000006 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
    2              0.000012   syn keyword pythonBuiltin	False True None
    2              0.000006   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " built-in functions
    2              0.000009   syn keyword pythonBuiltin	abs all any bin bool bytearray callable chr
    2              0.000008   syn keyword pythonBuiltin	classmethod compile complex delattr dict dir
    2              0.000007   syn keyword pythonBuiltin	divmod enumerate eval filter float format
    2              0.000008   syn keyword pythonBuiltin	frozenset getattr globals hasattr hash
    2              0.000011   syn keyword pythonBuiltin	help hex id input int isinstance
    2              0.000007   syn keyword pythonBuiltin	issubclass iter len list locals map max
    2              0.000008   syn keyword pythonBuiltin	memoryview min next object oct open ord pow
    2              0.000007   syn keyword pythonBuiltin	print property range repr reversed round set
    2              0.000007   syn keyword pythonBuiltin	setattr slice sorted staticmethod str
    2              0.000011   syn keyword pythonBuiltin	sum super tuple type vars zip __import__
                              " Python 2 only
    2              0.000007   syn keyword pythonBuiltin	basestring cmp execfile file
    2              0.000005   syn keyword pythonBuiltin	long raw_input reduce reload unichr
    2              0.000004   syn keyword pythonBuiltin	unicode xrange
                              " Python 3 only
    2              0.000004   syn keyword pythonBuiltin	ascii bytes exec
                              " non-essential built-in functions; Python 2 only
    2              0.000006   syn keyword pythonBuiltin	apply buffer coerce intern
                              " avoid highlighting attributes as builtins
    2              0.000026   syn match   pythonAttribute	/\.\h\w*/hs=s+1
                            	\ contains=ALLBUT,pythonBuiltin,pythonFunction,pythonAsync
                            	\ transparent
    2              0.000002 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/2/library/exceptions.html
                            " http://docs.python.org/3/library/exceptions.html
    2              0.000007 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
    2              0.000009   syn keyword pythonExceptions	BaseException Exception
    2              0.000007   syn keyword pythonExceptions	ArithmeticError BufferError
    2              0.000004   syn keyword pythonExceptions	LookupError
                              " builtin base exceptions removed in Python 3
    2              0.000005   syn keyword pythonExceptions	EnvironmentError StandardError
                              " builtin exceptions (actually raised)
    2              0.000005   syn keyword pythonExceptions	AssertionError AttributeError
    2              0.000006   syn keyword pythonExceptions	EOFError FloatingPointError GeneratorExit
    2              0.000004   syn keyword pythonExceptions	ImportError IndentationError
    2              0.000009   syn keyword pythonExceptions	IndexError KeyError KeyboardInterrupt
    2              0.000007   syn keyword pythonExceptions	MemoryError NameError NotImplementedError
    2              0.000005   syn keyword pythonExceptions	OSError OverflowError ReferenceError
    2              0.000006   syn keyword pythonExceptions	RuntimeError StopIteration SyntaxError
    2              0.000006   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    2              0.000005   syn keyword pythonExceptions	UnboundLocalError UnicodeError
    2              0.000004   syn keyword pythonExceptions	UnicodeDecodeError UnicodeEncodeError
    2              0.000005   syn keyword pythonExceptions	UnicodeTranslateError ValueError
    2              0.000006   syn keyword pythonExceptions	ZeroDivisionError
                              " builtin OS exceptions in Python 3
    2              0.000017   syn keyword pythonExceptions	BlockingIOError BrokenPipeError
    2              0.000006   syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
    2              0.000005   syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
    2              0.000004   syn keyword pythonExceptions	ConnectionResetError FileExistsError
    2              0.000006   syn keyword pythonExceptions	FileNotFoundError InterruptedError
    2              0.000005   syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
    2              0.000004   syn keyword pythonExceptions	PermissionError ProcessLookupError
    2              0.000006   syn keyword pythonExceptions	RecursionError StopAsyncIteration
    2              0.000004   syn keyword pythonExceptions	TimeoutError
                              " builtin exceptions deprecated/removed in Python 3
    2              0.000005   syn keyword pythonExceptions	IOError VMSError WindowsError
                              " builtin warnings
    2              0.000021   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    2              0.000006   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    2              0.000005   syn keyword pythonExceptions	RuntimeWarning SyntaxWarning UnicodeWarning
    2              0.000004   syn keyword pythonExceptions	UserWarning Warning
                              " builtin warnings in Python 3
    2              0.000005   syn keyword pythonExceptions	ResourceWarning
    2              0.000002 endif
                            
    2              0.000006 if exists("python_space_error_highlight")
                              " trailing whitespace
    2              0.000010   syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
    2              0.000007   syn match   pythonSpaceError	display " \+\t"
    2              0.000006   syn match   pythonSpaceError	display "\t\+ "
    2              0.000002 endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    2              0.000004 if !exists("python_no_doctest_highlight")
    2              0.000019   if !exists("python_no_doctest_code_highlight")
    2              0.000028     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,pythonFunction,@Spell
    2              0.000019     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
    2              0.000002   else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
                              endif
    2              0.000016 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    2              0.000019 syn sync match pythonSync grouphere NONE "^\%(def\|class\)\s\+\h\w*\s*[(:]"
                            
                            " The default highlight links.  Can be overridden later.
    2              0.000010 hi def link pythonStatement		Statement
    2              0.000008 hi def link pythonConditional		Conditional
    2              0.000008 hi def link pythonRepeat		Repeat
    2              0.000007 hi def link pythonOperator		Operator
    2              0.000007 hi def link pythonException		Exception
    2              0.000008 hi def link pythonInclude		Include
    2              0.000007 hi def link pythonAsync			Statement
    2              0.000008 hi def link pythonDecorator		Define
    2              0.000007 hi def link pythonDecoratorName		Function
    2              0.000007 hi def link pythonFunction		Function
    2              0.000007 hi def link pythonComment		Comment
    2              0.000008 hi def link pythonTodo			Todo
    2              0.000007 hi def link pythonString		String
    2              0.000007 hi def link pythonRawString		String
    2              0.000021 hi def link pythonQuotes		String
    2              0.000004 hi def link pythonTripleQuotes		pythonQuotes
    2              0.000008 hi def link pythonEscape		Special
    2              0.000007 if !exists("python_no_number_highlight")
    2              0.000008   hi def link pythonNumber		Number
    2              0.000002 endif
    2              0.000004 if !exists("python_no_builtin_highlight")
    2              0.000008   hi def link pythonBuiltin		Function
    2              0.000002 endif
    2              0.000005 if !exists("python_no_exception_highlight")
    2              0.000008   hi def link pythonExceptions		Structure
    2              0.000001 endif
    2              0.000019 if exists("python_space_error_highlight")
    2              0.000009   hi def link pythonSpaceError		Error
    2              0.000001 endif
    2              0.000004 if !exists("python_no_doctest_highlight")
    2              0.000007   hi def link pythonDoctest		Special
    2              0.000007   hi def link pythonDoctestValue	Define
    2              0.000002 endif
                            
    2              0.000008 let b:current_syntax = "python"
                            
    2              0.000015 let &cpo = s:cpo_save
    2              0.000002 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /Users/jinwook/.vim/plugged/ultisnips/autoload/UltiSnips.vim
Sourced 1 time
Total time:   0.015183
 Self time:   0.015183

count  total (s)   self (s)
    1              0.000008 if exists("b:did_autoload_ultisnips") || !exists("g:_uspy")
                                finish
                            endif
    1              0.000003 let b:did_autoload_ultisnips = 1
                            
                            " Also import vim as we expect it to be imported in many places.
    1              0.000028 exec g:_uspy "import vim"
    1              0.014946 exec g:_uspy "from UltiSnips import UltiSnips_Manager"
                            
    1              0.000005 function! s:compensate_for_pum()
                                """ The CursorMovedI event is not triggered while the popup-menu is visible,
                                """ and it's by this event that UltiSnips updates its vim-state. The fix is
                                """ to explicitly check for the presence of the popup menu, and update
                                """ the vim-state accordingly.
                                if pumvisible()
                                    exec g:_uspy "UltiSnips_Manager._cursor_moved()"
                                endif
                            endfunction
                            
    1              0.000002 function! UltiSnips#Edit(bang, ...)
                                if a:0 == 1 && a:1 != ''
                                    let type = a:1
                                else
                                    let type = ""
                                endif
                                exec g:_uspy "vim.command(\"let file = '%s'\" % UltiSnips_Manager._file_to_edit(vim.eval(\"type\"), vim.eval('a:bang')))"
                            
                                if !len(file)
                                   return
                                endif
                            
                                let mode = 'e'
                                if exists('g:UltiSnipsEditSplit')
                                    if g:UltiSnipsEditSplit == 'vertical'
                                        let mode = 'vs'
                                    elseif g:UltiSnipsEditSplit == 'horizontal'
                                        let mode = 'sp'
                                    elseif g:UltiSnipsEditSplit == 'tabdo'
                                        let mode = 'tabedit'
                                    elseif g:UltiSnipsEditSplit == 'context'
                                        let mode = 'vs'
                                        if winwidth(0) <= 2 * (&tw ? &tw : 80)
                                            let mode = 'sp'
                                        endif
                                    endif
                                endif
                                exe ':'.mode.' '.escape(file, ' ')
                            endfunction
                            
    1              0.000002 function! UltiSnips#AddFiletypes(filetypes)
                                exec g:_uspy "UltiSnips_Manager.add_buffer_filetypes('" . a:filetypes . "')"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#FileTypeComplete(arglead, cmdline, cursorpos)
                                let ret = {}
                                let items = map(
                                \   split(globpath(&runtimepath, 'syntax/*.vim'), '\n'),
                                \   'fnamemodify(v:val, ":t:r")'
                                \ )
                                call insert(items, 'all')
                                for item in items
                                    if !has_key(ret, item) && item =~ '^'.a:arglead
                                        let ret[item] = 1
                                    endif
                                endfor
                            
                                return sort(keys(ret))
                            endfunction
                            
    1              0.000001 function! UltiSnips#ExpandSnippet()
                                exec g:_uspy "UltiSnips_Manager.expand()"
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#ExpandSnippetOrJump()
                                call s:compensate_for_pum()
                                exec g:_uspy "UltiSnips_Manager.expand_or_jump()"
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#ListSnippets()
                                exec g:_uspy "UltiSnips_Manager.list_snippets()"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#SnippetsInCurrentScope(...)
                                let g:current_ulti_dict = {}
                                let all = get(a:, 1, 0)
                                if all
                                  let g:current_ulti_dict_info = {}
                                endif
                                exec g:_uspy "UltiSnips_Manager.snippets_in_current_scope(" . all . ")"
                                return g:current_ulti_dict
                            endfunction
                            
    1              0.000002 function! UltiSnips#SaveLastVisualSelection() range
                                exec g:_uspy "UltiSnips_Manager._save_last_visual_selection()"
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#JumpBackwards()
                                call s:compensate_for_pum()
                                exec g:_uspy "UltiSnips_Manager.jump_backwards()"
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#JumpForwards()
                                call s:compensate_for_pum()
                                exec g:_uspy "UltiSnips_Manager.jump_forwards()"
                                return ""
                            endfunction
                            
    1              0.000003 function! UltiSnips#AddSnippetWithPriority(trigger, value, description, options, filetype, priority)
                                exec g:_uspy "trigger = vim.eval(\"a:trigger\")"
                                exec g:_uspy "value = vim.eval(\"a:value\")"
                                exec g:_uspy "description = vim.eval(\"a:description\")"
                                exec g:_uspy "options = vim.eval(\"a:options\")"
                                exec g:_uspy "filetype = vim.eval(\"a:filetype\")"
                                exec g:_uspy "priority = vim.eval(\"a:priority\")"
                                exec g:_uspy "UltiSnips_Manager.add_snippet(trigger, value, description, options, filetype, priority)"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#Anon(value, ...)
                                " Takes the same arguments as SnippetManager.expand_anon:
                                " (value, trigger="", description="", options="")
                                exec g:_uspy "args = vim.eval(\"a:000\")"
                                exec g:_uspy "value = vim.eval(\"a:value\")"
                                exec g:_uspy "UltiSnips_Manager.expand_anon(value, *args)"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#CursorMoved()
                                exec g:_uspy "UltiSnips_Manager._cursor_moved()"
                            endf
                            
    1              0.000001 function! UltiSnips#LeavingBuffer()
                                exec g:_uspy "UltiSnips_Manager._leaving_buffer()"
                            endf
                            
    1              0.000001 function! UltiSnips#LeavingInsertMode()
                                exec g:_uspy "UltiSnips_Manager._leaving_insert_mode()"
                            endfunction
                            
    1              0.000001 function! UltiSnips#TrackChange()
                                exec g:_uspy "UltiSnips_Manager._track_change()"
                            endfunction
                            
    1              0.000001 function! UltiSnips#RefreshSnippets()
                                exec g:_uspy "UltiSnips_Manager._refresh_snippets()"
                            endfunction
                            " }}}

SCRIPT  /Users/jinwook/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    1              0.000024 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7-4-1826') && !has('gui_running')) ||
                                  \     (has('patch-7-4-1850') &&  has('gui_running')) ||
                                  \     (has('patch-7-4-1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )
                            
    1              0.000003 function! gitgutter#async#available()
                              return s:available
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#async#execute(cmd, bufnr, handler) abort
                              call gitgutter#debug#log('[async] '.a:cmd)
                            
                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': a:bufnr,
                                    \   'handler': a:handler
                                    \ }
                              let command = s:build_command(a:cmd)
                            
                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                call job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                              endif
                            endfunction
                            
                            
    1              0.000003 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'
                            endfunction
                            
                            
    1              0.000002 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction
                            
    1              0.000003 function! s:on_stderr_nvim(_job_id, _data, _event) dict abort
                              call self.handler.err(self.buffer)
                            endfunction
                            
    1              0.000001 function! s:on_exit_nvim(_job_id, exit_code, _event) dict abort
                              if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction
                            
    1              0.000002 function! s:on_stderr_vim(channel, _data) dict abort
                              call self.handler.err(self.buffer)
                              try
                                call ch_close(a:channel)  " so close_cb and its 'out' handler are not triggered
                              catch /E906/
                                " noop
                              endtry
                            endfunction
                            
    1              0.000002 function! s:on_exit_vim(_channel) dict abort
                              call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                            endfunction

SCRIPT  /Users/jinwook/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
    1              0.000013 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000003 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000002 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000002 let s:new_log_session = 1
                            
                            
    1              0.000002 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile
                            
                              call s:vim_version()
                              call s:separator()
                            
                              call s:git_version()
                              call s:separator()
                            
                              call s:grep_version()
                              call s:separator()
                            
                              call s:option('updatetime')
                              call s:option('shell')
                              call s:option('shellcmdflag')
                              call s:option('shellpipe')
                              call s:option('shellquote')
                              call s:option('shellredir')
                              call s:option('shellslash')
                              call s:option('shelltemp')
                              call s:option('shelltype')
                              call s:option('shellxescape')
                              call s:option('shellxquote')
                            endfunction
                            
                            
    1              0.000002 function! s:separator()
                              call s:output('')
                            endfunction
                            
    1              0.000001 function! s:vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call s:output(split(version_info, '\n')[0:2])
                            endfunction
                            
    1              0.000001 function! s:git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            endfunction
                            
    1              0.000002 function! s:grep_version()
                              let v = system('grep --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            
                              let v = system('grep --help')
                              call s:output( substitute(v, '\%x00', '', 'g') )
                            endfunction
                            
    1              0.000002 function! s:option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call s:output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call s:output(a:name . '=' . output)
                              else
                                call s:output(a:name . ' [n/a]')
                              end
                            endfunction
                            
    1              0.000001 function! s:output(text)
                              call append(line('$'), a:text)
                            endfunction
                            
                            " assumes optional args are calling function's optional args
    1              0.000001 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif
                            endfunction
                            
    1              0.000002 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction
                            

SCRIPT  /Users/jinwook/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim
Sourced 1 time
Total time:   0.018518
 Self time:   0.000676

count  total (s)   self (s)
    1              0.000007 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000002 let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'
                            
                            " True for git v1.7.2+.
    1              0.000004 function! s:git_supports_command_line_config_override() abort
                              call system(g:gitgutter_git_executable.' -c foo.bar=baz --version')
                              return !v:shell_error
                            endfunction
                            
    1   0.017918   0.000076 let s:c_flag = s:git_supports_command_line_config_override()
                            
                            
    1              0.000015 let s:temp_index = tempname()
    1              0.000006 let s:temp_buffer = tempname()
                            
                            " Returns a diff of the buffer.
                            "
                            " The buffer contents is not the same as the file on disk so we need to pass
                            " two instances of the file to git-diff:
                            "
                            "     git diff myfileA myfileB
                            "
                            " where myfileA comes from
                            "
                            "     git show :myfile > myfileA
                            "
                            " and myfileB is the buffer contents.
                            "
                            " After running the diff we pass it through grep where available to reduce
                            " subsequent processing by the plugin.  If grep is not available the plugin
                            " does the filtering instead.
                            "
                            "
                            " Regarding line endings:
                            "
                            " git-show does not convert line endings.
                            " git-diff FILE FILE does convert line endings for the given files.
                            "
                            " If a file has CRLF line endings and git's core.autocrlf is true,
                            " the file in git's object store will have LF line endings.  Writing
                            " it out via git-show will produce a file with LF line endings.
                            "
                            " If this last file is one of the files passed to git-diff, git-diff will
                            " convert its line endings to CRLF before diffing -- which is what we want --
                            " but also by default output a warning on stderr.
                            "
                            "   warning: LF will be replace by CRLF in <temp file>.
                            "   The file will have its original line endings in your working directory.
                            "
                            " When running the diff asynchronously, the warning message triggers the stderr
                            " callbacks which assume the overall command has failed and reset all the
                            " signs.  As this is not what we want, and we can safely ignore the warning,
                            " we turn it off by passing the '-c "core.safecrlf=false"' argument to
                            " git-diff.
                            "
                            " When writing the temporary files we preserve the original file's extension
                            " so that repos using .gitattributes to control EOL conversion continue to
                            " convert correctly.
    1              0.000005 function! gitgutter#diff#run_diff(bufnr, preserve_full_diff) abort
                              while gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                sleep 5m
                              endwhile
                            
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
                              let cmd = '('
                            
                              " Append buffer number to avoid race conditions between writing and reading
                              " the files when asynchronously processing multiple buffers.
                              "
                              " Without the buffer number, index_file would have a race in the shell
                              " between the second process writing it (with git-show) and the first
                              " reading it (with git-diff).
                              let index_file = s:temp_index.'.'.a:bufnr
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
                              let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              let extension = gitgutter#utility#extension(a:bufnr)
                              if !empty(extension)
                                let index_file .= '.'.extension
                                let buff_file .= '.'.extension
                              endif
                            
                              " Write file from index to temporary file.
                              let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
                              let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.index_file.' && '
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
                              call s:write_buffer(a:bufnr, buff_file)
                            
                              " Call git-diff with the temporary files.
                              let cmd .= g:gitgutter_git_executable.' --no-pager'
                              if s:c_flag
                                let cmd .= ' -c "diff.autorefreshindex=0"'
                                let cmd .= ' -c "diff.noprefix=false"'
                                let cmd .= ' -c "core.safecrlf=false"'
                              endif
                              let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.index_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
                              if !a:preserve_full_diff && !empty(g:gitgutter_grep)
                                let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
                              endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
                              let cmd .= ' || exit 0'
                            
                              let cmd .= ')'
                            
                              let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
                              if g:gitgutter_async && gitgutter#async#available()
                                call gitgutter#async#execute(cmd, a:bufnr, {
                                      \   'out': function('gitgutter#diff#handler'),
                                      \   'err': function('gitgutter#hunk#reset'),
                                      \ })
                                return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif
                            endfunction
                            
                            
    1              0.000003 function! gitgutter#diff#handler(bufnr, diff) abort
                              call gitgutter#debug#log(a:diff)
                            
                              call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
                              let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
                              let signs_count = len(modified_lines)
                              if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf(
                                      \ 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).',
                                      \ signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
                                if g:gitgutter_signs || g:gitgutter_highlight_lines
                                  call gitgutter#sign#update_signs(a:bufnr, modified_lines)
                                endif
                              endif
                            
                              call s:save_last_seen_change(a:bufnr)
                              if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif
                            endfunction
                            
                            
    1              0.000004 function! gitgutter#diff#parse_diff(diff) abort
                              let hunks = []
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
                              return hunks
                            endfunction
                            
    1              0.000004 function! gitgutter#diff#parse_hunk(line) abort
                              let matches = matchlist(a:line, s:hunk_re)
                              if len(matches) > 0
                                let from_line  = str2nr(matches[1])
                                let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
                                let to_line    = str2nr(matches[3])
                                let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
                                return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end
                            endfunction
                            
                            " This function is public so it may be used by other plugins
                            " e.g. vim-signature.
    1              0.000002 function! gitgutter#diff#process_hunks(bufnr, hunks) abort
                              let modified_lines = []
                              for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
                              endfor
                              return modified_lines
                            endfunction
                            
                            " Returns [ [<line_number (number)>, <name (string)>], ...]
    1              0.000003 function! s:process_hunk(bufnr, hunk) abort
                              let modifications = []
                              let from_line  = a:hunk[0]
                              let from_count = a:hunk[1]
                              let to_line    = a:hunk[2]
                              let to_count   = a:hunk[3]
                            
                              if s:is_added(from_count, to_count)
                                call s:process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
                              elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
                              endif
                              return modifications
                            endfunction
                            
    1              0.000003 function! s:is_added(from_count, to_count) abort
                              return a:from_count == 0 && a:to_count > 0
                            endfunction
                            
    1              0.000002 function! s:is_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count == 0
                            endfunction
                            
    1              0.000002 function! s:is_modified(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count
                            endfunction
                            
    1              0.000003 function! s:is_modified_and_added(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count
                            endfunction
                            
    1              0.000003 function! s:is_modified_and_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count
                            endfunction
                            
    1              0.000003 function! s:process_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:process_removed(modifications, from_count, to_count, to_line) abort
                              if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif
                            endfunction
                            
    1              0.000003 function! s:process_modified(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000004 function! s:process_modified_and_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:from_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000004 function! s:process_modified_and_removed(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']
                            endfunction
                            
                            
                            " Returns a diff for the current hunk.
    1              0.000003 function! gitgutter#diff#hunk_diff(bufnr, full_diff)
                              let modified_diff = []
                              let keep_line = 1
                              " Don't keepempty when splitting because the diff we want may not be the
                              " final one.  Instead add trailing NL at end of function.
                              for line in split(a:full_diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4  " start of new hunk
                                  let keep_line = gitgutter#hunk#cursor_in_hunk(hunk_info)
                                endif
                                if keep_line
                                  call add(modified_diff, line)
                                endif
                              endfor
                              return join(modified_diff, "\n")."\n"
                            endfunction
                            
                            
    1              0.000002 function! s:write_buffer(bufnr, file)
                              let bufcontents = getbufline(a:bufnr, 1, '$')
                            
                              if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
                              let fenc = getbufvar(a:bufnr, '&fileencoding')
                              if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
                              if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='ï»¿'.bufcontents[0]
                              endif
                            
                              call writefile(bufcontents, a:file)
                            endfunction
                            
                            
    1              0.000002 function! s:save_last_seen_change(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))
                            endfunction
                            
                            

SCRIPT  /Users/jinwook/.vim/view/~=+.vimrc=
Sourced 1 time
Total time:   0.001140
 Self time:   0.001140

count  total (s)   self (s)
    1              0.000028 let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0
    1              0.000002 argglobal
    1              0.000006 let s:cpo_save=&cpo
    1              0.000012 set cpo&vim
    1              0.000023 nmap <buffer> ,hp <Plug>GitGutterPreviewHunk
    1              0.000010 nmap <buffer> ,hu <Plug>GitGutterUndoHunk
    1              0.000008 nmap <buffer> ,hs <Plug>GitGutterStageHunk
    1              0.000008 nmap <buffer> [c <Plug>GitGutterPrevHunk
    1              0.000015 vnoremap <buffer> <silent> [" :exe "normal! gv"|call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")
    1              0.000011 nnoremap <buffer> <silent> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")
    1              0.000013 vnoremap <buffer> <silent> [] m':exe "normal! gv"|call search('^\s*endf*\%[unction]\>', "bW")
    1              0.000011 nnoremap <buffer> <silent> [] m':call search('^\s*endf*\%[unction]\>', "bW")
    1              0.000014 vnoremap <buffer> <silent> [[ m':exe "normal! gv"|call search('^\s*fu\%[nction]\>', "bW")
    1              0.000013 nnoremap <buffer> <silent> [[ m':call search('^\s*fu\%[nction]\>', "bW")
    1              0.000009 nmap <buffer> ]c <Plug>GitGutterNextHunk
    1              0.000013 vnoremap <buffer> <silent> ]" :exe "normal! gv"|call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")
    1              0.000010 nnoremap <buffer> <silent> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")
    1              0.000012 vnoremap <buffer> <silent> ][ m':exe "normal! gv"|call search('^\s*endf*\%[unction]\>', "W")
    1              0.000010 nnoremap <buffer> <silent> ][ m':call search('^\s*endf*\%[unction]\>', "W")
    1              0.000011 vnoremap <buffer> <silent> ]] m':exe "normal! gv"|call search('^\s*fu\%[nction]\>', "W")
    1              0.000009 nnoremap <buffer> <silent> ]] m':call search('^\s*fu\%[nction]\>', "W")
    1              0.000010 xmap <buffer> ac <Plug>GitGutterTextObjectOuterVisual
    1              0.000010 omap <buffer> ac <Plug>GitGutterTextObjectOuterPending
    1              0.000009 xmap <buffer> ic <Plug>GitGutterTextObjectInnerVisual
    1              0.000009 omap <buffer> ic <Plug>GitGutterTextObjectInnerPending
    1              0.000008 let &cpo=s:cpo_save
    1              0.000002 unlet s:cpo_save
    1              0.000009 setlocal keymap=
    1              0.000024 setlocal noarabic
    1              0.000003 setlocal autoindent
    1              0.000003 setlocal backupcopy=
    1              0.000003 setlocal balloonexpr=
    1              0.000002 setlocal nobinary
    1              0.000002 setlocal nobreakindent
    1              0.000003 setlocal breakindentopt=
    1              0.000003 setlocal bufhidden=
    1              0.000002 setlocal buflisted
    1              0.000002 setlocal buftype=
    1              0.000002 setlocal cindent
    1              0.000010 setlocal cinkeys=0{,0},0),:,0#,!^F,o,O,e
    1              0.000007 setlocal cinoptions=
    1              0.000005 setlocal cinwords=if,else,while,do,for,switch
    1              0.000007 setlocal colorcolumn=
    1              0.000005 setlocal comments=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
    1              0.000003 setlocal commentstring=\"%s
    1              0.000006 setlocal complete=.,w,b,u,t,i
    1              0.000005 setlocal concealcursor=
    1              0.000003 setlocal conceallevel=2
    1              0.000003 setlocal completefunc=youcompleteme#CompleteFunc
    1              0.000002 setlocal nocopyindent
    1              0.000004 setlocal cryptmethod=
    1              0.000002 setlocal nocursorbind
    1              0.000003 setlocal nocursorcolumn
    1              0.000002 setlocal cursorline
    1              0.000002 setlocal define=
    1              0.000006 setlocal dictionary=
    1              0.000003 setlocal nodiff
    1              0.000002 setlocal equalprg=
    1              0.000005 setlocal errorformat=
    1              0.000002 setlocal expandtab
    1              0.000020 if &filetype != 'vim'
                            setlocal filetype=vim
                            endif
    1              0.000003 setlocal fixendofline
    1              0.000002 setlocal foldcolumn=0
    1              0.000002 setlocal foldenable
    1              0.000003 setlocal foldexpr=0
    1              0.000003 setlocal foldignore=#
    1              0.000003 setlocal foldlevel=0
    1              0.000003 setlocal foldmarker={{{,}}}
    1              0.000003 setlocal foldmethod=manual
    1              0.000002 setlocal foldminlines=1
    1              0.000003 setlocal foldnestmax=20
    1              0.000002 setlocal foldtext=foldtext()
    1              0.000006 setlocal formatexpr=
    1              0.000004 setlocal formatoptions=croql
    1              0.000006 setlocal formatlistpat=^\\s*\\d\\+[\\]:.)}\\t\ ]\\s*
    1              0.000003 setlocal formatprg=
    1              0.000003 setlocal grepprg=
    1              0.000003 setlocal iminsert=0
    1              0.000002 setlocal imsearch=-1
    1              0.000003 setlocal include=
    1              0.000005 setlocal includeexpr=
    1              0.000003 setlocal indentexpr=GetVimIndent()
    1              0.000004 setlocal indentkeys=0{,0},:,0#,!^F,o,O,e,=end,=else,=cat,=fina,=END,0\\
    1              0.000003 setlocal noinfercase
    1              0.000030 setlocal iskeyword=@,48-57,_,192-255,#
    1              0.000003 setlocal keywordprg=:help
    1              0.000002 setlocal nolinebreak
    1              0.000008 setlocal nolisp
    1              0.000005 setlocal lispwords=
    1              0.000002 setlocal nolist
    1              0.000022 setlocal makeencoding=
    1              0.000002 setlocal makeprg=
    1              0.000003 setlocal matchpairs=(:),{:},[:]
    1              0.000005 setlocal modeline
    1              0.000006 setlocal modifiable
    1              0.000006 setlocal nrformats=bin,octal,hex
    1              0.000003 setlocal number
    1              0.000002 setlocal numberwidth=4
    1              0.000003 setlocal omnifunc=
    1              0.000003 setlocal path=
    1              0.000002 setlocal nopreserveindent
    1              0.000002 setlocal nopreviewwindow
    1              0.000003 setlocal quoteescape=\\
    1              0.000002 setlocal noreadonly
    1              0.000002 setlocal norelativenumber
    1              0.000002 setlocal norightleft
    1              0.000003 setlocal rightleftcmd=search
    1              0.000002 setlocal noscrollbind
    1              0.000003 setlocal shiftwidth=4
    1              0.000002 setlocal noshortname
    1              0.000003 setlocal signcolumn=auto
    1              0.000003 setlocal smartindent
    1              0.000002 setlocal softtabstop=4
    1              0.000002 setlocal nospell
    1              0.000020 setlocal spellcapcheck=[.?!]\\_[\\])'\"\	\ ]\\+
    1              0.000003 setlocal spellfile=
    1              0.000238 setlocal spelllang=en
    1              0.000005 setlocal statusline=%!airline#statusline(1)
    1              0.000003 setlocal suffixesadd=
    1              0.000004 setlocal noswapfile
    1              0.000003 setlocal synmaxcol=3000
    1              0.000003 if &syntax != 'vim'
                            setlocal syntax=vim
                            endif
    1              0.000003 setlocal tabstop=4
    1              0.000005 setlocal tagcase=
    1              0.000004 setlocal tags=
    1              0.000002 setlocal termwinkey=
    1              0.000003 setlocal termwinscroll=10000
    1              0.000003 setlocal termwinsize=
    1              0.000002 setlocal textwidth=78
    1              0.000003 setlocal thesaurus=
    1              0.000003 setlocal noundofile
    1              0.000002 setlocal undolevels=-123456
    1              0.000004 setlocal nowinfixheight
    1              0.000002 setlocal nowinfixwidth
    1              0.000002 setlocal wrap
    1              0.000003 setlocal wrapmargin=0
    1              0.000034 silent! normal! zE
    1              0.000007 let s:l = 2 - ((1 * winheight(0) + 27) / 55)
    1              0.000004 if s:l < 1 | let s:l = 1 | endif
    1              0.000003 exe s:l
    1              0.000005 normal! zt
    1              0.000001 2
    1              0.000004 normal! 010|
    1              0.000010 let &so = s:so_save | let &siso = s:siso_save
    1              0.000024 doautoall SessionLoadPost
                            " vim: set ft=vim :

SCRIPT  /Users/jinwook/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim
Sourced 1 time
Total time:   0.000291
 Self time:   0.000291

count  total (s)   self (s)
                            " Vim doesn't namespace sign ids so every plugin shares the same
                            " namespace.  Sign ids are simply integers so to avoid clashes with other
                            " signs we guess at a clear run.
                            "
                            " Note also we currently never reset s:next_sign_id.
    1              0.000004 let s:first_sign_id = 3000
    1              0.000002 let s:next_sign_id  = s:first_sign_id
    1              0.000003 let s:dummy_sign_id = s:first_sign_id - 1
                            " Remove-all-signs optimisation requires Vim 7.3.596+.
    1              0.000004 let s:supports_star = v:version > 703 || (v:version == 703 && has("patch596"))
                            
                            
    1              0.000002 function! gitgutter#sign#enable() abort
                              let old_signs = g:gitgutter_signs
                            
                              let g:gitgutter_signs = 1
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !old_signs && !g:gitgutter_highlight_lines
                                call gitgutter#all(1)
                              endif
                            endfunction
                            
    1              0.000002 function! gitgutter#sign#disable() abort
                              let g:gitgutter_signs = 0
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !g:gitgutter_highlight_lines
                                call gitgutter#sign#clear_signs(bufnr(''))
                                call gitgutter#sign#remove_dummy_sign(bufnr(''), 0)
                              endif
                            endfunction
                            
    1              0.000001 function! gitgutter#sign#toggle() abort
                              if g:gitgutter_signs
                                call gitgutter#sign#disable()
                              else
                                call gitgutter#sign#enable()
                              endif
                            endfunction
                            
                            
                            " Removes gitgutter's signs (excluding dummy sign) from the buffer being processed.
    1              0.000002 function! gitgutter#sign#clear_signs(bufnr) abort
                              call s:find_current_signs(a:bufnr)
                            
                              let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
                              call s:remove_signs(a:bufnr, sign_ids, 1)
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})
                            endfunction
                            
                            
                            " Updates gitgutter's signs in the buffer being processed.
                            "
                            " modified_lines: list of [<line_number (number)>, <name (string)>]
                            " where name = 'added|removed|modified|modified_removed'
    1              0.000003 function! gitgutter#sign#update_signs(bufnr, modified_lines) abort
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
                              if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
                              if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif
                            endfunction
                            
                            
    1              0.000003 function! s:add_dummy_sign(bufnr) abort
                              if !gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
                                execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 1)
                              endif
                            endfunction
                            
    1              0.000003 function! gitgutter#sign#remove_dummy_sign(bufnr, force) abort
                              if gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
                                execute "sign unplace" s:dummy_sign_id "buffer=" . a:bufnr
                                call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 0)
                              endif
                            endfunction
                            
                            
                            "
                            " Internal functions
                            "
                            
                            
    1              0.000002 function! s:find_current_signs(bufnr) abort
                              let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
                              let other_signs = []      " [<line_number (number),...]
                              let dummy_sign_placed = 0
                            
                              redir => signs
                                silent execute "sign place buffer=" . a:bufnr
                              redir END
                            
                              for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
                              endfor
                            
                              call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
                              call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)
                            endfunction
                            
                            
                            " Returns a list of [<id (number)>, ...]
                            " Sets `s:remove_all_old_signs` as a side-effect.
    1              0.000003 function! s:obsolete_gitgutter_signs_to_remove(bufnr, new_gitgutter_signs_line_numbers) abort
                              let signs_to_remove = []  " list of [<id (number)>, ...]
                              let remove_all_signs = 1
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                              for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
                              let s:remove_all_old_signs = remove_all_signs
                              return signs_to_remove
                            endfunction
                            
                            
    1              0.000003 function! s:remove_signs(bufnr, sign_ids, all_signs) abort
                              if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . a:bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
                              else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif
                            endfunction
                            
                            
    1              0.000003 function! s:upsert_new_gitgutter_signs(bufnr, modified_lines) abort
                              let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              for line in a:modified_lines
                                let line_number = line[0]  " <number>
                                if index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = s:highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.
                            endfunction
                            
                            
    1              0.000002 function! s:next_sign_id() abort
                              let next_id = s:next_sign_id
                              let s:next_sign_id += 1
                              return next_id
                            endfunction
                            
                            
                            " Only for testing.
    1              0.000002 function! gitgutter#sign#reset()
                              let s:next_sign_id  = s:first_sign_id
                            endfunction
                            
                            
    1              0.000002 function! s:highlight_name_for_change(text) abort
                              if a:text ==# 'added'
                                return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              endif
                            endfunction
                            
                            

SCRIPT  /Users/jinwook/.vim/plugged/syntastic/syntax_checkers/vim/vimlint.vim
Sourced 1 time
Total time:   0.000671
 Self time:   0.000379

count  total (s)   self (s)
                            "============================================================================
                            "File:        vimlint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000010 if exists('g:loaded_syntastic_vim_vimlint_checker')
                                finish
                            endif
    1              0.000011 let g:loaded_syntastic_vim_vimlint_checker = 1
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000016 set cpo&vim
                            
    1              0.000006 function! SyntaxCheckers_vim_vimlint_GetHighlightRegex(item) " {{{1
                                let term = matchstr(a:item['text'], '\m `\zs[^`]\+\ze`')
                                if term !=# ''
                                    let col = get(a:item, 'col', 0)
                            
                                    if col && term[0:1] ==# 'l:'
                                        if getline(a:item.lnum)[col-1:col] !=# 'l:'
                                            let term = term[2:]
                                        endif
                                    endif
                            
                                    return col ? '\%>' . (col - 1) . 'c\%<' . (col + strlen(term)) . 'c' : '\V' . escape(term, '\')
                                endif
                            
                                return ''
                            endfunction " }}}1
                            
    1              0.000005 function! SyntaxCheckers_vim_vimlint_IsAvailable() dict " {{{1
                                try
                                    " Vim 7.2-051 and later
                                    let vimlparser = globpath(&runtimepath, 'autoload/vimlparser.vim', 1)
                                    let vimlint    = globpath(&runtimepath, 'autoload/vimlint.vim', 1)
                                catch /\m^Vim\%((\a\+)\)\=:E118/
                                    let vimlparser = globpath(&runtimepath, 'autoload/vimlparser.vim')
                                    let vimlint    = globpath(&runtimepath, 'autoload/vimlint.vim')
                                endtry
                                call self.log("globpath(&runtimepath, 'autoload/vimlparser.vim', 1) = " . string(vimlparser) . ', ' .
                                            \ "globpath(&runtimepath, 'autoload/vimlint.vim', 1) = " .    string(vimlint))
                                return vimlparser !=# '' && vimlint !=# ''
                            endfunction " }}}1
                            
    1              0.000004 function! SyntaxCheckers_vim_vimlint_GetLocList() dict " {{{1
                                let buf = bufnr('')
                            
                                " EVL102: unused variable v
                                " EVL103: unused argument v
                                " EVL104: variable may not be initialized on some execution path: v
                                " EVL105: global variable v is defined without g:
                                " EVL106: local variable v is used without l:
                                " EVL201: unreachable code
                                " EVL204: constant in conditional context
                                " EVL205: missing scriptencoding
                                " value 3: the message is a warning
                                "
                                " References: :help vimlint-errorcode and :help vimlint-variables
                                let param = {
                                    \ 'output': function('s:vimlintOutput'),
                                    \ 'quiet':  1,
                                    \ 'EVL102': 3,
                                    \ 'EVL103': 3,
                                    \ 'EVL104': 3,
                                    \ 'EVL105': 3,
                                    \ 'EVL106': 3,
                                    \ 'EVL201': 3,
                                    \ 'EVL204': 3,
                                    \ 'EVL205': 3 }
                            
                                let opts = syntastic#util#bufVar(buf, 'vimlint_options')
                                if type(opts) == type({})
                                    let options = filter(copy(opts), 'v:key =~# "\\m^EVL"')
                                    call extend(param, options, 'force')
                                endif
                            
                                call self.log('options =', param)
                            
                                return vimlint#vimlint(bufname(buf), param)
                            endfunction " }}}1
                            
                            " Utilities {{{1
                            
                            " @vimlint(EVL103, 1, a:filename)
    1              0.000007 function! s:vimlintOutput(filename, pos, ev, eid, mes, obj) " {{{2
                                call add(a:obj.error, {
                                    \ 'bufnr': bufnr(''),
                                    \ 'lnum': a:pos.lnum,
                                    \ 'col': a:pos.col,
                                    \ 'vcol': 0,
                                    \ 'type': a:ev[0],
                                    \ 'text': '[' . a:eid . '] ' . a:mes,
                                    \ 'valid': a:pos.lnum > 0 })
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:filename)
                            
                            " }}}1
                            
    1   0.000310   0.000018 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'vim',
                                \ 'name': 'vimlint' })
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/jinwook/.vim/plugged/syntastic/syntax_checkers/vim/vint.vim
Sourced 1 time
Total time:   0.000331
 Self time:   0.000147

count  total (s)   self (s)
                            "============================================================================
                            "File:        vint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000007 if exists('g:loaded_syntastic_vim_vint_checker')
                                finish
                            endif
    1              0.000008 let g:loaded_syntastic_vim_vint_checker = 1
                            
    1              0.000004 if !exists('g:syntastic_vim_vint_sort')
    1              0.000005     let g:syntastic_vim_vint_sort = 1
    1              0.000001 endif
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000003 function! SyntaxCheckers_vim_vint_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'post_args': '--json' })
                            
                                let errorformat = '%f:%l:%c:%t: %m'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'preprocess': 'vint',
                                    \ 'returns': [0, 1] })
                            
                                for e in loclist
                                    if e['type'] ==? 's'
                                        let e['type'] = 'w'
                                        let e['subtype'] = 'Style'
                                    elseif e['type'] !=? 'e' && e['type'] !=? 'w'
                                        let e['type'] = 'e'
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000195   0.000011 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'vim',
                                \ 'name': 'vint'})
                            
    1              0.000008 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

FUNCTION  airline#extensions#tabline#group_of_bufnr()
Called 9 times
Total time:   0.000297
 Self time:   0.000297

count  total (s)   self (s)
    9              0.000084   let cur = bufnr('%')
    9              0.000013   if cur == a:bufnr
    6              0.000024     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod'
                                else
    6              0.000007       let group = 'airline_tabsel'
    6              0.000004     endif
    6              0.000002   else
    3              0.000013     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
                                elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
                                else
    3              0.000005       let group = 'airline_tabhid'
    3              0.000001     endif
    3              0.000003   endif
    9              0.000009   return group

FUNCTION  <SNR>111_tabline_evaluated_length()
Called 11 times
Total time:   0.002071
 Self time:   0.000207

count  total (s)   self (s)
   11   0.002068   0.000204   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  <SNR>104_section_is_empty()
Called 127 times
Total time:   0.174603
 Self time:   0.020998

count  total (s)   self (s)
  127              0.000143   let start=1
                            
                              " do not check for inactive windows or the tabline
  127              0.000155   if a:self._context.active == 0
                                return 0
                              elseif get(a:self._context, 'tabline', 0)
   19              0.000017     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
  108              0.000251   if get(g:, 'airline_skip_empty_sections', 0) == 0
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
  108              0.000219   if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
  108              0.007768   if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
   36              0.000037     return 0
                              endif
   72              0.000123   if empty(a:content)
   12              0.000011     return 1
                              endif
   60              0.003117   let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
   60              0.000123   if empty(list)
   12              0.000012     return 0 " no function in statusline text
                              endif
  100              0.000189   while len(list) > 0
   72              0.000149     let expr = list[0]
   72              0.000052     try
                                  " catch all exceptions, just in case
   72   0.154501   0.000896       if !empty(eval(expr))
   20              0.000018         return 0
                                  endif
   52              0.000041     catch
                                  return 0
                                endtry
   52              0.000093     let start += 1
   52              0.005460     let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
   52              0.000107   endw
   28              0.000022   return 1

FUNCTION  <SNR>80_LeadingSpaceDisable()
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000003     if g:indentLine_newVersion
    2              0.000008         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
                                    endif
                            
    2              0.000001         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  <SNR>105_build_sections()
Called 24 times
Total time:   0.007494
 Self time:   0.001254

count  total (s)   self (s)
  120              0.000127   for key in a:keys
   96              0.000243     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
   96   0.006719   0.000479     call s:add_section(a:builder, a:context, key)
   96              0.000088   endfor

FUNCTION  <SNR>101_get_syn()
Called 660 times
Total time:   0.021816
 Self time:   0.021816

count  total (s)   self (s)
  660              0.001876   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
  660              0.000765   let color = ''
  660              0.003119   if hlexists(a:group)
  618              0.004748     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  618              0.000438   endif
  660              0.001586   if empty(color) || color == -1
                                " should always exists
   42              0.000398     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   42              0.000114     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
   42              0.000028   endif
  660              0.000662   return color

FUNCTION  airline#util#exec_funcrefs()
Called 17 times
Total time:   0.024682
 Self time:   0.001457

count  total (s)   self (s)
  106              0.000127     for Fn in a:list
  101   0.024131   0.000906       let code = call(Fn, a:000)
  101              0.000103       if code != 0
   12              0.000011         return code
                                  endif
   89              0.000097     endfor
    5              0.000003     return 0

FUNCTION  <SNR>124_build_command()
Called 5 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    5              0.000013   if has('unix')
    5              0.000012     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  <SNR>108_has_fresh_changes()
Called 9 times
Total time:   0.000289
 Self time:   0.000102

count  total (s)   self (s)
    9   0.000288   0.000101   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>46_dir()
Called 16 times
Total time:   0.002369
 Self time:   0.000311

count  total (s)   self (s)
   16   0.002360   0.000302   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  gitgutter#process_buffer()
Called 11 times
Total time:   0.053850
 Self time:   0.001477

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   11   0.004704   0.000186   if gitgutter#utility#is_active(a:bufnr)
    9   0.000412   0.000123     if a:force || s:has_fresh_changes(a:bufnr)
                            
    3              0.000004       let diff = ''
    3              0.000004       try
    3   0.048207   0.000641         let diff = gitgutter#diff#run_diff(a:bufnr, 0)
    3              0.000026       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    3              0.000009       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
    3              0.000003     endif
    9              0.000008   endif

FUNCTION  <SNR>8_DetectScala()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000013     if getline(1) =~# '^#!\(/usr\)\?/bin/env\s\+scalas\?'
                                    set filetype=scala
                                endif

FUNCTION  <SNR>80_SetConcealOption()
Called 2 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    2              0.000003     if !g:indentLine_setConceal
                                    return
                                endif
    2              0.000006     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
    2              0.000004         let b:indentLine_ConcealOptionSet = 1
    2              0.000005         let b:indentLine_original_concealcursor = &l:concealcursor
    2              0.000005         let b:indentLine_original_conceallevel = &l:conceallevel
    2              0.000014         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
    2              0.000016         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
    2              0.000001     endif

FUNCTION  <SNR>87_get_hunks_gitgutter()
Called 507 times
Total time:   0.019231
 Self time:   0.004953

count  total (s)   self (s)
  507   0.005467   0.002686   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
  507   0.012839   0.001342   return GitGutterGetHunkSummary()

FUNCTION  <SNR>58_BufReadPostHook()
Called 2 times
Total time:   0.000431
 Self time:   0.000057

count  total (s)   self (s)
    2   0.000411   0.000037     let buf = syntastic#util#fname2buf(a:fname)
    2              0.000003     if g:syntastic_check_on_open && buf > 0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
                                    if index(s:_check_stack, buf) == -1
                                        call add(s:_check_stack, buf)
                                    endif
                                endif

FUNCTION  <SNR>58_BufWinEnterHook()
Called 2 times
Total time:   0.000372
 Self time:   0.000075

count  total (s)   self (s)
    2   0.000295   0.000014     let buf = syntastic#util#fname2buf(a:fname)
    2   0.000041   0.000025     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    2              0.000008     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    2              0.000010         let idx = index(reverse(copy(s:_check_stack)), buf)
    2              0.000003         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
                                    endif
    2              0.000000     endif

FUNCTION  <SNR>56__normalise_filetype()
Called 6 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    6              0.000037     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    6              0.000025     let ft = get(g:syntastic_filetype_map, ft, ft)
    6              0.000042     let ft = substitute(ft, '\m-', '_', 'g')
    6              0.000009     return ft

FUNCTION  <SNR>126_process_removed()
Called 8 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    8              0.000009   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
    8              0.000023     call add(a:modifications, [a:to_line, 'removed'])
    8              0.000002   endif

FUNCTION  syntastic#log#debugShowOptions()
Called 3 times
Total time:   0.000034
 Self time:   0.000022

count  total (s)   self (s)
    3   0.000029   0.000017     if !s:_isDebugEnabled(a:level)
    3              0.000003         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  airline#statusline()
Called 507 times
Total time:   0.009816
 Self time:   0.009816

count  total (s)   self (s)
  507              0.005264   if has_key(s:contexts, a:winnr)
  507              0.003566     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>80_IndentLinesDisable()
Called 2 times
Total time:   0.000391
 Self time:   0.000370

count  total (s)   self (s)
    2              0.000003     if g:indentLine_newVersion
    2              0.000010         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
   42              0.000029             for id in w:indentLine_indentLineId
   40              0.000020                 try
   40              0.000108                     call matchdelete(id)
   40              0.000034                 catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
   40              0.000034             endfor
    2              0.000013             let w:indentLine_indentLineId = []
    2              0.000002         endif
                            
    2   0.000081   0.000060         call s:ResetConcealOption()
    2              0.000002         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  <SNR>124_on_exit_vim()
Called 5 times
Total time:   0.134533
 Self time:   0.000246

count  total (s)   self (s)
    5   0.134528   0.000241   call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))

FUNCTION  airline#check_mode()
Called 507 times
Total time:   0.044012
 Self time:   0.044012

count  total (s)   self (s)
  507              0.001885   let context = s:contexts[a:winnr]
                            
  507              0.001740   if get(w:, 'airline_active', 1)
  507              0.001521     let l:m = mode()
  507              0.000916     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
  507              0.000937       let l:mode = ['normal']
  507              0.000331     endif
  507              0.002225     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  507              0.000302   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
  507              0.001741   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
  507              0.000751   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  507              0.002261   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  507              0.000749   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  507              0.000654   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
  507              0.002604   let mode_string = join(l:mode)
  507              0.001848   if get(w:, 'airline_lastmode', '') != mode_string
                                call airline#highlighter#highlight_modified_inactive(context.bufnr)
                                call airline#highlighter#highlight(l:mode, context.bufnr)
                                let w:airline_lastmode = mode_string
                              endif
                            
  507              0.000501   return ''

FUNCTION  <SNR>46_is_file_buffer()
Called 13 times
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
   13              0.000167   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  airline#util#append()
Called 3549 times
Total time:   0.030683
 Self time:   0.030683

count  total (s)   self (s)
 3549              0.006700   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 3549              0.009111   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 3549              0.008595   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>104_get_accented_line()
Called 71 times
Total time:   0.003851
 Self time:   0.003851

count  total (s)   self (s)
   71              0.000085   if a:self._context.active
   71              0.000083     let contents = []
   71              0.000468     let content_parts = split(a:contents, '__accent')
  170              0.000222     for cpart in content_parts
   99              0.000995       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   99              0.000245       call add(contents, cpart)
   99              0.000132     endfor
   71              0.000322     let line = join(contents, a:group)
   71              0.000463     let line = substitute(line, '__restore__', a:group, 'g')
   71              0.000047   else
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
   71              0.000070   return line

FUNCTION  <SNR>109_Pyeval()
Called 8 times
Total time:   0.006615
 Self time:   0.006615

count  total (s)   self (s)
    8              0.000021   if s:using_python3
    8              0.006578     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  <SNR>126_process_hunk()
Called 24 times
Total time:   0.004253
 Self time:   0.002033

count  total (s)   self (s)
   24              0.000038   let modifications = []
   24              0.000047   let from_line  = a:hunk[0]
   24              0.000038   let from_count = a:hunk[1]
   24              0.000031   let to_line    = a:hunk[2]
   24              0.000032   let to_count   = a:hunk[3]
                            
   24   0.000162   0.000117   if s:is_added(from_count, to_count)
    6   0.000356   0.000073     call s:process_added(modifications, from_count, to_count, to_line)
    6   0.000360   0.000086     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    6              0.000014   elseif s:is_removed(from_count, to_count)
    8   0.000123   0.000065     call s:process_removed(modifications, from_count, to_count, to_line)
    8   0.000403   0.000082     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    8              0.000018   elseif s:is_modified(from_count, to_count)
    8   0.000229   0.000081     call s:process_modified(modifications, from_count, to_count, to_line)
    8   0.000405   0.000099     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    8              0.000019   elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
    2   0.000636   0.000092     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
    2   0.000103   0.000007     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
    2   0.000072   0.000009     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
    2              0.000002   endif
   24              0.000027   return modifications

FUNCTION  <SNR>109_AllowedToCompleteInCurrentBuffer()
Called 374 times
Total time:   0.017014
 Self time:   0.001929

count  total (s)   self (s)
  374   0.016886   0.001801   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>126_process_modified()
Called 8 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    8              0.000011   let offset = 0
   16              0.000022   while offset < a:to_count
    8              0.000017     let line_number = a:to_line + offset
    8              0.000023     call add(a:modifications, [line_number, 'modified'])
    8              0.000009     let offset += 1
    8              0.000003   endwhile

FUNCTION  <SNR>104_get_seperator()
Called 39 times
Total time:   0.016820
 Self time:   0.000477

count  total (s)   self (s)
   39   0.001387   0.000204   if airline#builder#should_change_group(a:prev_group, a:group)
   39   0.015413   0.000253     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  syntastic#log#debug()
Called 78 times
Total time:   0.001052
 Self time:   0.000761

count  total (s)   self (s)
   78   0.000909   0.000618     if !s:_isDebugEnabled(a:level)
   78              0.000075         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  gitgutter#utility#set_repo_path()
Called 2 times
Total time:   0.003418
 Self time:   0.000506

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    2   0.000073   0.000041   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    2   0.000443   0.000058   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' ls-files --error-unmatch --full-name -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    2   0.000434   0.000197   if g:gitgutter_async && gitgutter#async#available()
    2              0.000004     if has('lambda')
    2   0.002402   0.000144       call gitgutter#async#execute(cmd, a:bufnr, {   'out': {bufnr, path -> gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))},   'err': {bufnr       -> gitgutter#utility#setbufvar(bufnr, 'path', -2)}, })
    2              0.000002     else
                                  if has('nvim') && !has('nvim-0.2.0')
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:not_tracked_by_git') })
                                  else
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:set_path', [-2]) })
                                  endif
                                endif
    2              0.000001   else
                                let path = gitgutter#utility#system(cmd)
                                if v:shell_error
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                else
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                                endif
                              endif

FUNCTION  airline#themes#get_highlight()
Called 310 times
Total time:   0.005860
 Self time:   0.001832

count  total (s)   self (s)
  310   0.005778   0.001750   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>109_OnFileReadyToParse()
Called 2 times
Total time:   0.003392
 Self time:   0.003392

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    2              0.000008   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    2              0.000006   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    2              0.003337     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    2              0.000011     call timer_stop( s:pollers.file_parse_response.id )
    2              0.000017     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    2              0.000002   endif

FUNCTION  airline#extensions#tabline#buffers#get()
Called 11 times
Total time:   0.014490
 Self time:   0.000814

count  total (s)   self (s)
   11              0.000013   try
   11   0.001445   0.000106     call <sid>map_keys()
   11              0.000008   catch
                                " no-op
                              endtry
   11              0.000031   let cur = bufnr('%')
   11              0.000033   if cur == s:current_bufnr && &columns == s:column_width
    9              0.000038     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    9              0.000018       return s:current_tabline
                                endif
                              endif
                            
    2   0.000362   0.000093   let b = airline#extensions#tabline#new_builder()
    2              0.000007   let tab_bufs = tabpagebuflist(tabpagenr())
    2              0.000003   let show_buf_label_first = 0
                            
    2              0.000005   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
    2              0.000002   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers')
                              endif
                            
    2              0.000014   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    2              0.000003   let b.overflow_group = 'airline_tabhid'
    2   0.000314   0.000074   let b.buffers = airline#extensions#tabline#buflist#list()
    2              0.000004   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
    2              0.000004   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    2              0.000007   if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
                              endif
                            
    2              0.000002   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    2              0.000010   let current_buffer = max([index(b.buffers, cur), 0])
    2              0.000008   let last_buffer = len(b.buffers) - 1
    2   0.000083   0.000011   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    2   0.000021   0.000009   call b.add_section('airline_tabfill', '')
    2   0.000017   0.000006   call b.split()
    2   0.000011   0.000004   call b.add_section('airline_tabfill', '')
    2              0.000003   if !show_buf_label_first
    2   0.000130   0.000059     call airline#extensions#tabline#add_label(b, 'buffers')
    2              0.000000   endif
                            
    2              0.000004   if tabpagenr('$') > 1
                                call b.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
                              endif
                            
    2              0.000011   let s:current_bufnr = cur
    2              0.000003   let s:column_width = &columns
    2   0.011670   0.000015   let s:current_tabline = b.build()
    2              0.000012   let s:current_visible_buffers = copy(b.buffers)
    2              0.000003   if b._right_title <= last_buffer
                                call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              endif
    2              0.000002   if b._left_title > 0
                                call remove(s:current_visible_buffers, 0, b._left_title)
                              endif
    2              0.000004   return s:current_tabline

FUNCTION  <SNR>106_reset_summary()
Called 4 times
Total time:   0.000119
 Self time:   0.000050

count  total (s)   self (s)
    4   0.000115   0.000046   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#highlighter#highlight()
Called 10 times
Total time:   0.086775
 Self time:   0.012619

count  total (s)   self (s)
   10              0.000029   let bufnr = a:0 ? a:1 : ''
   10              0.000047   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   10              0.000097   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   10              0.000035   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   20              0.000036   for mode in mapped
   10              0.000037     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
    5              0.000024       continue
                                endif
    5              0.000034     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    5              0.000022       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   90              0.000207       for kvp in items(dict)
   85              0.000181         let mode_colors = kvp[1]
   85              0.000156         let name = kvp[0]
   85              0.000258         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
   85   0.021856   0.000756         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  255              0.000537         for accent in keys(s:accents)
  170              0.000446           if !has_key(p.accents, accent)
                                        continue
                                      endif
  170              0.000714           let colors = copy(mode_colors)
  170              0.000459           if p.accents[accent][0] != ''
   85              0.000246             let colors[0] = p.accents[accent][0]
   85              0.000055           endif
  170              0.000355           if p.accents[accent][2] != ''
   85              0.000195             let colors[2] = p.accents[accent][2]
   85              0.000054           endif
  170              0.000317           if len(colors) >= 5
  170              0.000589             let colors[4] = get(p.accents[accent], 4, '')
  170              0.000115           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  170   0.043904   0.001426           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  170              0.000230         endfor
   85              0.000073       endfor
                            
                                  " TODO: optimize this
   50              0.000113       for sep in items(s:separators)
   45   0.010977   0.000399         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   45              0.000046       endfor
    5              0.000018     endif
    5              0.000000   endfor

FUNCTION  <SNR>46_abs_path()
Called 39 times
Total time:   0.002185
 Self time:   0.002185

count  total (s)   self (s)
   39              0.001964   let p = resolve(expand('#'.a:bufnr.':p'))
   39              0.000186   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>126_git_supports_command_line_config_override()
Called 1 time
Total time:   0.017842
 Self time:   0.000320

count  total (s)   self (s)
    1   0.017821   0.000299   call system(g:gitgutter_git_executable.' -c foo.bar=baz --version')
    1              0.000014   return !v:shell_error

FUNCTION  <SNR>96_map_keys()
Called 11 times
Total time:   0.001339
 Self time:   0.001339

count  total (s)   self (s)
   11              0.000055   if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   11              0.000247     noremap <silent> <Plug>AirlineSelectTab1 :call <SID>select_tab(0)<CR>
   11              0.000117     noremap <silent> <Plug>AirlineSelectTab2 :call <SID>select_tab(1)<CR>
   11              0.000105     noremap <silent> <Plug>AirlineSelectTab3 :call <SID>select_tab(2)<CR>
   11              0.000094     noremap <silent> <Plug>AirlineSelectTab4 :call <SID>select_tab(3)<CR>
   11              0.000097     noremap <silent> <Plug>AirlineSelectTab5 :call <SID>select_tab(4)<CR>
   11              0.000090     noremap <silent> <Plug>AirlineSelectTab6 :call <SID>select_tab(5)<CR>
   11              0.000094     noremap <silent> <Plug>AirlineSelectTab7 :call <SID>select_tab(6)<CR>
   11              0.000089     noremap <silent> <Plug>AirlineSelectTab8 :call <SID>select_tab(7)<CR>
   11              0.000090     noremap <silent> <Plug>AirlineSelectTab9 :call <SID>select_tab(8)<CR>
   11              0.000122     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   11              0.000106     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
   11              0.000007   endif

FUNCTION  SyntaxCheckers_vim_vimlint_IsAvailable()
Called 1 time
Total time:   0.000619
 Self time:   0.000580

count  total (s)   self (s)
    1              0.000001     try
                                    " Vim 7.2-051 and later
    1              0.000284         let vimlparser = globpath(&runtimepath, 'autoload/vimlparser.vim', 1)
    1              0.000245         let vimlint    = globpath(&runtimepath, 'autoload/vimlint.vim', 1)
    1              0.000002     catch /\m^Vim\%((\a\+)\)\=:E118/
                                    let vimlparser = globpath(&runtimepath, 'autoload/vimlparser.vim')
                                    let vimlint    = globpath(&runtimepath, 'autoload/vimlint.vim')
                                endtry
    1   0.000075   0.000036     call self.log("globpath(&runtimepath, 'autoload/vimlparser.vim', 1) = " . string(vimlparser) . ', ' . "globpath(&runtimepath, 'autoload/vimlint.vim', 1) = " .    string(vimlint))
    1              0.000003     return vimlparser !=# '' && vimlint !=# ''

FUNCTION  airline#extensions#vimagit#apply()
Called 12 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
   12              0.000017   if ( &filetype == 'magit' )
                                let w:airline_section_a = '%{airline#extensions#vimagit#get_mode()}'
                              endif

FUNCTION  <SNR>109_OnCursorMovedNormalMode()
Called 372 times
Total time:   0.049225
 Self time:   0.032395

count  total (s)   self (s)
  372   0.018264   0.001434   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  372              0.030124   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  <SNR>82_sync_active_winnr()
Called 372 times
Total time:   0.003039
 Self time:   0.003039

count  total (s)   self (s)
  372              0.001972   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  airline#parts#filetype()
Called 515 times
Total time:   0.003051
 Self time:   0.003051

count  total (s)   self (s)
  515              0.002834   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â€¦' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 12 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
   12              0.000050   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 507 times
Total time:   0.002950
 Self time:   0.002950

count  total (s)   self (s)
  507              0.001142   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  507              0.000341   return ''

FUNCTION  airline#extensions#term#apply()
Called 12 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
   12              0.000020   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                let name=get(g:airline_mode_map, 't', 't')
                                call a:1.add_section('airline_a', spc.name.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.'%f')
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  airline#builder#get_next_group()
Called 2 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000008   let x = a:i + 1
    2              0.000007   let l = len(a:sections)
    4              0.000005   while x < l
    4              0.000011     let group = a:sections[x][0]
    4              0.000008     if group != '' && group != '|'
    2              0.000002       return group
                                endif
    2              0.000003     let x = x + 1
    2              0.000020   endwhile
                              return ''

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 6 times
Total time:   0.000274
 Self time:   0.000089

count  total (s)   self (s)
    6   0.000142   0.000028   let summary = gitgutter#hunk#summary(a:bufnr)
    6              0.000012   let summary[0] += a:count
    6   0.000116   0.000045   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>10_LoadFTPlugin()
Called 2 times
Total time:   0.004504
 Self time:   0.003650

count  total (s)   self (s)
    2              0.000008     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    2              0.000006     let s = expand("<amatch>")
    2              0.000003     if s != ""
    2              0.000014       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000020       for name in split(s, '\.')
    2   0.004384   0.003530 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    2              0.000034       endfor
    2              0.000002     endif

FUNCTION  <SNR>58_ClearCache()
Called 3 times
Total time:   0.002804
 Self time:   0.000104

count  total (s)   self (s)
    3   0.000213   0.000029     let loclist = g:SyntasticLoclist.current(a:buf)
    3   0.002265   0.000046     call s:notifiers.reset(loclist)
    3   0.000321   0.000024     call loclist.destroy()

FUNCTION  gitgutter#async#execute()
Called 5 times
Total time:   0.006078
 Self time:   0.005575

count  total (s)   self (s)
    5   0.000670   0.000195   call gitgutter#debug#log('[async] '.a:cmd)
                            
    5              0.000028   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    5   0.000073   0.000045   let command = s:build_command(a:cmd)
                            
    5              0.000016   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
    5              0.005162     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    5              0.000025   endif

FUNCTION  <SNR>101_Get()
Called 147 times
Total time:   0.001036
 Self time:   0.001036

count  total (s)   self (s)
  147              0.000429   let res=get(a:dict, a:key, '')
  147              0.000209   if res is ''
   73              0.000060     return ''
                              else
   74              0.000134     return a:prefix. res
                              endif

FUNCTION  300()
Called 8 times
Total time:   0.001853
 Self time:   0.001853

count  total (s)   self (s)
  168              0.000655     for match in getmatches()
  160              0.000474         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
  160              0.000219     endfor

FUNCTION  301()
Called 18 times
Total time:   0.001106
 Self time:   0.001106

count  total (s)   self (s)
   18              0.000382     let newObj = copy(self)
                            
   18              0.000256     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
   18              0.000074     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
   18              0.000043     let newObj._rawLoclist = llist
   18              0.000042     let newObj._name = ''
   18              0.000045     let newObj._owner = bufnr('')
   18              0.000030     let newObj._sorted = 0
   18              0.000036     let newObj._columns = g:syntastic_cursor_columns
                            
   18              0.000021     return newObj

FUNCTION  302()
Called 32 times
Total time:   0.001957
 Self time:   0.000790

count  total (s)   self (s)
   32              0.000157     let buf = a:0 ? a:1 : bufnr('')
   32   0.000427   0.000223     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
   32              0.000151     if type(loclist) != type({}) || empty(loclist)
   15              0.000022         unlet! loclist
   15   0.001064   0.000101         let loclist = g:SyntasticLoclist.New([])
   15              0.000009     endif
   32              0.000025     return loclist

FUNCTION  304()
Called 3 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    3              0.000006     if !self._sorted
    3              0.000008         for e in self._rawLoclist
                                        call s:_set_screen_column(e)
                                    endfor
                            
    3              0.000018         call sort(self._rawLoclist, self._columns ? 's:_compare_error_items_by_columns' : 's:_compare_error_items_by_lines')
                            
    3              0.000007         let self._sorted = 1
    3              0.000003     endif

FUNCTION  305()
Called 22 times
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
   22              0.000138     return empty(self._rawLoclist)

FUNCTION  306()
Called 5 times
Total time:   0.000182
 Self time:   0.000109

count  total (s)   self (s)
    5              0.000014     if !exists('self._stamp')
    2              0.000007         let self._stamp = []
    2              0.000002         return 0
                                endif
    3   0.000146   0.000073     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  308()
Called 3 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    3              0.000004     return self._rawLoclist

FUNCTION  309()
Called 6 times
Total time:   0.000369
 Self time:   0.000137

count  total (s)   self (s)
    6   0.000365   0.000133     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  airline#extensions#tabline#buflist#list()
Called 24 times
Total time:   0.000342
 Self time:   0.000307

count  total (s)   self (s)
   24              0.000069   if exists('s:current_buffer_list')
   22              0.000027     return s:current_buffer_list
                              endif
                            
    2              0.000006   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
    2              0.000005   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
    2              0.000006   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    2              0.000013   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    2              0.000002   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
    5              0.000006   for nr in list
    3              0.000007     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                            
                                  " check buffer numbers first
    3              0.000007       if index(exclude_buffers, nr) >= 0
                                    continue
                                    " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                    " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
    3              0.000007       call add(buffers, nr)
    3              0.000002     endif
    3              0.000002   endfor
                            
    2              0.000004   let s:current_buffer_list = buffers
    2              0.000002   return buffers

FUNCTION  <SNR>84_invoke_funcrefs()
Called 12 times
Total time:   0.217527
 Self time:   0.000529

count  total (s)   self (s)
   12   0.000348   0.000078   let builder = airline#builder#new(a:context)
   12   0.012172   0.000163   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   12              0.000011   if err == 1
   12   0.204790   0.000071     let a:context.line = builder.build()
   12              0.000079     let s:contexts[a:context.winnr] = a:context
   12              0.000100     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   12              0.000008   endif

FUNCTION  syntastic#util#stamp()
Called 8 times
Total time:   0.000391
 Self time:   0.000391

count  total (s)   self (s)
    8              0.000384     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  <SNR>46_winshell()
Called 4 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    4              0.000044   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  311()
Called 24 times
Total time:   0.001318
 Self time:   0.001318

count  total (s)   self (s)
   24              0.000062     if !exists('self._stl_format')
   15              0.000024         let self._stl_format = ''
   15              0.000007     endif
   24              0.000047     if !exists('self._stl_flag')
   15              0.000020         let self._stl_flag = ''
   15              0.000008     endif
                            
   24              0.000043     if g:syntastic_stl_format !=# self._stl_format
   24              0.000037         let self._stl_format = g:syntastic_stl_format
                            
   24              0.000040         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
   24              0.000026             let self._stl_flag = ''
   24              0.000013         endif
   24              0.000013     endif
                            
   24              0.000024     return self._stl_flag

FUNCTION  <SNR>45_on_bufenter()
Called 2 times
Total time:   0.049818
 Self time:   0.000236

count  total (s)   self (s)
    2              0.000007   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                let force = !g:gitgutter_terminal_reports_focus
                            
                                if exists('t:gitgutter_force') && t:gitgutter_force
                                  let t:gitgutter_force = 0
                                  let force = 1
                                endif
                            
                                call gitgutter#all(force)
                              else
    2   0.004592   0.000071     call gitgutter#init_buffer(bufnr(''))
    2   0.045162   0.000101     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    2              0.000002   endif

FUNCTION  316()
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000020     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  318()
Called 3 times
Total time:   0.000297
 Self time:   0.000087

count  total (s)   self (s)
    6   0.000254   0.000044     for buf in self.getBuffers()
    3              0.000022         call setbufvar(buf, 'syntastic_loclist', {})
    3              0.000003     endfor

FUNCTION  <SNR>111_evaluate_tabline()
Called 11 times
Total time:   0.001807
 Self time:   0.001350

count  total (s)   self (s)
   11              0.000019   let tabline = a:tabline
   11   0.000917   0.000460   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
   11              0.000509   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
   11              0.000131   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
   11              0.000059   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
   11              0.000044   let tabline = substitute(tabline, '%=', '', 'g')
   11              0.000040   let tabline = substitute(tabline, '%\d*\*', '', 'g')
   11              0.000034   if has('tablineat')
                                let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
                              endif
   11              0.000009   return tabline

FUNCTION  <SNR>128_highlight_name_for_change()
Called 104 times
Total time:   0.000736
 Self time:   0.000736

count  total (s)   self (s)
  104              0.000160   if a:text ==# 'added'
   32              0.000031     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
    8              0.000006     return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
   62              0.000063     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
    2              0.000003     return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  <SNR>46_not_git_dir()
Called 11 times
Total time:   0.002651
 Self time:   0.000751

count  total (s)   self (s)
   11   0.002643   0.000743   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>107__isDebugEnabled_smart()
Called 90 times
Total time:   0.000342
 Self time:   0.000342

count  total (s)   self (s)
   90              0.000301     return and(g:syntastic_debug, a:level)

FUNCTION  gitgutter#utility#cd_cmd()
Called 5 times
Total time:   0.000897
 Self time:   0.000139

count  total (s)   self (s)
    5   0.000375   0.000086   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    5   0.000521   0.000052   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>126_process_added()
Called 6 times
Total time:   0.000283
 Self time:   0.000283

count  total (s)   self (s)
    6              0.000008   let offset = 0
   38              0.000043   while offset < a:to_count
   32              0.000055     let line_number = a:to_line + offset
   32              0.000088     call add(a:modifications, [line_number, 'added'])
   32              0.000028     let offset += 1
   32              0.000016   endwhile

FUNCTION  <SNR>87_get_hunks()
Called 507 times
Total time:   0.031547
 Self time:   0.012316

count  total (s)   self (s)
  507              0.002437   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    2              0.000006     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
    2              0.000004       let b:source_func = 's:get_hunks_gitgutter'
    2              0.000002     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
    2              0.000001   endif
  507   0.022154   0.002923   return {b:source_func}()

FUNCTION  329()
Called 3 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    3              0.000016     if exists('g:syntastic_mode_map')
    3              0.000025         let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
    3              0.000025         let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
    3              0.000033         let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
    3              0.000004     else
                                    let self._mode = 'active'
                                    let self._activeFiletypes = []
                                    let self._passiveFiletypes = []
                                endif

FUNCTION  307()
Called 5 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    5              0.000015     return copy(self._rawLoclist)

FUNCTION  <SNR>80_IndentLinesEnable()
Called 2 times
Total time:   0.000774
 Self time:   0.000714

count  total (s)   self (s)
    2              0.000002     if g:indentLine_newVersion
    2              0.000003         if &diff
                                        return
                                    endif
                            
    2              0.000006         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
                                    endif
                            
    2              0.000005         if !exists("w:indentLine_indentLineId")
                                        let w:indentLine_indentLineId = []
                                    endif
                            
    2   0.000105   0.000045         call s:SetConcealOption()
                            
    2              0.000003         if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
                                    endif
                            
    2              0.000005         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
   42              0.000047         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
   40              0.000512             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
   40              0.000044         endfor
                            
    2              0.000002         return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  <SNR>46_unc_path()
Called 5 times
Total time:   0.000230
 Self time:   0.000057

count  total (s)   self (s)
    5   0.000228   0.000055   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  330()
Called 3 times
Total time:   0.000492
 Self time:   0.000164

count  total (s)   self (s)
    3   0.000098   0.000049     let registry = g:SyntasticRegistry.Instance()
    3   0.000251   0.000033     let fts = registry.resolveFiletypes(a:filetype)
                            
    3   0.000026   0.000014     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    3   0.000095   0.000046         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  331()
Called 3 times
Total time:   0.000567
 Self time:   0.000075

count  total (s)   self (s)
    3              0.000019     let local_mode = getbufvar(a:buf, 'syntastic_mode')
    3              0.000011     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    3   0.000523   0.000031     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  332()
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000009     return self._mode ==# 'passive'

FUNCTION  nerdtree#checkForBrowse()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000017     if !isdirectory(a:dir)
    2              0.000002         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  airline#builder#get_prev_group()
Called 129 times
Total time:   0.001311
 Self time:   0.001311

count  total (s)   self (s)
  129              0.000193   let x = a:i - 1
  145              0.000157   while x >= 0
  127              0.000252     let group = a:sections[x][0]
  127              0.000230     if group != '' && group != '|'
  111              0.000110       return group
                                endif
   16              0.000017     let x = x - 1
   16              0.000009   endwhile
   18              0.000015   return ''

FUNCTION  <SNR>80_Disable()
Called 2 times
Total time:   0.000102
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000007     if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                elseif exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    return
                                elseif s:Filter() == 0
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
                                endif

FUNCTION  375()
Called 2 times
Total time:   0.000072
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000005   let self._first_title = a:first " lowest index
    2              0.000004   let self._last_title = a:last " highest index
    2              0.000002   let self._left_title = a:current " next index to add on the left
    2              0.000004   let self._right_title = a:current + 1 " next index to add on the right
    2   0.000052   0.000044   let self._left_position = self.get_position() " left end of titles
    2              0.000004   let self._right_position = self._left_position " right end of the titles

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 22 times
Total time:   0.002260
 Self time:   0.000394

count  total (s)   self (s)
   22   0.000212   0.000110   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   22              0.000069   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   22   0.001960   0.000196   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  340()
Called 3 times
Total time:   0.002219
 Self time:   0.001096

count  total (s)   self (s)
    3   0.000058   0.000022     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   18              0.000037     for type in self._enabled_types
   15              0.000491         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   15              0.000094         if has_key(g:{class}, 'reset')
    9   0.001225   0.000138             call self._notifier[type].reset(a:loclist)
    9              0.000009         endif
                            
                                    " also reset stamps
   15              0.000065         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    6              0.000040             let b:syntastic_private_{type}_stamp = []
    6              0.000006         endif
   15              0.000014     endfor

FUNCTION  342()
Called 5 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    5              0.000028     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
    5              0.000013     return s:SyntasticRegistryInstance

FUNCTION  343()
Called 2 times
Total time:   0.000475
 Self time:   0.000129

count  total (s)   self (s)
    2   0.000047   0.000016     let registry = g:SyntasticRegistry.Instance()
                            
    2              0.000008     if has_key(a:args, 'redirect')
                                    let [ft, name] = split(a:args['redirect'], '/')
                                    call registry._loadCheckersFor(ft, 1)
                            
                                    let clone = get(registry._checkerMap[ft], name, {})
                                    if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
                                    let checker = g:SyntasticChecker.New(a:args, clone)
                                else
    2   0.000269   0.000041         let checker = g:SyntasticChecker.New(a:args)
    2              0.000000     endif
    2   0.000100   0.000013     call registry._registerChecker(checker)

FUNCTION  344()
Called 3 times
Total time:   0.003250
 Self time:   0.000418

count  total (s)   self (s)
    3   0.000123   0.000017     let ftlist = self.resolveFiletypes(a:ftalias)
                            
    3              0.000022     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
    3              0.000004     let cnames = []
    3              0.000006     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
                                else
    6              0.000011         for ft in ftlist
    3   0.000129   0.000037             call self._sanityCheck(ft)
    3              0.000027             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
    3              0.000042             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
    3              0.000004         endfor
    3              0.000003     endif
    3   0.000120   0.000019     let cnames = syntastic#util#unique(cnames)
                            
    6   0.000142   0.000051     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
    3   0.002348   0.000025         call self._loadCheckersFor(ft, 0)
    3              0.000003     endfor
                            
    3   0.000158   0.000039     return self._filterCheckersByName(cnames)

FUNCTION  349()
Called 6 times
Total time:   0.000324
 Self time:   0.000200

count  total (s)   self (s)
    6   0.000321   0.000197     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  <SNR>126_is_added()
Called 24 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
   24              0.000039   return a:from_count == 0 && a:to_count > 0

FUNCTION  syntastic#util#rawVar()
Called 56 times
Total time:   0.000441
 Self time:   0.000441

count  total (s)   self (s)
   56              0.000412     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  gitgutter#diff#process_hunks()
Called 3 times
Total time:   0.004516
 Self time:   0.000263

count  total (s)   self (s)
    3              0.000006   let modified_lines = []
   27              0.000026   for hunk in a:hunks
   24   0.004440   0.000187     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   24              0.000014   endfor
    3              0.000003   return modified_lines

FUNCTION  351()
Called 2 times
Total time:   0.000087
 Self time:   0.000078

count  total (s)   self (s)
    2   0.000016   0.000012     let ft = a:checker.getFiletype()
    2              0.000007     if !has_key(self._checkerMap, ft)
    1              0.000003         let self._checkerMap[ft] = {}
    1              0.000001     endif
                            
    2   0.000034   0.000029     let name = a:checker.getName()
    2              0.000007     if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
    2              0.000008     let self._checkerMap[ft][name] = a:checker

FUNCTION  352()
Called 3 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    3              0.000012     let sep_idx = stridx(a:cname, '/')
    3              0.000005     if sep_idx > 0
    3              0.000010         let ft = a:cname[: sep_idx-1]
    3              0.000011         let name = a:cname[sep_idx+1 :]
    3              0.000003     else
                                    let ft = &filetype
                                    let name = a:cname
                                endif
    3              0.000013     return get(self._checkerMap[ft], name, {})

FUNCTION  353()
Called 3 times
Total time:   0.000119
 Self time:   0.000048

count  total (s)   self (s)
    3   0.000116   0.000045     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  354()
Called 3 times
Total time:   0.002323
 Self time:   0.000928

count  total (s)   self (s)
    3              0.000013     if !a:force && has_key(self._checkerMap, a:filetype)
    2              0.000003         return
                                endif
                            
    1   0.002292   0.000897     execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
    1              0.000005     if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  355()
Called 3 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    3              0.000024     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
                                endif
                            
    3              0.000024     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  357()
Called 10 times
Total time:   0.000525
 Self time:   0.000182

count  total (s)   self (s)
   10   0.000516   0.000173     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  358()
Called 5 times
Total time:   0.001047
 Self time:   0.000228

count  total (s)   self (s)
    5   0.000071   0.000027     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    5   0.000076   0.000028     let old_signs = copy(self._bufSignIds())
    5   0.000122   0.000015     if self.enabled()
    5              0.000007         if !s:setup_done
    1   0.000320   0.000031             call self._setup()
    1              0.000002             let s:setup_done = 1
    1              0.000002             lockvar s:setup_done
    1              0.000000         endif
                            
    5   0.000273   0.000023         call self._signErrors(a:loclist)
    5              0.000002     endif
    5   0.000127   0.000046     call self._removeSigns(old_signs)

FUNCTION  359()
Called 1 time
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
    1              0.000004     if has('signs')
    1              0.000020         if !hlexists('SyntasticErrorSign')
    1              0.000140             highlight link SyntasticErrorSign error
    1              0.000001         endif
    1              0.000009         if !hlexists('SyntasticWarningSign')
    1              0.000009             highlight link SyntasticWarningSign todo
    1              0.000001         endif
    1              0.000006         if !hlexists('SyntasticStyleErrorSign')
    1              0.000010             highlight link SyntasticStyleErrorSign SyntasticErrorSign
    1              0.000001         endif
    1              0.000007         if !hlexists('SyntasticStyleWarningSign')
    1              0.000006             highlight link SyntasticStyleWarningSign SyntasticWarningSign
    1              0.000001         endif
    1              0.000006         if !hlexists('SyntasticStyleErrorLine')
    1              0.000008             highlight link SyntasticStyleErrorLine SyntasticErrorLine
    1              0.000001         endif
    1              0.000006         if !hlexists('SyntasticStyleWarningLine')
    1              0.000008             highlight link SyntasticStyleWarningLine SyntasticWarningLine
    1              0.000001         endif
                            
                                    " define the signs used to display syntax and style errors/warns
    1              0.000013         execute 'sign define SyntasticError text=' . g:syntastic_error_symbol . ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
    1              0.000010         execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol . ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
    1              0.000008         execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol . ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
    1              0.000008         execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol . ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
    1              0.000001     endif

FUNCTION  <SNR>72_Highlight_Matching_Pair()
Called 372 times
Total time:   0.039407
 Self time:   0.039407

count  total (s)   self (s)
                              " Remove any previous match.
  372              0.001742   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  372              0.001627   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  372              0.001087   let c_lnum = line('.')
  372              0.000852   let c_col = col('.')
  372              0.000358   let before = 0
                            
  372              0.000947   let text = getline(c_lnum)
  372              0.005126   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  372              0.000757   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  372              0.001545     let [c_before, c] = matches[1:2]
  372              0.000208   endif
  372              0.014175   let plist = split(&matchpairs, '.\zs[:,]')
  372              0.001301   let i = index(plist, c)
  372              0.000373   if i < 0
                                " not found, in Insert mode try character before the cursor
  372              0.000987     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
  372              0.000261     if i < 0
                                  " not found, nothing to do
  372              0.000339       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  airline#util#shorten()
Called 519 times
Total time:   0.008338
 Self time:   0.008338

count  total (s)   self (s)
  519              0.002690   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â€¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'â€¦'
                                endif
                              else
  519              0.000523     return a:text
                              endif

FUNCTION  airline#extensions#tabline#add_label()
Called 2 times
Total time:   0.000071
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000007   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    2   0.000062   0.000033     call a:dict.add_section_spaced('airline_tablabel', get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    2              0.000002   endif

FUNCTION  <SNR>58__ignore_file()
Called 6 times
Total time:   0.000173
 Self time:   0.000173

count  total (s)   self (s)
    6              0.000096     let fname = fnamemodify(a:filename, ':p')
    6              0.000022     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    6              0.000008     return 0

FUNCTION  360()
Called 5 times
Total time:   0.000250
 Self time:   0.000236

count  total (s)   self (s)
    5              0.000009     let loclist = a:loclist
    5   0.000030   0.000016     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  361()
Called 5 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    5              0.000016     if has('signs')
    5              0.000021         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    5              0.000005     endif

FUNCTION  362()
Called 5 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    5              0.000021     if !exists('b:syntastic_private_sign_ids')
    2              0.000005         let b:syntastic_private_sign_ids = []
    2              0.000001     endif
    5              0.000009     return b:syntastic_private_sign_ids

FUNCTION  367()
Called 14 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   14              0.000054   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  368()
Called 2 times
Total time:   0.000029
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000012   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    2   0.000016   0.000010   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  369()
Called 102 times
Total time:   0.000350
 Self time:   0.000350

count  total (s)   self (s)
  102              0.000321   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>128_add_dummy_sign()
Called 1 time
Total time:   0.059614
 Self time:   0.059587

count  total (s)   self (s)
    1   0.000011   0.000004   if !gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
    1              0.059554     execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
    1   0.000046   0.000026     call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 1)
    1              0.000001   endif

FUNCTION  <SNR>128_find_current_signs()
Called 3 times
Total time:   0.005174
 Self time:   0.005051

count  total (s)   self (s)
    3              0.000006   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    3              0.000003   let other_signs = []      " [<line_number (number),...]
    3              0.000004   let dummy_sign_placed = 0
                            
    3              0.000008   redir => signs
    3              0.000058     silent execute "sign place buffer=" . a:bufnr
    3              0.000008   redir END
                            
   55              0.000215   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
   52              0.002602     let components  = split(sign_line)
   52              0.000304     let name        = split(components[2], '=')[1]
   52              0.000199     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
   52              0.000296       let line_number = str2nr(split(components[0], '=')[1])
   52              0.000155       if name =~# 'GitGutter'
   52              0.000268         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
   52              0.000102         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
   52              0.000181         let gitgutter_signs[line_number] = {'id': id, 'name': name}
   52              0.000026       else
                                    call add(other_signs, line_number)
                                  endif
   52              0.000031     end
   52              0.000024   endfor
                            
    3   0.000056   0.000015   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
    3   0.000067   0.000032   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
    3   0.000078   0.000031   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  airline#highlighter#add_separator()
Called 110 times
Total time:   0.019604
 Self time:   0.001402

count  total (s)   self (s)
  110              0.000586   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  110   0.018976   0.000774   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  371()
Called 3 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    3              0.000012   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  373()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000005   return len(self._sections)

FUNCTION  374()
Called 16 times
Total time:   0.212418
 Self time:   0.009504

count  total (s)   self (s)
   16              0.000017   let side = 1
   16              0.000013   let line = ''
   16              0.000016   let i = 0
   16              0.000031   let length = len(self._sections)
   16              0.000017   let split = 0
   16              0.000016   let is_empty = 0
   16              0.000030   let prev_group = ''
                            
  143              0.000169   while i < length
  127              0.000263     let section = self._sections[i]
  127              0.000205     let group = section[0]
  127              0.000180     let contents = section[1]
  127              0.000155     let pgroup = prev_group
  127   0.001954   0.000665     let prev_group = airline#builder#get_prev_group(self._sections, i)
  127              0.000272     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
  127              0.000098     if is_empty
   28              0.000032       let prev_group = pgroup
   28              0.000016     endif
  127   0.175304   0.000701     let is_empty = s:section_is_empty(self, contents)
                            
  127              0.000096     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
   40              0.000049       let pgroup = group
   40              0.000021     endif
                            
  127              0.000149     if group == ''
                                  let line .= contents
                                elseif group == '|'
   16              0.000014       let side = 0
   16              0.000029       let line .= contents
   16              0.000014       let split = 1
   16              0.000004     else
  111              0.000121       if prev_group == ''
   16              0.000046         let line .= '%#'.group.'#'
   16              0.000014       elseif split
   16              0.000014         if !is_empty
   16   0.006460   0.000109           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   16              0.000011         endif
   16              0.000015         let split = 0
   16              0.000011       else
   79              0.000064         if !is_empty
   39   0.017049   0.000229           let line .= s:get_seperator(self, prev_group, group, side)
   39              0.000029         endif
   79              0.000033       endif
  111   0.004650   0.000799       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  111              0.000063     endif
                            
  127              0.000224     let i = i + 1
  127              0.000118   endwhile
                            
   16              0.000018   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
   16              0.000016   return line

FUNCTION  376()
Called 3 times
Total time:   0.001613
 Self time:   0.000127

count  total (s)   self (s)
    3   0.000446   0.000016   let title = self.get_title(a:index)
    3   0.001058   0.000019   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    3              0.000005   if a:force || self._remaining_space >= title_size
    3              0.000003     let pos = a:pos
    3              0.000007     if has_key(self, "get_pretitle")
                                  call self.insert_raw(self.get_pretitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
                                endif
                            
    3   0.000033   0.000016     call self.insert_section(a:group, title, pos)
    3              0.000004     let self._right_position += 1
    3              0.000003     let pos += 1
                            
    3              0.000007     if has_key(self, "get_posttitle")
                                  call self.insert_raw(self.get_posttitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
                                endif
                            
    3              0.000005     let self._remaining_space -= title_size
    3              0.000003     return 1
                              endif
                              return 0

FUNCTION  377()
Called 2 times
Total time:   0.011655
 Self time:   0.000632

count  total (s)   self (s)
    2              0.000008   if has_key(self, '_left_position') && self._first_title <= self._last_title
    2   0.003913   0.000075     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    2              0.000007     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    2   0.000127   0.000008     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    2   0.000092   0.000008     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    2   0.000033   0.000011     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    2   0.000116   0.000043     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    2              0.000010     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    2   0.000097   0.000008     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    2              0.000003     if self._left_title > self._first_title
    1   0.000031   0.000007       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
    1              0.000001     endif
    2              0.000002     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
                                endif
                            
                                " Add the current title
    2   0.000180   0.000028     let group = self.get_group(self._left_title)
    2              0.000002     if self._left_title == self._first_title
    1   0.000131   0.000050       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
    1              0.000000     else
    1   0.000068   0.000006       let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    1              0.000001     endif
    2              0.000003     if self._left_title == self._last_title
    2   0.000126   0.000012       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
    2              0.000001     else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
    2              0.000002     let left_group = group
    2              0.000004     let right_group = group
    2   0.001150   0.000029     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    2              0.000005     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
                                endif
                            
    2              0.000004     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
                                endif
                            
    3              0.000004     while self._remaining_space > 0
    3              0.000003       let done = 0
    3              0.000003       if self._left_title >= self._first_title
                                    " Insert next title to the left
    1   0.000067   0.000006         let group = self.get_group(self._left_title)
    1              0.000003         if self._left_title == self._first_title
    1   0.000102   0.000012           let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
    1              0.000000         else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
    1              0.000002         let left_group = group
    1   0.000498   0.000006         let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
    1              0.000001         let self._left_title -= done
    1              0.000000       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    3              0.000005       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
                                  endif
    3              0.000003       if !done
    2              0.000002         break
                                  endif
    1              0.000000     endwhile
                            
    2              0.000003     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
                                endif
                            
    2              0.000002     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
                                endif
    2              0.000000   endif
                            
    2   0.004611   0.000010   return self._build()

FUNCTION  gitgutter#debug#log()
Called 8 times
Total time:   0.000360
 Self time:   0.000360

count  total (s)   self (s)
    8              0.000014   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>126_is_modified_and_removed()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000006   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  airline#util#wrap()
Called 2072 times
Total time:   0.009683
 Self time:   0.009683

count  total (s)   self (s)
 2072              0.004217   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 2072              0.001806   return a:text

FUNCTION  <SNR>58__skip_file()
Called 6 times
Total time:   0.000939
 Self time:   0.000623

count  total (s)   self (s)
    6              0.000026     let fname = bufname(a:buf)
    6   0.000854   0.000538     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    6              0.000009     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    6              0.000008     return skip

FUNCTION  <SNR>109_OnBufferUnload()
Called 1 time
Total time:   0.000085
 Self time:   0.000068

count  total (s)   self (s)
                              " Expanding <abuf> returns the unloaded buffer number as a string but we want
                              " it as a true number for the getbufvar function.
    1              0.000007   let buffer_number = str2nr( expand( '<abuf>' ) )
    1   0.000074   0.000057   if !s:AllowedToCompleteInBuffer( buffer_number )
    1              0.000001     return
                              endif
                            
                              exec s:python_command "ycm_state.OnBufferUnload( " . buffer_number . " )"

FUNCTION  syntastic#log#debugShowVariables()
Called 6 times
Total time:   0.000088
 Self time:   0.000060

count  total (s)   self (s)
    6   0.000075   0.000047     if !s:_isDebugEnabled(a:level)
    6              0.000006         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  airline#extensions#tabline#get()
Called 11 times
Total time:   0.014982
 Self time:   0.000492

count  total (s)   self (s)
   11              0.000053   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   11              0.000030   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   11              0.000028   let curtabcnt = tabpagenr('$')
   11              0.000020   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
   11              0.000042   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
   11              0.000012   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
   11   0.014649   0.000159     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  317()
Called 3 times
Total time:   0.000412
 Self time:   0.000085

count  total (s)   self (s)
    3   0.000194   0.000026     let self._stamp = syntastic#util#stamp()
    6   0.000180   0.000021     for buf in self.getBuffers()
    3              0.000018         call setbufvar(buf, 'syntastic_loclist', self)
    3              0.000003     endfor

FUNCTION  gitgutter#utility#extension()
Called 3 times
Total time:   0.000211
 Self time:   0.000041

count  total (s)   self (s)
    3   0.000210   0.000040   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>4_StarSetf()
Called 2 times
Total time:   0.131529
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000021   if expand("<amatch>") !~ g:ft_ignore_pat
    2   0.131504   0.000022     exe 'setf ' . a:ft
    2              0.000001   endif

FUNCTION  airline#util#getwinvar()
Called 156 times
Total time:   0.000466
 Self time:   0.000466

count  total (s)   self (s)
  156              0.000416     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#tabline#buffers#invalidate()
Called 3 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    3              0.000013   let s:current_bufnr = -1

FUNCTION  <SNR>93_update_tabline()
Called 2 times
Total time:   0.000556
 Self time:   0.000272

count  total (s)   self (s)
    2              0.000015   if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
                              endif
    2              0.000065   let match = expand('<afile>')
    2              0.000015   let ignore_bufadd_pat = get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', '\c\vgundo|undotree|vimfiler|tagbar|nerd_tree|startify')
    2              0.000004   if pumvisible()
                                return
                              elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
                              elseif empty(match) || airline#util#ignore_buf(match) || isdirectory(expand("<afile>"))
                                return
                              endif
    2   0.000178   0.000049   doautocmd User BufMRUChange
                              " sometimes, the tabline is not correctly updated see #1580
                              " so force redraw here
    2              0.000016   let &tabline = &tabline

FUNCTION  gitgutter#hunk#hunks()
Called 3 times
Total time:   0.000047
 Self time:   0.000017

count  total (s)   self (s)
    3   0.000046   0.000016   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>41_on_window_changed()
Called 5 times
Total time:   0.044002
 Self time:   0.000273

count  total (s)   self (s)
    5              0.000023   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    5              0.000061   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
    5              0.000072   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    3              0.000004     return
                              endif
    2              0.000006   let g:airline_last_window_changed = l:key
    2   0.000041   0.000035   call s:init()
    2   0.043761   0.000038   call airline#update_statusline()

FUNCTION  syntastic#util#getbufvar()
Called 32 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
   32              0.000183     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  airline#extensions#syntastic#get()
Called 24 times
Total time:   0.003195
 Self time:   0.000591

count  total (s)   self (s)
   24              0.000073   let _backup = get(g:, 'syntastic_stl_format', '')
   24              0.000043   let is_err = (a:type  is# 'error')
   24              0.000016   if is_err
   12              0.000039     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_err', '%E{[%e(#%fe)]}')
   12              0.000009   else
   12              0.000044     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_warn', '%W{[%w(#%fw)]}')
   12              0.000007   endif
   24   0.002719   0.000115   let cnt = SyntasticStatuslineFlag()
   24              0.000044   if !empty(_backup)
   24              0.000036     let g:syntastic_stl_format = _backup
   24              0.000012   endif
   24              0.000034   if empty(cnt)
   24              0.000021     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  syntastic#util#isRunningWindows()
Called 3 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    3              0.000051     return has('win16') || has('win32') || has('win64')

FUNCTION  airline#themes#patch()
Called 5 times
Total time:   0.001063
 Self time:   0.001063

count  total (s)   self (s)
   35              0.000088   for mode in keys(a:palette)
   30              0.000118     if !has_key(a:palette[mode], 'airline_warning')
                                  let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
                                endif
   30              0.000105     if !has_key(a:palette[mode], 'airline_error')
                                  let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
                                endif
   30              0.000084     if !has_key(a:palette[mode], 'airline_term')
                                  let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
                                endif
   30              0.000049   endfor
                            
    5              0.000025   let a:palette.accents = get(a:palette, 'accents', {})
    5              0.000035   let a:palette.accents.none = [ '', '', '', '', '' ]
    5              0.000032   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    5              0.000038   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    5              0.000016   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
    5              0.000015   if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
                              endif
    5              0.000013   if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
                              endif
    5              0.000013   if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
                              endif
    5              0.000012   if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
                              endif
    5              0.000012   if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
                              endif

FUNCTION  <SNR>41_init()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000003   if s:airline_initialized
    2              0.000002     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 22 times
Total time:   0.000398
 Self time:   0.000398

count  total (s)   self (s)
   22              0.000103   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
   22              0.000144   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   22              0.000068   if getbufvar(a:bufnr, '&modified') == 1
                                let _ .= s:buf_modified_symbol
                              endif
   22              0.000020   return _

FUNCTION  airline#extensions#syntastic#get_error()
Called 12 times
Total time:   0.001556
 Self time:   0.000050

count  total (s)   self (s)
   12   0.001551   0.000045   return airline#extensions#syntastic#get('error')

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 10 times
Total time:   0.000402
 Self time:   0.000139

count  total (s)   self (s)
   10   0.000221   0.000074   let summary = gitgutter#hunk#summary(a:bufnr)
   10              0.000021   let summary[1] += a:count
   10   0.000157   0.000041   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>80_ResetConcealOption()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000009     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    let &l:concealcursor = b:indentLine_original_concealcursor
                                    let &l:conceallevel = b:indentLine_original_conceallevel
                                    let b:indentLine_ConcealOptionSet = 0
                                endif

FUNCTION  gitgutter#sign#remove_dummy_sign()
Called 1 time
Total time:   0.000046
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000023   0.000009   if gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
    1              0.000005     execute "sign unplace" s:dummy_sign_id "buffer=" . a:bufnr
    1   0.000016   0.000004     call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 0)
    1              0.000001   endif

FUNCTION  airline#highlighter#load_theme()
Called 5 times
Total time:   0.087114
 Self time:   0.000339

count  total (s)   self (s)
    5              0.000013   if pumvisible()
                                return
                              endif
    5              0.000053   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
                              endfor
    5   0.000706   0.000111   call airline#highlighter#highlight(['inactive'])
    5              0.000041   if getbufvar( bufnr('%'), '&modified'  )
                                call airline#highlighter#highlight(['normal', 'modified'])
                              else
    5   0.086230   0.000050     call airline#highlighter#highlight(['normal'])
    5              0.000005   endif

FUNCTION  syntastic#util#var()
Called 56 times
Total time:   0.001107
 Self time:   0.000666

count  total (s)   self (s)
   56   0.001075   0.000634     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  syntastic#util#compareLexi()
Called 3 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    3              0.000025     for idx in range(max([len(a:a), len(a:b)]))
    3              0.000016         let a_element = str2nr(get(a:a, idx, 0))
    3              0.000014         let b_element = str2nr(get(a:b, idx, 0))
    3              0.000006         if a_element != b_element
    3              0.000006             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  airline#extensions#vimtex#apply()
Called 12 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
   12              0.000037   if exists("b:vimtex")
                                let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x)
                                let w:airline_section_x.=s:spc.g:airline_left_alt_sep.s:spc.'%{airline#extensions#vimtex#get_scope()}'
                              endif

FUNCTION  <SNR>126_process_modified_and_removed()
Called 2 times
Total time:   0.000544
 Self time:   0.000544

count  total (s)   self (s)
    2              0.000003   let offset = 0
   58              0.000058   while offset < a:to_count
   56              0.000106     let line_number = a:to_line + offset
   56              0.000225     call add(a:modifications, [line_number, 'modified'])
   56              0.000068     let offset += 1
   56              0.000051   endwhile
    2              0.000008   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  <SNR>46_strip_trailing_new_line()
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000021   return substitute(a:line, '\n$', '', '')

FUNCTION  <SNR>126_save_last_seen_change()
Called 3 times
Total time:   0.000065
 Self time:   0.000021

count  total (s)   self (s)
    3   0.000064   0.000020   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>101_CheckDefined()
Called 475 times
Total time:   0.013654
 Self time:   0.013654

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  475              0.001518   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  475              0.001610   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
  945              0.001324   for val in a:colors
  945              0.002053     if !empty(val) && val !=# 'NONE'
  475              0.000521       return a:colors
                                endif
  470              0.000550   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 22 times
Total time:   0.001764
 Self time:   0.001366

count  total (s)   self (s)
   22              0.000061   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
   22              0.000021   let _ = ''
                            
   22              0.000050   let name = bufname(a:bufnr)
   22              0.000035   if empty(name)
                                let _ .= '[No Name]'
                              else
   22              0.000023     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Ð£Ñ‡Ñ‘Ð±Ð°/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   22              0.000697       let _ .= pathshorten(fnamemodify(name, fmod))
   22              0.000020     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
   22              0.000083     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
   22              0.000008   endif
                            
   22   0.000561   0.000163   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  gitgutter#utility#shellescape()
Called 24 times
Total time:   0.001724
 Self time:   0.001677

count  total (s)   self (s)
   24              0.001467   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   20              0.000062     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    4              0.000016     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
Called 509 times
Total time:   0.057586
 Self time:   0.057586

count  total (s)   self (s)
  509              0.003558   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify')
  509              0.053599   return match(a:name, pat) > -1

FUNCTION  gitgutter#async#available()
Called 5 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    5              0.000008   return s:available

FUNCTION  <SNR>109_SetCompleteFunc()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007   let &completefunc = 'youcompleteme#CompleteFunc'

FUNCTION  <SNR>109_OnFileTypeSet()
Called 2 times
Total time:   0.042162
 Self time:   0.004314

count  total (s)   self (s)
    2   0.000233   0.000049   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    2   0.000069   0.000032   call s:SetUpCompleteopt()
    2   0.000038   0.000030   call s:SetCompleteFunc()
    2   0.000061   0.000040   call s:StartMessagePoll()
                            
    2   0.038210   0.004004   exec s:python_command "ycm_state.OnBufferVisit()"
    2   0.003543   0.000151   call s:OnFileReadyToParse( 1 )

FUNCTION  gitgutter#diff#parse_hunk()
Called 24 times
Total time:   0.001398
 Self time:   0.001398

count  total (s)   self (s)
   24              0.000984   let matches = matchlist(a:line, s:hunk_re)
   24              0.000052   if len(matches) > 0
   24              0.000066     let from_line  = str2nr(matches[1])
   24              0.000093     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   24              0.000050     let to_line    = str2nr(matches[3])
   24              0.000068     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   24              0.000050     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>128_next_sign_id()
Called 52 times
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
   52              0.000060   let next_id = s:next_sign_id
   52              0.000061   let s:next_sign_id += 1
   52              0.000039   return next_id

FUNCTION  326()
Called 3 times
Total time:   0.000262
 Self time:   0.000206

count  total (s)   self (s)
    3              0.000013     if !exists('w:syntastic_loclist_set')
    1              0.000002         let w:syntastic_loclist_set = []
    1              0.000001     endif
    3              0.000016     if a:new || empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [self._owner, getbufvar(self._owner, 'changedtick')]
    3              0.000012         let replace = !a:new && g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
    3   0.000052   0.000022         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
    3   0.000052   0.000047         call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
    3              0.000003         try
                                        " Vim 7.4.2200 or later
    3              0.000023             call setloclist(0, [], 'r', { 'title': ':SyntasticCheck ' . self._name })
    3              0.000006         catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                        " do nothing
                                    endtry
    3   0.000036   0.000015         call syntastic#util#setLastTick(self._owner)
    3              0.000018         let w:syntastic_loclist_set = [self._owner, getbufvar(self._owner, 'syntastic_lasttick')]
    3              0.000003     endif

FUNCTION  airline#load_theme()
Called 5 times
Total time:   0.249194
 Self time:   0.000429

count  total (s)   self (s)
    5              0.000041   let g:airline_theme = get(g:, 'airline_theme', 'dark')
    5              0.000040   if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
                              endif
                            
    5              0.000027   let palette = g:airline#themes#{g:airline_theme}#palette
    5   0.001137   0.000074   call airline#themes#patch(palette)
                            
    5              0.000019   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    5   0.087183   0.000069   call airline#highlighter#load_theme()
    5   0.012790   0.000071   call airline#extensions#load_theme()
    5   0.147887   0.000018   call airline#update_statusline()

FUNCTION  airline#parts#paste()
Called 507 times
Total time:   0.001351
 Self time:   0.001351

count  total (s)   self (s)
  507              0.001191   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
Called 12 times
Total time:   0.218527
 Self time:   0.000948

count  total (s)   self (s)
   12   0.000149   0.000097   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   12              0.000084   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor
                            
   12              0.000024   unlet! w:airline_render_left w:airline_render_right
   12              0.000258   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
   12              0.000019   let w:airline_active = 1
   12              0.000087   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   12   0.217720   0.000193   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  gitgutter#sign#update_signs()
Called 3 times
Total time:   0.126220
 Self time:   0.000468

count  total (s)   self (s)
    3   0.005230   0.000056   call s:find_current_signs(a:bufnr)
                            
    3              0.000101   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    3   0.000708   0.000080   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    3              0.000010   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    3              0.000003   if flicker_possible
    1   0.059644   0.000030     call s:add_dummy_sign(a:bufnr)
    1              0.000000   endif
                            
    3   0.055490   0.000048   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    3   0.004918   0.000070   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    3              0.000003   if flicker_possible
    1   0.000089   0.000043     call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
    1              0.000001   endif

FUNCTION  SyntasticLoclistHide()
Called 3 times
Total time:   0.000076
 Self time:   0.000025

count  total (s)   self (s)
    3   0.000067   0.000016     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
    3              0.000006     silent! lclose

FUNCTION  <SNR>101_get_array()
Called 330 times
Total time:   0.002972
 Self time:   0.002972

count  total (s)   self (s)
  330              0.001253   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  330              0.001533   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  <SNR>109_AllowedToCompleteInBuffer()
Called 375 times
Total time:   0.015102
 Self time:   0.013308

count  total (s)   self (s)
  375              0.001822   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
  375              0.002070   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
    1              0.000001     return 0
                              endif
                            
  374   0.003295   0.001501   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
  374              0.001811   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
  374              0.001212   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
  374              0.000638   let allowed = whitelist_allows && blacklist_allows
  374              0.000331   if allowed
  374              0.001101     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  374              0.000208   endif
  374              0.000378   return allowed

FUNCTION  airline#parts#readonly()
Called 507 times
Total time:   0.066254
 Self time:   0.008823

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files, 
                              " but not special ones like e.g. NERDTree)
  507   0.061499   0.004068   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
  507              0.001453   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  507              0.000733     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  syntastic#util#bufIsActive()
Called 5 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    5              0.000028     let buf = str2nr(a:buffer)
                            
    5              0.000022     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
    5              0.000060     for tab in range(1, tabpagenr('$'))
    5              0.000024         if index(tabpagebuflist(tab), buf) >= 0
    5              0.000005             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  gitgutter#utility#setbufvar()
Called 53 times
Total time:   0.000801
 Self time:   0.000801

count  total (s)   self (s)
   53              0.000248   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   53              0.000119   let needs_setting = empty(dict)
   53              0.000181   let dict[a:varname] = a:val
   53              0.000045   if needs_setting
    2              0.000006     call setbufvar(+a:buffer, 'gitgutter', dict)
    2              0.000002   endif

FUNCTION  airline#highlighter#exec()
Called 475 times
Total time:   0.093007
 Self time:   0.029456

count  total (s)   self (s)
  475              0.000778   if pumvisible()
                                return
                              endif
  475              0.000657   let colors = a:colors
  475              0.000518   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  475   0.044723   0.002183   let old_hi = airline#highlighter#get_highlight(a:group)
  475              0.000912   if len(colors) == 4
  155              0.000331     call add(colors, '')
  155              0.000098   endif
  475              0.000695   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  475              0.003365     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  475              0.000301   endif
  475   0.015815   0.002161   let colors = s:CheckDefined(colors)
  475   0.008727   0.002406   if old_hi != new_hi || !s:hl_group_exists(a:group)
   21   0.001758   0.000722     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
   21              0.000293     exe cmd
   21              0.000073     if has_key(s:hl_groups, a:group)
   21              0.000055       let s:hl_groups[a:group] = colors
   21              0.000018     endif
   21              0.000009   endif

FUNCTION  UltiSnips#SnippetsInCurrentScope()
Called 2 times
Total time:   0.018924
 Self time:   0.018924

count  total (s)   self (s)
    2              0.000040     let g:current_ulti_dict = {}
    2              0.000008     let all = get(a:, 1, 0)
    2              0.000002     if all
    2              0.000046       let g:current_ulti_dict_info = {}
    2              0.000002     endif
    2              0.018816     exec g:_uspy "UltiSnips_Manager.snippets_in_current_scope(" . all . ")"
    2              0.000003     return g:current_ulti_dict

FUNCTION  <SNR>126_is_modified()
Called 10 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
   10              0.000021   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  airline#extensions#whitespace#check()
Called 12 times
Total time:   0.148117
 Self time:   0.059816

count  total (s)   self (s)
   12              0.000055   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   12              0.000067   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
   12              0.000058   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   12              0.000030   if !exists('b:airline_whitespace_check')
    7              0.000011     let b:airline_whitespace_check = ''
    7              0.000030     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    7              0.000007     let trailing = 0
    7              0.000008     let check = 'trailing'
    7              0.000067     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    7              0.000005       try
    7              0.000021         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    7              0.058325         let trailing = search(regexp, 'nw')
    7              0.000016       catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    7              0.000005     endif
                            
    7              0.000011     let mixed = 0
    7              0.000008     let check = 'indent'
    7              0.000061     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    7   0.086105   0.000085       let mixed = s:check_mixed_indent()
    7              0.000012     endif
                            
    7              0.000012     let mixed_file = ''
    7              0.000009     let check = 'mixed-indent-file'
    7              0.000066     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    7   0.002183   0.000089       let mixed_file = s:check_mixed_indent_file()
    7              0.000004     endif
                            
    7              0.000007     let long = 0
    7              0.000016     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    7              0.000020     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
    7              0.000002   endif
   12   0.000243   0.000056   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>101_exec_separator()
Called 155 times
Total time:   0.028780
 Self time:   0.005253

count  total (s)   self (s)
  155              0.000254   if pumvisible()
                                return
                              endif
  155   0.004488   0.000831   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  155   0.002908   0.000705   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  155              0.000464   let group = a:from.'_to_'.a:to.a:suffix
  155              0.000159   if a:inverse
   66              0.000273     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   66              0.000040   else
   89              0.000365     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   89              0.000041   endif
  155              0.000398   let a:dict[group] = colors
  155   0.018595   0.000928   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>121_foldable()
Called 22 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   22              0.000062   if index(s:foldable_groups, 'ALL') > -1
   22              0.000019     return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  <SNR>128_obsolete_gitgutter_signs_to_remove()
Called 3 times
Total time:   0.000628
 Self time:   0.000602

count  total (s)   self (s)
    3              0.000007   let signs_to_remove = []  " list of [<id (number)>, ...]
    3              0.000003   let remove_all_signs = 1
    3   0.000039   0.000013   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
   55              0.000072   for line_number in keys(old_gitgutter_signs)
   52              0.000187     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
   52              0.000061       let remove_all_signs = 0
   52              0.000030     endif
   52              0.000044   endfor
    3              0.000006   let s:remove_all_old_signs = remove_all_signs
    3              0.000003   return signs_to_remove

FUNCTION  <SNR>108_setup_maps()
Called 2 times
Total time:   0.000482
 Self time:   0.000482

count  total (s)   self (s)
    2              0.000004   if !g:gitgutter_map_keys
                                return
                              endif
                            
    2              0.000054   if !hasmapto('<Plug>GitGutterPrevHunk') && maparg('[c', 'n') ==# ''
    2              0.000017     nmap <buffer> [c <Plug>GitGutterPrevHunk
    2              0.000001   endif
    2              0.000030   if !hasmapto('<Plug>GitGutterNextHunk') && maparg(']c', 'n') ==# ''
    2              0.000014     nmap <buffer> ]c <Plug>GitGutterNextHunk
    2              0.000000   endif
                            
    2              0.000031   if !hasmapto('<Plug>GitGutterStageHunk') && maparg('<Leader>hs', 'n') ==# ''
    2              0.000016     nmap <buffer> <Leader>hs <Plug>GitGutterStageHunk
    2              0.000001   endif
    2              0.000029   if !hasmapto('<Plug>GitGutterUndoHunk') && maparg('<Leader>hu', 'n') ==# ''
    2              0.000015     nmap <buffer> <Leader>hu <Plug>GitGutterUndoHunk
    2              0.000001   endif
    2              0.000043   if !hasmapto('<Plug>GitGutterPreviewHunk') && maparg('<Leader>hp', 'n') ==# ''
    2              0.000015     nmap <buffer> <Leader>hp <Plug>GitGutterPreviewHunk
    2              0.000001   endif
                            
    2              0.000032   if !hasmapto('<Plug>GitGutterTextObjectInnerPending') && maparg('ic', 'o') ==# ''
    2              0.000016     omap <buffer> ic <Plug>GitGutterTextObjectInnerPending
    2              0.000001   endif
    2              0.000044   if !hasmapto('<Plug>GitGutterTextObjectOuterPending') && maparg('ac', 'o') ==# ''
    2              0.000015     omap <buffer> ac <Plug>GitGutterTextObjectOuterPending
    2              0.000001   endif
    2              0.000029   if !hasmapto('<Plug>GitGutterTextObjectInnerVisual') && maparg('ic', 'x') ==# ''
    2              0.000016     xmap <buffer> ic <Plug>GitGutterTextObjectInnerVisual
    2              0.000002   endif
    2              0.000028   if !hasmapto('<Plug>GitGutterTextObjectOuterVisual') && maparg('ac', 'x') ==# ''
    2              0.000015     xmap <buffer> ac <Plug>GitGutterTextObjectOuterVisual
    2              0.000001   endif

FUNCTION  <SNR>80_Filter()
Called 6 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
    6              0.000027     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
                                endif
                            
    6              0.000021     if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
                                endif
                            
    6              0.000020     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
                                endif
                            
    6              0.000012     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
                                endfor
                            
    6              0.000004     return 1

FUNCTION  airline#extensions#default#apply()
Called 12 times
Total time:   0.008521
 Self time:   0.000553

count  total (s)   self (s)
   12              0.000024   let winnr = a:context.winnr
   12              0.000018   let active = a:context.active
                            
   12   0.000097   0.000059   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   12   0.002877   0.000109     call s:build_sections(a:builder, a:context, s:layout[0])
   12              0.000008   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
   12   0.000505   0.000098   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   12   0.000071   0.000042   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   12   0.004787   0.000061     call s:build_sections(a:builder, a:context, s:layout[1])
   12              0.000007   endif
                            
   12              0.000009   return 1

FUNCTION  gitgutter#utility#repo_path()
Called 14 times
Total time:   0.000676
 Self time:   0.000227

count  total (s)   self (s)
   14   0.000365   0.000143   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
   14   0.000293   0.000066   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>111_get_separator_change_with_end()
Called 6 times
Total time:   0.000286
 Self time:   0.000136

count  total (s)   self (s)
    6              0.000007   let sep_change = 0
    6              0.000013   if !empty(a:new_end_group) " Separator between title and the end
    3   0.000108   0.000018     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
    3              0.000001   endif
    6              0.000010   if !empty(a:old_group) " Separator between the title and the one adjacent
    1   0.000038   0.000007     let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
    1              0.000003     if !empty(a:old_end_group) " Remove mis-predicted separator
    1   0.000036   0.000007       let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
    1              0.000000     endif
    1              0.000001   endif
    6              0.000007   return sep_change

FUNCTION  <SNR>126_write_buffer()
Called 3 times
Total time:   0.003317
 Self time:   0.003317

count  total (s)   self (s)
    3              0.000415   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    3              0.000024   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
    3              0.000014   let fenc = getbufvar(a:bufnr, '&fileencoding')
    3              0.000008   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
    3              0.000010   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='ï»¿'.bufcontents[0]
                              endif
                            
    3              0.002796   call writefile(bufcontents, a:file)

FUNCTION  <SNR>91_check_mixed_indent_file()
Called 7 times
Total time:   0.002094
 Self time:   0.002094

count  total (s)   self (s)
    7              0.000038   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    7              0.000022   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    7              0.000010     let head_spc = '\v(^ +)'
    7              0.000002   endif
    7              0.001457   let indent_tabs = search('\v(^\t+)', 'nw')
    7              0.000495   let indent_spc  = search(head_spc, 'nw')
    7              0.000014   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    7              0.000005     return ''
                              endif

FUNCTION  <SNR>126_is_removed()
Called 18 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
   18              0.000033   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>80_InitColor()
Called 4 times
Total time:   0.000334
 Self time:   0.000334

count  total (s)   self (s)
    4              0.000007     if !g:indentLine_setColors
                                    return
                                endif
                            
    4              0.000012     if !exists("g:indentLine_color_term")
    4              0.000007         if &background ==# "light"
                                        let term_color = 249
                                    else
    4              0.000007             let term_color = 239
    4              0.000001         endif
    4              0.000002     else
                                    let term_color = g:indentLine_color_term
                                endif
                            
    4              0.000008     if !exists("g:indentLine_bgcolor_term")
    4              0.000004         let term_bgcolor = "NONE"
    4              0.000003     else
                                    let term_bgcolor = g:indentLine_bgcolor_term
                                endif
                            
    4              0.000008     if !exists("g:indentLine_color_gui")
    4              0.000004         if &background ==# "light"
                                        let gui_color = "Grey70"
                                    else
    4              0.000005             let gui_color = "Grey30"
    4              0.000001         endif
    4              0.000002     else
                                    let gui_color = g:indentLine_color_gui
                                endif
                            
    4              0.000008     if !exists("g:indentLine_bgcolor_gui")
    4              0.000004         let gui_bgcolor = "NONE"
    4              0.000002     else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
                                endif
                            
    4              0.000075     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    4              0.000064     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    4              0.000004     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
                                endif

FUNCTION  gitgutter#utility#windows()
Called 5 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    5              0.000058   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
Called 507 times
Total time:   0.011360
 Self time:   0.011360

count  total (s)   self (s)
  507              0.005242   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  507              0.000761   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
  507              0.000372   return ''

FUNCTION  gitgutter#hunk#summary()
Called 533 times
Total time:   0.009545
 Self time:   0.003720

count  total (s)   self (s)
  533   0.009315   0.003490   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>109_SetUpCompleteopt()
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
    2              0.000011   set completeopt-=menu
    2              0.000005   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
    2              0.000005   set completeopt-=longest
                            
    2              0.000003   if g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
                              endif

FUNCTION  airline#extensions#tabline#load_theme()
Called 5 times
Total time:   0.012492
 Self time:   0.000730

count  total (s)   self (s)
    5              0.000009   if pumvisible()
                                return
                              endif
    5              0.000018   let colors    = get(a:palette, 'tabline', {})
    5              0.000019   let tablabel  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
                              " Theme for tabs on the left
    5              0.000013   let tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
    5              0.000014   let tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
    5              0.000014   let tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
    5              0.000011   let tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
    5              0.000011   let tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
    5              0.000011   let tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
    5              0.000019   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
                                let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
                              else
                                "Fall back to normal airline_c if modified airline_c isn't present
    5              0.000015     let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
    5              0.000005   endif
    5   0.000533   0.000032   call airline#highlighter#exec('airline_tablabel', tablabel)
    5   0.001112   0.000028   call airline#highlighter#exec('airline_tab', tab)
    5   0.000514   0.000026   call airline#highlighter#exec('airline_tabsel', tabsel)
    5   0.001095   0.000029   call airline#highlighter#exec('airline_tabtype', tabtype)
    5   0.000527   0.000026   call airline#highlighter#exec('airline_tabfill', tabfill)
    5   0.001085   0.000024   call airline#highlighter#exec('airline_tabmod', tabmod)
    5   0.001109   0.000029   call airline#highlighter#exec('airline_tabmod_unsel', tabmodu)
    5   0.000610   0.000028   call airline#highlighter#exec('airline_tabhid', tabhid)
                            
                              " Theme for tabs on the right
    5              0.000020   let tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
    5              0.000017   let tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
    5              0.000015   let tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
    5              0.000015   let tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
    5              0.000017   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
                                let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
                              else
                                "Fall back to normal airline_c if modified airline_c isn't present
    5              0.000017     let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
    5              0.000003   endif
    5   0.001203   0.000046   call airline#highlighter#exec('airline_tab_right',    tab_right)
    5   0.001099   0.000032   call airline#highlighter#exec('airline_tabsel_right', tabsel_right)
    5   0.001057   0.000042   call airline#highlighter#exec('airline_tabmod_right', tabmod_right)
    5   0.001081   0.000026   call airline#highlighter#exec('airline_tabhid_right', tabhid_right)
    5   0.001135   0.000030   call airline#highlighter#exec('airline_tabmod_unsel_right', tabmodu_right)

FUNCTION  <SNR>46_filename()
Called 2 times
Total time:   0.000060
 Self time:   0.000011

count  total (s)   self (s)
    2   0.000059   0.000010   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  337()
Called 3 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000043     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  339()
Called 5 times
Total time:   0.007318
 Self time:   0.002254

count  total (s)   self (s)
    5   0.000477   0.000178     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    5   0.000170   0.000028     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   30              0.000051     for type in self._enabled_types
   25              0.000705         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   25   0.001015   0.000304         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   20              0.000085             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    5              0.000026                 if !exists('b:syntastic_private_' . type . '_stamp')
    2              0.000010                     let b:syntastic_private_{type}_stamp = []
    2              0.000002                 endif
    5   0.000234   0.000047                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    5   0.001113   0.000066                     call self._notifier[type].refresh(a:loclist)
    5   0.000296   0.000073                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    5              0.000006                 endif
    5              0.000004             else
   15   0.002547   0.000092                 call self._notifier[type].refresh(a:loclist)
   15              0.000010             endif
   20              0.000014         endif
   25              0.000019     endfor

FUNCTION  <SNR>128_upsert_new_gitgutter_signs()
Called 3 times
Total time:   0.004848
 Self time:   0.003868

count  total (s)   self (s)
    3   0.000080   0.000036   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    3   0.000035   0.000015   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
  107              0.000103   for line in a:modified_lines
  104              0.000166     let line_number = line[0]  " <number>
  104              0.000178     if index(other_signs, line_number) == -1  " don't clobber others' signs
  104   0.001240   0.000504       let name = s:highlight_name_for_change(line[1])
  104              0.000209       if !has_key(old_gitgutter_signs, line_number)  " insert
   52   0.000349   0.000169         let id = s:next_sign_id()
   52              0.001491         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
   52              0.000027       else  " update if sign has changed
   52              0.000095         let old_sign = old_gitgutter_signs[line_number]
   52              0.000076         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
   52              0.000030       endif
  104              0.000043     endif
  104              0.000136   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  gitgutter#init_buffer()
Called 2 times
Total time:   0.004521
 Self time:   0.000186

count  total (s)   self (s)
    2   0.000412   0.000018   if gitgutter#utility#is_active(a:bufnr)
    2   0.000516   0.000034     call s:setup_maps()
    2   0.000073   0.000032     let p = gitgutter#utility#repo_path(a:bufnr, 0)
    2              0.000006     if type(p) != s:t_string || empty(p)
    2   0.003499   0.000081       call gitgutter#utility#set_repo_path(a:bufnr)
    2              0.000004     endif
    2              0.000000   endif

FUNCTION  airline#parts#crypt()
Called 507 times
Total time:   0.002752
 Self time:   0.002752

count  total (s)   self (s)
  507              0.002501   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>91_ws_refresh()
Called 12 times
Total time:   0.277672
 Self time:   0.000303

count  total (s)   self (s)
   12              0.000089   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    7              0.000010     return
                              endif
    5              0.000026   unlet! b:airline_whitespace_check
    5              0.000018   if get(g:, 'airline_skip_empty_sections', 0)
    5   0.277479   0.000110     exe ':AirlineRefresh'
    5              0.000001   endif
    5              0.000009   let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#extensions#keymap#status()
Called 507 times
Total time:   0.005580
 Self time:   0.005580

count  total (s)   self (s)
  507              0.002803   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  507              0.002381     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>87_is_branch_empty()
Called 507 times
Total time:   0.002781
 Self time:   0.002781

count  total (s)   self (s)
  507              0.002600   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>92_wordcount_update()
Called 374 times
Total time:   0.020878
 Self time:   0.020878

count  total (s)   self (s)
  374              0.001031   if empty(bufname(''))
                                return
                              endif
  374              0.010629   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  airline#util#strchars()
Called 11 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
   11              0.000027   if exists('*strchars')
   11              0.000022     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  syntastic#log#debugDump()
Called 3 times
Total time:   0.000031
 Self time:   0.000020

count  total (s)   self (s)
    3   0.000027   0.000016     if !s:_isDebugEnabled(a:level)
    3              0.000003         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>124_on_stderr_vim()
Called 2 times
Total time:   0.000219
 Self time:   0.000101

count  total (s)   self (s)
    2   0.000179   0.000061   call self.handler.err(self.buffer)
    2              0.000002   try
    2              0.000009     call ch_close(a:channel)  " so close_cb and its 'out' handler are not triggered
                              catch /E906/
                                " noop
    2              0.000004   endtry

FUNCTION  <SNR>5_isAnsible()
Called 2 times
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
    2              0.000031   let filepath = expand("%:p")
    2              0.000005   let filename = expand("%:t")
    2              0.000049   if filepath =~ '\v/(tasks|roles|handlers)/.*\.ya?ml$' | return 1 | en
    2              0.000038   if filepath =~ '\v/(group|host)_vars/' | return 1 | en
    2              0.000037   if filename =~ '\v(playbook|site|main|local)\.ya?ml$' | return 1 | en
                            
    2              0.000007   let shebang = getline(1)
    2              0.000012   if shebang =~# '^#!.*/bin/env\s\+ansible-playbook\>' | return 1 | en
    2              0.000008   if shebang =~# '^#!.*/bin/ansible-playbook\>' | return 1 | en
                            
    2              0.000002   return 0

FUNCTION  airline#extensions#load_theme()
Called 5 times
Total time:   0.012719
 Self time:   0.000046

count  total (s)   self (s)
    5   0.012716   0.000043   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  gitgutter#diff#run_diff()
Called 3 times
Total time:   0.028438
 Self time:   0.019416

count  total (s)   self (s)
    6   0.000470   0.000226   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
    3   0.018192   0.017891     sleep 5m
    3              0.000049   endwhile
                            
    3   0.000093   0.000020   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    3              0.000006   let cmd = '('
                            
                              " Append buffer number to avoid race conditions between writing and reading
                              " the files when asynchronously processing multiple buffers.
                              "
                              " Without the buffer number, index_file would have a race in the shell
                              " between the second process writing it (with git-show) and the first
                              " reading it (with git-diff).
    3              0.000024   let index_file = s:temp_index.'.'.a:bufnr
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    3              0.000015   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
    3   0.000311   0.000100   let extension = gitgutter#utility#extension(a:bufnr)
    3              0.000012   if !empty(extension)
                                let index_file .= '.'.extension
                                let buff_file .= '.'.extension
                              endif
                            
                              " Write file from index to temporary file.
    3   0.000348   0.000030   let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    3              0.000026   let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.index_file.' && '
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    3   0.003586   0.000269   call s:write_buffer(a:bufnr, buff_file)
                            
                              " Call git-diff with the temporary files.
    3              0.000023   let cmd .= g:gitgutter_git_executable.' --no-pager'
    3              0.000005   if s:c_flag
    3              0.000009     let cmd .= ' -c "diff.autorefreshindex=0"'
    3              0.000008     let cmd .= ' -c "diff.noprefix=false"'
    3              0.000006     let cmd .= ' -c "core.safecrlf=false"'
    3              0.000004   endif
    3              0.000024   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.index_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    3              0.000013   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    3   0.000159   0.000031     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    3              0.000002   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    3              0.000008   let cmd .= ' || exit 0'
                            
    3              0.000005   let cmd .= ')'
                            
    3   0.000636   0.000034   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    3   0.000022   0.000014   if g:gitgutter_async && gitgutter#async#available()
    3   0.004059   0.000239     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    3              0.000038     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>111_get_separator_change()
Called 5 times
Total time:   0.000281
 Self time:   0.000085

count  total (s)   self (s)
    5   0.000280   0.000084   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  GitGutterGetHunkSummary()
Called 507 times
Total time:   0.011497
 Self time:   0.002365

count  total (s)   self (s)
  507   0.011297   0.002165   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 507 times
Total time:   0.012370
 Self time:   0.004219

count  total (s)   self (s)
  507   0.012044   0.003893   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>105_get_section()
Called 132 times
Total time:   0.003800
 Self time:   0.003453

count  total (s)   self (s)
  132              0.000288   if has_key(s:section_truncate_width, a:key)
   96              0.000245     if winwidth(a:winnr) < s:section_truncate_width[a:key]
   12              0.000008       return ''
                                endif
   84              0.000040   endif
  120              0.000150   let spc = g:airline_symbols.space
  120              0.000451   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
  120   0.001018   0.000671   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  120              0.000684   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  120              0.000383   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#extensions#tabline#buflist#invalidate()
Called 6 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    6              0.000021   unlet! s:current_buffer_list

FUNCTION  airline#extensions#quickfix#apply()
Called 12 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
   12              0.000035   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 10 times
Total time:   0.000384
 Self time:   0.000116

count  total (s)   self (s)
   10   0.000184   0.000032   let summary = gitgutter#hunk#summary(a:bufnr)
   10              0.000015   let summary[2] += a:count
   10   0.000175   0.000059   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  syntastic#util#fname2buf()
Called 9 times
Total time:   0.002482
 Self time:   0.002482

count  total (s)   self (s)
    9              0.000054     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
    9              0.000019     let buf = -1
   15              0.000054     for md in [':~:.', ':~', ':p']
   15              0.000019         try
                                        " Older versions of Vim can throw E94 here
   15              0.001827             let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
   15              0.000029         catch
                                        " catch everything
                                    endtry
   15              0.000030         if buf != -1
    9              0.000011             break
                                    endif
    6              0.000109     endfor
    9              0.000013     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
                                endif
                            
    9              0.000032     if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
    9              0.000013     return buf

FUNCTION  <SNR>109_DisableOnLargeFile()
Called 374 times
Total time:   0.001794
 Self time:   0.001794

count  total (s)   self (s)
  374              0.000975   if exists( 'b:ycm_largefile' )
  372              0.000479     return b:ycm_largefile
                              endif
                            
    2              0.000004   let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
    2              0.000050   let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
    2              0.000002   if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
    2              0.000002   return b:ycm_largefile

FUNCTION  gitgutter#diff#handler()
Called 3 times
Total time:   0.134165
 Self time:   0.000667

count  total (s)   self (s)
    3   0.000172   0.000049   call gitgutter#debug#log(a:diff)
                            
    3   0.002181   0.000096   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    3   0.004643   0.000080   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    3              0.000006   let signs_count = len(modified_lines)
    3              0.000006   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    3              0.000004     if g:gitgutter_signs || g:gitgutter_highlight_lines
    3   0.126945   0.000283       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    3              0.000001     endif
    3              0.000000   endif
                            
    3   0.000132   0.000067   call s:save_last_seen_change(a:bufnr)
    3              0.000018   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  <SNR>91_check_mixed_indent()
Called 7 times
Total time:   0.086020
 Self time:   0.086020

count  total (s)   self (s)
    7              0.000024   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    7              0.000008   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    7              0.085921     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>58_BufWritePostHook()
Called 3 times
Total time:   0.018214
 Self time:   0.000225

count  total (s)   self (s)
    3   0.001253   0.000071     let buf = syntastic#util#fname2buf(a:fname)
    3   0.000115   0.000062     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . buf . ' = ' . string(a:fname))
    3   0.016839   0.000085     call s:UpdateErrors(buf, 1, [])

FUNCTION  <SNR>11_LoadIndent()
Called 2 times
Total time:   0.001076
 Self time:   0.000729

count  total (s)   self (s)
    2              0.000008     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    2              0.000006     let s = expand("<amatch>")
    2              0.000004     if s != ""
    2              0.000004       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000016       for name in split(s, '\.')
    2   0.001008   0.000661 	exe 'runtime! indent/' . name . '.vim'
    2              0.000003       endfor
    2              0.000002     endif

FUNCTION  airline#extensions#wordcount#apply()
Called 12 times
Total time:   0.000403
 Self time:   0.000403

count  total (s)   self (s)
   12              0.000357   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  <SNR>101_hl_group_exists()
Called 454 times
Total time:   0.006321
 Self time:   0.006321

count  total (s)   self (s)
  454              0.001900   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  454              0.000340   return 1

FUNCTION  <SNR>13_SynSet()
Called 2 times
Total time:   0.039187
 Self time:   0.001426

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000008   syn clear
    2              0.000006   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    2              0.000006   let s = expand("<amatch>")
    2              0.000003   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    2              0.000002   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000017     for name in split(s, '\.')
    2   0.039098   0.001337       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    2              0.000002     endfor
    2              0.000002   endif

FUNCTION  airline#extensions#tabline#builder#new()
Called 2 times
Total time:   0.000124
 Self time:   0.000047

count  total (s)   self (s)
    2   0.000094   0.000017   let builder = airline#builder#new(a:context)
    2              0.000005   let builder._build = builder.build
    2              0.000017   call extend(builder, s:prototype, 'force')
    2              0.000002   return builder

FUNCTION  <SNR>5_SelectJavascript()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000012   if getline(1) =~# '^#!.*/bin/\%(env\s\+\)\?node\>'
                                set ft=javascript
                              endif

FUNCTION  <SNR>58_CacheErrors()
Called 3 times
Total time:   0.010029
 Self time:   0.001353

count  total (s)   self (s)
    3   0.000075   0.000038     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    3   0.002950   0.000146     call s:ClearCache(a:buf)
    3   0.000162   0.000019     let newLoclist = g:SyntasticLoclist.New([])
    3   0.000037   0.000015     call newLoclist.setOwner(a:buf)
                            
    3   0.000384   0.000015     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    3   0.000104   0.000067         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    3   0.000117   0.000066         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
    3   0.000070   0.000041             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    3   0.000047   0.000024             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
    3              0.000003         endif
    3   0.000067   0.000021         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    3   0.000124   0.000094         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    3   0.003294   0.000044         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
    3   0.000098   0.000035         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
    3   0.000058   0.000017         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    3   0.000056   0.000017         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    3              0.000005         let names = []
    3              0.000006         let unavailable_checkers = 0
    6              0.000013         for checker in clist
    3   0.000053   0.000039             let cname = checker.getCName()
    3   0.001063   0.000017             if !checker.isAvailable()
    3   0.000052   0.000023                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
    3              0.000009                 let unavailable_checkers += 1
    3              0.000005                 continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            call newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
    3              0.000009         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    3              0.000027         if len(clist) == unavailable_checkers
    3              0.000012             if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
    3   0.000109   0.000059                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
    3              0.000003             endif
    3              0.000002         endif
                                    " }}}3
                            
    3   0.000055   0.000022         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    3              0.000005         if sort_aggregated_errors
    3   0.000088   0.000015             call newLoclist.sort()
    3   0.000055   0.000020             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
    3              0.000004         endif
    3              0.000002     endif
                            
    3   0.000448   0.000036     call newLoclist.deploy()

FUNCTION  gitgutter#hunk#reset()
Called 1 time
Total time:   0.000089
 Self time:   0.000045

count  total (s)   self (s)
    1   0.000036   0.000013   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
    1   0.000052   0.000031   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>80_Setup()
Called 2 times
Total time:   0.000969
 Self time:   0.000087

count  total (s)   self (s)
    2              0.000004     if &filetype ==# ""
                                    call s:InitColor()
                                endif
                            
    2   0.000073   0.000011     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
    2   0.000816   0.000042         call s:IndentLinesEnable()
    2              0.000001     endif
                            
    2   0.000060   0.000014     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif

FUNCTION  <SNR>109_UpdateMatches()
Called 2 times
Total time:   0.000863
 Self time:   0.000863

count  total (s)   self (s)
    2              0.000861   exec s:python_command "ycm_state.UpdateMatches()"

FUNCTION  airline#extensions#apply()
Called 12 times
Total time:   0.001087
 Self time:   0.000560

count  total (s)   self (s)
   12              0.000035   let s:active_winnr = winnr()
                            
   12   0.000599   0.000072   if s:is_excluded_window()
                                return -1
                              endif
                            
   12              0.000018   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   12              0.000012   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   12              0.000045   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
   12              0.000039   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  <SNR>109_PollFileParseResponse()
Called 2 times
Total time:   0.006711
 Self time:   0.006245

count  total (s)   self (s)
    2   0.000384   0.000055   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    2              0.006112   exec s:python_command "ycm_state.HandleFileParseRequest()"
    2   0.000170   0.000033   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  syntastic#util#unique()
Called 12 times
Total time:   0.000424
 Self time:   0.000424

count  total (s)   self (s)
   12              0.000031     let seen = {}
   12              0.000021     let uniques = []
   24              0.000043     for e in a:list
   12              0.000042         let k = string(e)
   12              0.000038         if !has_key(seen, k)
   12              0.000030             let seen[k] = 1
   12              0.000038             call add(uniques, e)
   12              0.000012         endif
   12              0.000013     endfor
   12              0.000017     return uniques

FUNCTION  gitgutter#utility#is_active()
Called 13 times
Total time:   0.004912
 Self time:   0.000449

count  total (s)   self (s)
   13   0.004884   0.000421   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  265()
Called 5 times
Total time:   0.000648
 Self time:   0.000068

count  total (s)   self (s)
    5   0.000071   0.000026     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    5   0.000572   0.000037     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  266()
Called 5 times
Total time:   0.000535
 Self time:   0.000326

count  total (s)   self (s)
    5   0.000080   0.000020     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    5   0.000083   0.000022     let auto_loc_list = syntastic#util#var('auto_loc_list')
    5   0.000028   0.000016     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
    5              0.000029         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
    3              0.000004             try
                                            " Vim 7.4.2200 or later
    3              0.000026                 let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
    3              0.000005             catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
    3              0.000011             if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
    3   0.000117   0.000041                 call SyntasticLoclistHide()
                            
    3              0.000003                 try
                                                " Vim 7.4.2200 or later
    3              0.000019                     call setloclist(0, [], 'r', { 'title': '' })
    3              0.000003                 catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
    3              0.000008                 let w:syntastic_loclist_set = []
    3              0.000002             endif
    3              0.000003         endif
    5              0.000004     endif

FUNCTION  268()
Called 5 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    5              0.000031     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  <SNR>82_is_excluded_window()
Called 12 times
Total time:   0.000527
 Self time:   0.000527

count  total (s)   self (s)
   12              0.000034   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   48              0.000056   for matchw in g:airline_exclude_filenames
   36              0.000224     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   36              0.000011   endfor
                            
   12              0.000015   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   12              0.000008   return 0

FUNCTION  airline#builder#should_change_group()
Called 44 times
Total time:   0.001333
 Self time:   0.000839

count  total (s)   self (s)
   44              0.000082   if a:group1 == a:group2
                                return 0
                              endif
   44   0.000484   0.000211   let color1 = airline#highlighter#get_highlight(a:group1)
   44   0.000380   0.000159   let color2 = airline#highlighter#get_highlight(a:group2)
   44              0.000065   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   44              0.000125     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>46_exists_file()
Called 13 times
Total time:   0.001615
 Self time:   0.000541

count  total (s)   self (s)
   13   0.001601   0.000527   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  syntastic#util#setLastTick()
Called 6 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    6              0.000046     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  airline#highlighter#get_highlight()
Called 873 times
Total time:   0.047062
 Self time:   0.022274

count  total (s)   self (s)
  873              0.003641   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
  543              0.000783     return s:hl_groups[a:group]
                              else
  330   0.012983   0.001674     let fg = s:get_syn(a:group, 'fg')
  330   0.012259   0.001752     let bg = s:get_syn(a:group, 'bg')
  330              0.005432     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  330              0.002051     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  330              0.000464     let opts = a:000
  330              0.000325     if bold
   77              0.000115       let opts = ['bold']
   77              0.000039     endif
  330   0.005247   0.002275     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
  330              0.000239   endif
  330              0.001006   let s:hl_groups[a:group] = res
  330              0.000323   return res

FUNCTION  gitgutter#diff#parse_diff()
Called 3 times
Total time:   0.001814
 Self time:   0.000416

count  total (s)   self (s)
    3              0.000007   let hunks = []
   27              0.000073   for line in split(a:diff, '\n')
   24   0.001568   0.000170     let hunk_info = gitgutter#diff#parse_hunk(line)
   24              0.000040     if len(hunk_info) == 4
   24              0.000064       call add(hunks, hunk_info)
   24              0.000013     endif
   24              0.000012   endfor
    3              0.000003   return hunks

FUNCTION  <SNR>124_on_stdout_vim()
Called 25 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
   25              0.000085   call add(self.stdoutbuffer, a:data)

FUNCTION  270()
Called 3 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    3              0.000013     let b:syntastic_private_balloons = {}
    3              0.000018     if has('balloon_eval')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    unlet! b:syntastic_private_balloons
                                    set noballooneval
                                endif

FUNCTION  271()
Called 2 times
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
    2              0.000040     let newObj = copy(self)
                            
    2              0.000008     let newObj._filetype = a:args['filetype']
    2              0.000005     let newObj._name = a:args['name']
                            
    2              0.000002     if a:0
                                    " redirected checker
                                    let newObj._exec_default = get(a:args, 'exec', a:1['_exec_default'])
                            
                                    let filetype = a:1['_filetype']
                                    let name = a:1['_name']
                                    let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
                                    if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
                                else
    2              0.000011         let newObj._exec_default = get(a:args, 'exec', newObj._name)
    2              0.000005         if newObj._exec_default ==# ''
                                        let newObj._exec_default = '<dummy>'
                                    endif
    2              0.000010         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
    2              0.000005         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    endif
    2              0.000002     endif
                            
    2              0.000012     let newObj._locListFunc = function(prefix . 'GetLocList')
                            
    2              0.000011     if exists('*' . prefix . 'IsAvailable')
    1              0.000005         let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
    1              0.000001     else
    1              0.000006         let newObj._isAvailableFunc = function('s:_isAvailableDefault')
    1              0.000001     endif
                            
    2              0.000010     if exists('*' . prefix . 'GetHighlightRegex')
    1              0.000006         let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
    1              0.000001     endif
                            
    2              0.000002     return newObj

FUNCTION  272()
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003     return self._filetype

FUNCTION  273()
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004     return self._name

FUNCTION  274()
Called 4 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    4              0.000016     return self._filetype . '/' . self._name

FUNCTION  275()
Called 3 times
Total time:   0.000263
 Self time:   0.000145

count  total (s)   self (s)
    3              0.000006     if a:0
                                    let self._exec = a:1
                                else
    3              0.000009         let suffix = self._name . '_exec'
    3   0.000232   0.000114         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    3              0.000004     endif

FUNCTION  <SNR>58_UpdateErrors()
Called 3 times
Total time:   0.016754
 Self time:   0.000870

count  total (s)   self (s)
    3   0.000140   0.000089     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    3   0.000120   0.000086     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
    3   0.000093   0.000062     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    3   0.000101   0.000068     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    3   0.000168   0.000042     call s:modemap.synch()
                            
    3   0.000622   0.000052     if s:_skip_file(a:buf)
                                    return
                                endif
                            
    3   0.000633   0.000066     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
    3              0.000005     if run_checks
    3   0.010116   0.000087         call s:CacheErrors(a:buf, a:checker_names)
    3   0.000082   0.000057         call syntastic#util#setLastTick(a:buf)
    3              0.000005     elseif a:auto_invoked
                                    return
                                endif
                            
    3   0.000121   0.000020     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    3              0.000012     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    3   0.000064   0.000015     let do_jump = syntastic#util#var('auto_jump') + 0
    3              0.000004     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    3   0.000061   0.000014     if syntastic#util#var('always_populate_loc_list') || do_jump
    3   0.000295   0.000033         call loclist.setloclist(1)
    3              0.000009         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    3              0.000003     endif
                                " }}}3
                            
    3   0.003975   0.000016     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>58_BufEnterHook()
Called 2 times
Total time:   0.005336
 Self time:   0.000562

count  total (s)   self (s)
    2   0.000681   0.000036     let buf = syntastic#util#fname2buf(a:fname)
    2   0.000275   0.000181     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    2              0.000013     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    2              0.000016         let idx = index(reverse(copy(s:_check_stack)), buf)
    2              0.000003         if idx >= 0
                                        if !has('vim_starting')
                                            call remove(s:_check_stack, -idx - 1)
                                            call s:UpdateErrors(buf, 1, [])
                                        endif
                                    elseif &buftype ==# ''
    2   0.004278   0.000243             call s:notifiers.refresh(g:SyntasticLoclist.current())
    2              0.000001         endif
    2              0.000002     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  airline#extensions#tabline#new_builder()
Called 2 times
Total time:   0.000269
 Self time:   0.000145

count  total (s)   self (s)
    2              0.000025   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    2              0.000009   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
    2              0.000011     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
    2              0.000008     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    2              0.000002   endif
                            
    2   0.000188   0.000064   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  <SNR>58__is_quitting()
Called 6 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    6              0.000012     let quitting = 0
    6              0.000027     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
    6              0.000010     return quitting

FUNCTION  282()
Called 1 time
Total time:   0.000039
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000011   0.000007     let leader = self.getCName() . ': '
    1              0.000002     if a:0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
                                else
    1   0.000019   0.000007         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
    1              0.000001     endif

FUNCTION  284()
Called 3 times
Total time:   0.001046
 Self time:   0.000164

count  total (s)   self (s)
    3   0.000316   0.000053     call self.syncExec()
                            
    3              0.000010     if !has_key(self, '_available')
    1              0.000003         let self._available = {}
    1              0.000001     endif
    3              0.000009     if !has_key(self._available, self._exec)
    1   0.000680   0.000061         let self._available[self._exec] = self._isAvailableFunc()
    1              0.000001     endif
                            
    3              0.000006     return self._available[self._exec]

FUNCTION  airline#extensions#tabline#tabs#invalidate()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007   let s:current_bufnr = -1

FUNCTION  <SNR>109_ReceiveMessages()
Called 4 times
Total time:   0.006386
 Self time:   0.000237

count  total (s)   self (s)
    4   0.006225   0.000076   let poll_again = s:Pyeval( 'ycm_state.OnPeriodicTick()' )
                            
    4              0.000031   if poll_again
    2              0.000060     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    2              0.000003   else
                                " Don't poll again until we open another buffer
    2              0.000009     let s:pollers.receive_messages.id = -1
    2              0.000003   endif

FUNCTION  airline#extensions#hunks#get_hunks()
Called 507 times
Total time:   0.072043
 Self time:   0.040496

count  total (s)   self (s)
  507              0.001412   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
  507              0.007474   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
  507   0.033474   0.001927   let hunks = s:get_hunks()
  507              0.000567   let string = ''
  507              0.000807   if !empty(hunks)
 2028              0.002645     for i in [0, 1, 2]
 1521              0.004816       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
 1509              0.007112         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
 1509              0.000903       endif
 1521              0.002536     endfor
  507              0.000310   endif
  507              0.000878   let b:airline_hunks = string
  507              0.000919   let b:airline_changenr = b:changedtick
  507              0.001022   let s:airline_winwidth = winwidth(0)
  507              0.000525   return string

FUNCTION  <SNR>109_StartMessagePoll()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000004   if s:pollers.receive_messages.id < 0
    2              0.000015     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    2              0.000001   endif

FUNCTION  <SNR>109_VisitedBufferRequiresReparse()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000008   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
    2              0.000002     return 0
                              endif
                            
                              return s:AllowedToCompleteInCurrentBuffer()

FUNCTION  292()
Called 10 times
Total time:   0.000216
 Self time:   0.000065

count  total (s)   self (s)
   10   0.000210   0.000059     return syntastic#util#var('echo_current_error')

FUNCTION  293()
Called 5 times
Total time:   0.000235
 Self time:   0.000117

count  total (s)   self (s)
    5   0.000168   0.000050     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  294()
Called 3 times
Total time:   0.000102
 Self time:   0.000067

count  total (s)   self (s)
    3   0.000055   0.000020     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    3              0.000020     autocmd! syntastic CursorMoved
    3              0.000007     unlet! b:syntastic_private_messages
    3              0.000008     let b:syntastic_private_line = -1

FUNCTION  296()
Called 10 times
Total time:   0.000311
 Self time:   0.000116

count  total (s)   self (s)
   10   0.000306   0.000111     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  297()
Called 5 times
Total time:   0.001572
 Self time:   0.000309

count  total (s)   self (s)
    5   0.000187   0.000018     if self.enabled()
    5   0.000082   0.000031         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    5   0.001053   0.000027         call self._reset()
    5              0.000016         let buf = bufnr('')
    5   0.000055   0.000038         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    5              0.000010         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    5              0.000004     endif

FUNCTION  298()
Called 3 times
Total time:   0.000921
 Self time:   0.000056

count  total (s)   self (s)
    3              0.000008     if s:has_highlighting
    3   0.000057   0.000019         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    3   0.000848   0.000021         call self._reset()
    3              0.000003     endif

FUNCTION  gitgutter#utility#getbufvar()
Called 574 times
Total time:   0.006406
 Self time:   0.006406

count  total (s)   self (s)
  574              0.003287   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  574              0.001503   if has_key(dict, a:varname)
  568              0.001012     return dict[a:varname]
                              else
    6              0.000004     if a:0
    2              0.000002       return a:1
                                endif
    4              0.000001   endif

FUNCTION  <SNR>105_add_section()
Called 96 times
Total time:   0.006240
 Self time:   0.002475

count  total (s)   self (s)
   96              0.000355     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   96   0.001170   0.000444     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
   96              0.000075     if condition
                                  call a:builder.add_raw('%(')
                                endif
   96   0.003856   0.000817     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   96              0.000085     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  SyntasticStatuslineFlag()
Called 24 times
Total time:   0.002604
 Self time:   0.000290

count  total (s)   self (s)
   24   0.002590   0.000276     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  airline#extensions#syntastic#get_warning()
Called 12 times
Total time:   0.001791
 Self time:   0.000102

count  total (s)   self (s)
   12   0.001781   0.000092   return airline#extensions#syntastic#get('warning')

FUNCTION  airline#highlighter#reset_hlcache()
Called 5 times
Total time:   0.000497
 Self time:   0.000497

count  total (s)   self (s)
    5              0.000494   let s:hl_groups = {}

FUNCTION  <SNR>112_ExcludeOther()
Called 3 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    3              0.000026   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
                                return 1 | endif

FUNCTION  airline#util#prepend()
Called 515 times
Total time:   0.003624
 Self time:   0.003624

count  total (s)   self (s)
  515              0.001140   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  515              0.001549   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>41_airline_refresh()
Called 5 times
Total time:   0.277369
 Self time:   0.000531

count  total (s)   self (s)
    5              0.000023   if !exists("#airline")
                                " disabled
                                return
                              endif
    5              0.000011   let nomodeline=''
    5              0.000019   if v:version > 703 || v:version == 703 && has("patch438")
    5              0.000010     let nomodeline = '<nomodeline>'
    5              0.000003   endif
    5   0.000465   0.000253   exe printf("silent doautocmd %s User AirlineBeforeRefresh", nomodeline)
    5   0.000602   0.000105   call airline#highlighter#reset_hlcache()
    5   0.249255   0.000061   call airline#load_theme()
    5   0.026953   0.000018   call airline#update_statusline()

FUNCTION  <SNR>109_OnBufferEnter()
Called 2 times
Total time:   0.000076
 Self time:   0.000063

count  total (s)   self (s)
    2   0.000072   0.000059   if !s:VisitedBufferRequiresReparse()
    2              0.000001     return
                              endif
                            
                              call s:SetUpCompleteopt()
                              call s:SetCompleteFunc()
                              call s:StartMessagePoll()
                            
                              exec s:python_command "ycm_state.OnBufferVisit()"
                              " Last parse may be outdated because of changes from other buffers. Force a
                              " new parse.
                              call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>126_is_modified_and_added()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000008   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  <SNR>104_get_transitioned_seperator()
Called 55 times
Total time:   0.021511
 Self time:   0.001907

count  total (s)   self (s)
   55              0.000060   let line = ''
   55   0.010956   0.000302   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   55              0.000239   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
   55   0.009260   0.000310     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   55              0.000221     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   55              0.000167     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   55              0.000127     let line .= '%#'.a:group.'#'
   55              0.000034   endif
   55              0.000052   return line

FUNCTION  <SNR>128_remove_signs()
Called 3 times
Total time:   0.055442
 Self time:   0.055411

count  total (s)   self (s)
    3   0.000034   0.000016   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
    2   0.000020   0.000007     let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
    2              0.000010     execute "sign unplace * buffer=" . a:bufnr
    2              0.000002     if dummy_sign_present
    1              0.055341       execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
    1              0.000003     endif
    2              0.000001   else
    1              0.000002     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    1              0.000001   endif

FUNCTION  gitgutter#hunk#set_hunks()
Called 3 times
Total time:   0.000271
 Self time:   0.000053

count  total (s)   self (s)
    3   0.000142   0.000022   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    3   0.000127   0.000029   call s:reset_summary(a:bufnr)

FUNCTION  airline#builder#new()
Called 14 times
Total time:   0.000347
 Self time:   0.000347

count  total (s)   self (s)
   14              0.000098   let builder = copy(s:prototype)
   14              0.000026   let builder._context = a:context
   14              0.000032   let builder._sections = []
                            
   14              0.000144   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   14              0.000014   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   12   0.277672   0.000303  <SNR>91_ws_refresh()
    5   0.277369   0.000531  <SNR>41_airline_refresh()
    5   0.249194   0.000429  airline#load_theme()
   12   0.218527   0.000948  airline#update_statusline()
   12   0.217527   0.000529  <SNR>84_invoke_funcrefs()
   16   0.212418   0.009504  374()
  127   0.174603   0.020998  <SNR>104_section_is_empty()
   12   0.148117   0.059816  airline#extensions#whitespace#check()
    5   0.134533   0.000246  <SNR>124_on_exit_vim()
    3   0.134165   0.000667  gitgutter#diff#handler()
    2   0.131529   0.000047  <SNR>4_StarSetf()
    3   0.126220   0.000468  gitgutter#sign#update_signs()
  475   0.093007   0.029456  airline#highlighter#exec()
    5   0.087114   0.000339  airline#highlighter#load_theme()
   10   0.086775   0.012619  airline#highlighter#highlight()
    7   0.086020             <SNR>91_check_mixed_indent()
  507   0.072043   0.040496  airline#extensions#hunks#get_hunks()
  507   0.066254   0.008823  airline#parts#readonly()
    1   0.059614   0.059587  <SNR>128_add_dummy_sign()
  509   0.057586             airline#util#ignore_buf()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    7              0.086020  <SNR>91_check_mixed_indent()
   12   0.148117   0.059816  airline#extensions#whitespace#check()
    1   0.059614   0.059587  <SNR>128_add_dummy_sign()
  509              0.057586  airline#util#ignore_buf()
    3   0.055442   0.055411  <SNR>128_remove_signs()
  507              0.044012  airline#check_mode()
  507   0.072043   0.040496  airline#extensions#hunks#get_hunks()
  372              0.039407  <SNR>72_Highlight_Matching_Pair()
  372   0.049225   0.032395  <SNR>109_OnCursorMovedNormalMode()
 3549              0.030683  airline#util#append()
  475   0.093007   0.029456  airline#highlighter#exec()
  873   0.047062   0.022274  airline#highlighter#get_highlight()
  660              0.021816  <SNR>101_get_syn()
  127   0.174603   0.020998  <SNR>104_section_is_empty()
  374              0.020878  <SNR>92_wordcount_update()
    3   0.028438   0.019416  gitgutter#diff#run_diff()
    2              0.018924  UltiSnips#SnippetsInCurrentScope()
  475              0.013654  <SNR>101_CheckDefined()
  375   0.015102   0.013308  <SNR>109_AllowedToCompleteInBuffer()
   10   0.086775   0.012619  airline#highlighter#highlight()

